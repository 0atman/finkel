;;; Forms containing language pragmas.

#p(LANGUAGE BangPatterns
            DeriveDataTypeable
            DeriveFoldable
            DeriveFunctor
            DeriveGeneric
            DeriveTraversable
            GADTs
            GeneralizedNewtypeDeriving
            OverloadedLists
            OverloadedStrings)

(module Main)

(import Data.Data)
(import GHC.Generics)
(import Data.ByteString ((ByteString)))
(import Data.Set ((Set)))

;; BangPatterns

(:: bp01 (-> Int Int Int))
(= bp01 !a !b (+ a b))

(:: bp02 (-> (, Int Int) (IO ())))
(= bp02 (, !a b)
  (print (if (even a) b a)))

(:: bp03 (-> Int (IO ())))
(= bp03 n
  (let ((= !x (* n 2))
        (= f i (, () (replicate i ())))
        (= (, !y _) (f n)))
    (>> (print x) (print y))))

(:: bp04 (-> Int (IO ())))
(= bp04 n
  (let ((:: f (-> a [a]))
        (= f x [x x x]))
    (case (f n)
      !ys (print (length ys)))))

(:: bp05 (-> Int (IO ())))
(= bp05 n
  (let ((= ![x y] (replicate 2 n))
        (= !(, a b) (, n n)))
    (do (print (+ x y))
        (print (+ a b)))))

(:: non-bp01 (-> Int (IO ())))
(= non-bp01 n
  (let ((= ! a b (+ a b)))
    (print (! n (+ n 2)))))

(:: bangpatterns (IO ()))
(= bangpatterns
  (do (print (bp01 10 32))
      (bp02 (, 21 42))
      (bp03 21)
      (bp04 21)
      (bp05 21)
      (non-bp01 20)))

;;; DeriveDataTypeable

(data (D1 a)
  (D1 a a)
  (deriving (Eq Show Data Typeable)))

;;; DeriveFunctor

(data (D2 a)
  (D2 a)
  (deriving (Eq Show Functor)))

;;; DeriveGeneric

(data (D3 a)
  (D3 a)
  (deriving (Eq Show Generic)))

;;; DeriveFoldable, DeriveTraversable

(data (Lst a)
  Nil
  (Cons a (Lst a))
  (deriving (Eq Show Functor Foldable Traversable)))

;;; GADTs

(data (Expr a)
  (:: I (-> Int (Expr Int)))
  (:: B (-> Bool (Expr Bool)))
  (:: Add (-> (Expr Int) (Expr Int) (Expr Int)))
  (:: Mul (-> (Expr Int) (Expr Int) (Expr Int)))
  (:: Eq (=> (Eq a) (-> (Expr a) (Expr a) (Expr Bool)))))

(:: eval (-> (Expr a) a))
(= eval e
  (case e
    (I n) n
    (B b) b
    (Add x y) (+ (eval x) (eval y))
    (Mul x y) (* (eval x) (eval y))
    (Eq x y) (== (eval x) (eval y))))

(:: gadt1 (IO ()))
(= gadt1
  (print (eval (Eq (Mul (Add (I 10) (I 11)) (I 2))
                   (I 42)))))

;;; GeneralizedNewtypeDeriving

(newtype (N a)
  (N a)
  (deriving (Eq Show Num)))

;;; OverloadedString

(:: f1 ByteString)
(= f1 "foo")

;;; OverloadedLists

(:: f2 (Set Char))
(= f2 [\a \e \i \o \u])

;;; Main

(:: main (IO ()))
(= main
  (do bangpatterns
      (print (typeOf (D1 True False)))
      (print (dataTypeOf (D1 \a \b)))
      (print (fmap succ (D2 (:: 41 Int))))
      (print (from (D3 False)))
      (let ((:: l1 (Lst Int))
            (= l1 (Cons 1 (Cons 2 (Cons 3 Nil))))))
      (print (foldr + 0 l1))
      (sequence_ (fmap print l1))
      gadt1
      (print (+ (N (:: 20 Int)) (N 22)))
      (print f1)
      (print f2)))
