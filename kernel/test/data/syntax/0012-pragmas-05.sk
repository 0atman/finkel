;;;; File containing language pragmas, part 5.

#p(LANGUAGE MultiParamTypeClasses)
#p(LANGUAGE NoMonomorphismRestriction)
#p(LANGUAGE ExplicitForAll)
#p(LANGUAGE FlexibleContexts)
#p(LANGUAGE FlexibleInstances)
#p(LANGUAGE KindSignatures)
#p(LANGUAGE TypeOperators)
#p(LANGUAGE TypeSynonymInstances)

(module Main)

(import GHC.Types)

;; Class `C1' requires `MultiParamTypeClasses'.
(class (C1 m a b)
  (:: c1 (-> (m a) (m b) (IO ()))))

(instance (C1 IO Bool Char)
  (= c1 a b
    (do (<- a' a)
        (<- b' b)
        (putStrLn (concat ["c1: " (show a') ", " (show b')])))))

;; Use of `Either String' requires `FlexibleInstances'.
(instance (C1 (Either String) Bool Char)
  (= c1 a b
    (where (f a b)
      (= f (Right b) (Right c) (pr (show b) (show c)))
      (= f (Right b) (Left s2) (pr (show b) s2))
      (= f (Left s1) (Right c) (pr s1 (show c)))
      (= f (Left s1) (Left s2) (pr s1 s2))
      (= pr x y
        (putStrLn (concat ["c1: " x ", " y]))))))

(class (C2 a b)
  (:: c2 (-> a b)))

(instance (C2 Bool String)
  (= c2 bool (++ "bool: " (show bool))))

;; Context `(C2 a String)' requires `FLexibleContexts'.
(:: c2str (=> (C2 a String) (-> a String)))
(= c2str c2)

;;; GHC Extension: overlap mode

(instance #p(OVERLAPS) (=> (Show a) (C2 a String))
  (= c2 show))

(class (C2b a b)
  (:: c2b (-> a b)))

(instance (C2b Bool String)
  (= c2b bool (++ "[c2b] bool:" (show bool))))

(instance #p(OVERLAPPABLE) (=> (Show a) (C2b a String))
  (= c2b (. (++ "[c2b] ") show)))

(class (C2c a b)
  (:: c2c (-> a b)))

(instance #p(OVERLAPPING) (C2c Bool String)
  (= c2c bool (++ "[c2c] bool:" (show bool))))

(instance (=> (Show a) (C2c a String))
  (= c2c (. (++ "[c2c] ") show)))

(class (C2d a b)
  (:: c2d (-> a b)))

(instance (C2d Bool String)
  (= c2d bool (++ "[c2d] bool:" (show bool))))

(instance #p(INCOHERENT) (=> (Show a) (C2d a String))
          (= c2d (. (++ "[c2d] ") show)))

(class (C3 a)
  (:: int (-> Int a))
  (:: add (-> a a a)))

(instance (C3 String)
  (= int show)
  (= add a b (concat ["(" a " + " b ")"])))

;; When monomorphism restriction is absent, fail to compile with
;; `c3_f1',
(= c3_f1 (add (int 1) (add (int 2) (int 3))))

;;; KindSignatures

(data (KS1 (:: m (-> Type Type)) a)
  (KS1 [a]))

(data (KS2 (:: m (-> * *)) a)
  (KS2 [a]))

(newtype (KS3 (:: m (-> Type Type)) a)
  (KS3 [a]))

(type (KS4 (:: f (-> Type Type)))
  (f Int))

(class (KS5 (:: f (-> Type Type)) a)
  (:: ks5 (-> (f Int) a)))

(:: f_ks1 (-> (:: Int Type) Int))
(= f_ks1 (+ 1))

(:: f_ks2 (forall (:: a *) (-> a a)))
(= f_ks2 x x)

(:: f_ks3 (forall a (-> a (:: a Type))))
(= f_ks3 x x)

(:: f_ks4 (forall (:: a *) (:: b *) (-> a b a)))
(= f_ks4 x _ x)

(:: ks1 (IO ()))
(= ks1
  (do (case (KS1 [1 2 3])
        (KS1 xs) (print xs))
      (case (KS2 [4 5 6])
        (KS2 xs) (print xs))
      (case (KS3 [7 8 9])
        (KS3 xs) (print xs))
      (print (:: (Just 42) (KS4 Maybe)))
      (print (f_ks1 41))
      (print (f_ks2 "f_ks2"))
      (print (f_ks3 "f_ks3"))
      (print (f_ks4 "f_ks4" undefined))))

;;; Type operator

(data (:* a b)
  (:* a b)
  (deriving (Eq Show)))

(:: to01 (IO ()))
(= to01 (print (:* True \x)))

(:: main (IO ()))
(= main
  (do (c1 (:: (return False) (IO Bool)) (return \x))
      (c1 (:: (return True) (Either String Bool)) (return \y))
      (let ((:: n Int)
            (= n 42)))
      (putStrLn (c2str True))
      (putStrLn (c2str n))
      (putStrLn (c2b True))
      (putStrLn (c2b n))
      (putStrLn (c2c True))
      (putStrLn (c2c n))
      (putStrLn (c2d True))
      (putStrLn (c2d n))
      (putStrLn (add (add (int 1) (int 2))
                     (add (int 3) (int 4))))
      (putStrLn c3_f1)
      to01))
