;;;; File containing language pragmas, part 5.

#p(LANGUAGE MultiParamTypeClasses)
#p(LANGUAGE NoMonomorphismRestriction)
#p(LANGUAGE ExplicitForAll)
#p(LANGUAGE FlexibleContexts)
#p(LANGUAGE FlexibleInstances)
#p(LANGUAGE KindSignatures)
#p(LANGUAGE MonoLocalBinds)
#p(LANGUAGE ScopedTypeVariables)
#p(LANGUAGE TypeOperators)
#p(LANGUAGE TypeSynonymInstances)
#p(LANGUAGE UndecidableInstances)

(module Main)

(import GHC.Types ((Type)))

;;; Multi param type classes

(class (C1 m a b)
  (:: c1 (-> (m a) (m b) (IO ()))))

(instance (C1 IO Bool Char)
  (= c1 a b
    (do (<- a' a)
        (<- b' b)
        (putStrLn (concat ["c1: " (show a') ", " (show b')])))))

;;; Flexible instances

;; Use of `Either String' requires `FlexibleInstances'.
(instance (C1 (Either String) Bool Char)
  (= c1 a b
    (where (f a b)
      (= f (Right b1) (Right b2) (pr (show b1) (show b2)))
      (= f (Right b1) (Left s2) (pr (show b1) s2))
      (= f (Left s1) (Right b2) (pr s1 (show b2)))
      (= f (Left s1) (Left s2) (pr s1 s2))
      (= pr x y
        (putStrLn (concat ["c1: " x ", " y]))))))

;;; Flexible contexts

(class (C2 a b)
  (:: c2 (-> a b)))

(instance (C2 Bool String)
  (= c2 bool (++ "bool: " (show bool))))

(:: c2str (=> (C2 a String) (-> a String)))
(= c2str c2)

;;; GHC Extension: overlap mode

(instance #p(OVERLAPS) (=> (Show a) (C2 a String))
  (= c2 show))

(class (C2b a b)
  (:: c2b (-> a b)))

(instance (C2b Bool String)
  (= c2b bool (++ "[c2b] bool:" (show bool))))

(instance #p(OVERLAPPABLE) (=> (Show a) (C2b a String))
  (= c2b (. (++ "[c2b] ") show)))

(class (C2c a b)
  (:: c2c (-> a b)))

(instance #p(OVERLAPPING) (C2c Bool String)
  (= c2c bool (++ "[c2c] bool:" (show bool))))

(instance (=> (Show a) (C2c a String))
  (= c2c (. (++ "[c2c] ") show)))

(class (C2d a b)
  (:: c2d (-> a b)))

(instance (C2d Bool String)
  (= c2d bool (++ "[c2d] bool:" (show bool))))

(instance #p(INCOHERENT) (=> (Show a) (C2d a String))
          (= c2d (. (++ "[c2d] ") show)))

;;; No monomorphism restriction

(class (C3 a)
  (:: int (-> Int a))
  (:: add (-> a a a)))

(instance (C3 String)
  (= int show)
  (= add a b (concat ["(" a " + " b ")"])))

(= c3_f1 (add (int 1) (add (int 2) (int 3))))

;;; KindSignatures

(data (KS1 (:: m (-> Type Type)) a)
  (KS1 [a]))

(data (KS2 (:: m (-> * *)) a)
  (KS2 [a]))

(newtype (KS3 (:: m (-> Type Type)) a)
  (KS3 [a]))

(type (KS4 (:: f (-> Type Type)))
  (f Int))

(class (KS5 (:: f (-> Type Type)) a)
  (:: ks5 (-> (f Int) a)))

(:: f_ks1 (-> (:: Int Type) Int))
(= f_ks1 (+ 1))

(:: f_ks2 (forall (:: a *) (-> a a)))
(= f_ks2 x x)

(:: f_ks3 (forall a (-> a (:: a Type))))
(= f_ks3 x x)

(:: f_ks4 (forall (:: a *) (:: b *) (-> a b a)))
(= f_ks4 x _ x)

(:: ks1 (IO ()))
(= ks1
  (do (case (KS1 [(:: 1 Int) 2 3])
        (KS1 xs) (print xs))
      (case (KS2 [(:: 4 Int) 5 6])
        (KS2 xs) (print xs))
      (case (KS3 [(:: 7 Int) 8 9])
        (KS3 xs) (print xs))
      (print (:: (Just 42) (KS4 Maybe)))
      (print (f_ks1 41))
      (print (f_ks2 "f_ks2"))
      (print (f_ks3 "f_ks3"))
      (print (f_ks4 "f_ks4" undefined))))

;;; Scoped type variables

(data Zero)
(data (Succ n))

(type One (Succ Zero))
(type Two (Succ One))
(type Four (Succ (Succ Two)))
(type Six (Succ (Succ Four)))
(type Eight (Succ (Succ Six)))

(class (Nat n)
  (:: toInt (-> n Int)))

(instance (Nat Zero)
  (= toInt _ 0))

(instance (=> (Nat n) (Nat (Succ n)))
  (= toInt _ (+ 1 (toInt (:: undefined n)))))

(:: f_stv01 (IO ()))
(= f_stv01
  (print (map (\ (:: x Int) (+ x 1)) [1 2 3])))

(:: f_stv02 (forall a (-> [a] [a])))
(= f_stv02 xs
  (where ys
    (:: ys [a])
    (= ys (reverse xs))))

(class (STVC a)
  (:: stv_op (-> [a] a))
  (= stv_op xs
    (let ((:: ys [a])
          (= ys (reverse xs)))
      (head ys))))

(instance (=> (STVC b) (STVC [b]))
  (= stv_op xs (reverse (head (:: xs [[b]])))))

(instance (STVC Bool))

(:: stv01 (IO ()))
(= stv01
  (do (print (toInt (:: undefined Four)))
      (print (toInt (:: undefined Eight)))
      f_stv01
      (print (f_stv02 "abc"))
      (print (stv_op [True False False]))))

;;; Type operator

(data (:* a b)
  (:* a b)
  (deriving (Eq Show)))

(data (:++ a b c)
  (:++ a b c)
  (deriving (Eq Show)))

(:: to01 (IO ()))
(= to01
  (do (print (:* True \x))
      ;; `:++' constructor takes three arguments, so surrounding with
      ;; parenthesis to avoid operator expansion. If no parenthesis,
      ;; below line would be expanded to: True :++ 'x' :++ "foo"
      (print ((:++) True \x "foo"))))


;;; Undecidable instances and mono local binds

(class (=> (Show a) (Monoid a) (ShowMonoid a)))

(instance (=> (Show a) (Monoid a) (ShowMonoid a)))

(:: showMonoid (=> (ShowMonoid a) (-> a String)))
(= showMonoid x
  (concat [(show x) "(mempty=" (show (asTypeOf mempty x)) ")"]))

(:: ui01 (IO ()))
(= ui01
  (do (putStrLn (showMonoid [(:: 1 Int) 2 3]))
      (putStrLn (showMonoid GT))))

;;; Main function

(:: main (IO ()))
(= main
  (do (c1 (:: (return False) (IO Bool)) (return \x))
      (c1 (:: (return True) (Either String Bool)) (return \y))
      (let ((:: n Int)
            (= n 42)))
      (putStrLn (c2str True))
      (putStrLn (c2str n))
      (putStrLn (c2b True))
      (putStrLn (c2b n))
      (putStrLn (c2c True))
      (putStrLn (c2c n))
      (putStrLn (c2d True))
      (putStrLn (c2d n))
      (putStrLn (add (add (int 1) (int 2))
                     (add (int 3) (int 4))))
      (putStrLn c3_f1)
      to01
      ui01))
