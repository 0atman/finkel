;;; Tests for REPL.

(require SK.Core)

(defmodule ReplTest
  (use
   ;; base
   (Control.Concurrent)
   (Control.Monad (void))
   (Data.List (intercalate))

   ;; directory
   (System.Directory (getCurrentDirectory))

   ;; hspec
   (Test.Hspec)

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Run)

   ;; sk-lang
   (SK.Repl (repl-env))
   (SK.Repl.Loop)
   (SK.Repl.Types))

  (export replTests))

(defn (replTests Spec)
  (do (describe "Read" readTests)
      (describe "Eval" evalTests)))

(defn (readTests Spec)
  (do (let ((= d describe)))
      (d "reading single line form"
         (it "returns '(foo bar buzz)"
             (do (<- form (run-repl (read-form "(foo bar buzz)")
                                    initial-repl-state))
                 (shouldBe (Just '(foo bar buzz)) form))))
      (d "reading multi line form"
         (it "returns '(a b c)"
             (do (<- form (run-repl (do (read-form "(a ")
                                        (read-form "b ")
                                        (read-form "c)"))
                                    initial-repl-state))
                 (shouldBe (Just '(a b c)) form))))))

(defn (evalTests Spec)
  (do (let ((= d describe)
            (= delines (intercalate "\n"))))
      (<- in-mv (runIO newEmptyMVar))
      (<- out-mv (runIO newEmptyMVar))
      (<- (, tmpfile hdl) (runIO make-tmpfile))
      (<- current-dir (runIO getCurrentDirectory))
      (<- etid
        (runIO (forkIO (void (runSkc (eval-loop hdl in-mv) repl-env)))))
      (let ((= eval-form ok-or-ng form expect
              (d (concat ["evaluate " (show form)])
                 (it (concat ["evaluates to " (show expect)])
                     (do (putMVar in-mv (Input Connection form out-mv))
                         (<- ret (takeMVar out-mv))
                         (shouldBe ret (ok-or-ng expect))))))
            (= ok (eval-form Right))
            (= ng (eval-form Left))
            (= satisfy form pred
              (d (concat ["evaluate " (show form)])
                 (it "satisfies predicate"
                     (do (putMVar in-mv (Input Connection form out-mv))
                         (<- ret (takeMVar out-mv))
                         (shouldSatisfy ret pred)))))))
      (beforeAll_
       (do (putMVar in-mv (Input Connection init-form out-mv))
           (void (takeMVar out-mv)))
       (afterAll_
        (do (killThread etid)
            (cleanup-tmpfile (, tmpfile hdl)))
        (do
          ;; Statements and declarations
          (ok '(+ 10 32) "42")
          (ok '(defn (f1 (-> Int Int))
                [n]
                (+ n 1))
              "; f1 :: Int -> Int")
          (ok '(f1 41) "42")
          (ok '(begin
                (:: (x y) Int)
                (= x 1)
                (= y 2))
              "; x :: Int\n; y :: Int")
          (ok '(<- z (return True))
              "; z :: Bool")
          (ok '(defn (f2 (-> (Maybe Int) Int))
                [(Just n)] (* n 2)
                [Nothing]  0)
              "; f2 :: Maybe Int -> Int")
          (ok '(f2 (Just 21)) "42")
          (ok '(data Foo (Foo Int))
              (concat ["; $tcFoo :: TyCon\n"
                       "; $tc'Foo :: TyCon\n"
                       "; Type constructor ‘Foo’"]))
          (ok '(import Control.Monad)
              "; import Control.Monad")

          ;; REPL macros
          (ok '(exported-macros Prelude) "[]")
          (ok '(*_ browse Unsafe.Coerce)
              "Unsafe.Coerce.unsafeCoerce :: a -> b")
          (ok '(*_ info putStr)
              "putStr :: String -> IO () \t-- Defined in ‘System.IO’")
          (ok '(*_ kind Maybe)
              "Maybe :: * -> *")
          (ok '(*_ pwd) current-dir)
          (satisfy
           '(*_ show bindings)
           (\ ret
             (case ret
               (Right str) (elem "f1 :: Int -> Int = _" (lines str))
               _ False)))
          (ok '(*_ show context)
              (delines
               ["; context"
                ";  IIDecl: import Control.Monad"
                ";  IIDecl: import SK.Repl.Macro"
                ";  IIDecl: import Language.SK"
                ";  IIDecl: import Prelude"]))
          (ok '(*_ show dflags)
              (delines
               ["; dflags:"
                ";  ghcLink: LinkInMemory"
                ";  ghcMode: CompManager"
                ";  hscTarget: HscInterpreted"
                ";  objectDir: Nothing"
                ";  thisInstalledUnitId: main"]))
          (ok '(begin
                (*_ set -odir /tmp)
                (*_ show dflags))
              (delines
               ["; dflags:"
                ";  ghcLink: LinkInMemory"
                ";  ghcMode: CompManager"
                ";  hscTarget: HscInterpreted"
                ";  objectDir: Just \"/tmp\""
                ";  thisInstalledUnitId: main"]))
          (satisfy
           '(*_ show macros)
           (\ ret
             (case ret
               (Right str) (elem ";  defmacro*!" (lines str))
               _ False)))
          (ok '(*_ show modules) "")
          (ok '(*_ show packages)
              "; packages")
          (ok '(begin
                (*_ set -package bytestring)
                (*_ show packages))
              (delines
               ["; packages"
                ";   -package bytestring"]))
          (ok '(*_ show paths)
              (concat
               ["; current working directory:\n"
                ";   " current-dir "\n"
                "; module import search paths:\n"
                ";    ."]))
          (ok '(*_ type putStrLn)
              "putStrLn :: String -> IO ()")

          ;; Errors
          (ng 'buzz
              (concat ["<interactive>:1:1: error: "
                       "Variable not in scope: buzz\n"]))
          (ng '(= f a (+ a 1) (+ a 2))
              (concat ["<quoted code>: syntax error on input "
                       "`(= f a (+ a 1) (+ a 2))'\n"]))
          (ng '(head []) "Prelude.head: empty list")
          (ng '(*_ info (foo bar))
              "<quoted code>: error: info: invalid form `(foo bar)'\n"))))))
