(:docn "Core language macros.

Macros defined in this module are available in @sk make@ compiler by
default, i.e., available without /require/-ing \"SK.Core\" module.")

(module SK.Core
  (:dh1 "Phase control")
  eval-when

  (:dh1 "Module header")
  defmodule

  (:dh1 "Top level macros")
  defmacro defmacro' defmacro-m defmacro-m'

  (:dh1 "Temporary macros")
  macrolet macrolet-m

  (:dh1 "Declaring functions")
  defn defn' defdo

  (:dh1 "Expanding macros")
  macroexpand macroexpand-1 exported-macros

  (:dh1 "Expressions")
  cond aps pfs)

;;; Requires

;; base
(require Prelude)
(require Control.Monad (foldM))

;; ghc
(require FastString (unpackFS))
(require SrcLoc ((SrcSpan ..)))

;; sk-kernel
(require Language.SK)

;; Internal
(require SK.Core.List)

;;; Imports

;; base
(import Control.Monad (foldM when))

;; ghc
(import DynFlags ((HasDynFlags ..)))
(import FastString (unpackFS))
(import GHC (getModuleInfo lookupModule lookupName modInfoExports))
(import Module (mkModuleName))
(import Outputable (ppr showSDoc))
(import SrcLoc ((SrcSpan ..)))
(import TyCoRep ((TyThing ..)))
(import Var (varName))

;; sk-kernel
(import Language.SK)
(import Language.SK.Form (symbolName))
(import Language.SK.SKC (isMacro))

;; Internal
(import SK.Core.List)


;;; [Internally used macros]
;;; ~~~~~~~~~~~~~~~~~~~~~~~~
;;;
;;; Defining a macro `eval-when-compile-and-load', to define functions
;;; and macros in current compilation context and compiled result. Then
;;; this module defines some auxiliary functions, and then a macro
;;; `define-macro'' to define a macro in compilation context and
;;; compiled result.

(with-macro ((= eval-when-compile-and-load
               (Macro
                (\ form
                  (case (unCode form)
                    (List (: _ rest)) (return `(begin
                                                 (eval-when-compile
                                                   ,@rest)
                                                 ,@rest))
                    _ (skSrcError
                       form
                       "eval-when-compile-and-load: panic"))))))
  (eval-when-compile-and-load
   (:docn "Code transformer function for macro declaration.")
   (:: macro-decl (-> Code Code Code (Skc Code)))
   (= macro-decl name arg body
     (do (<- tmp (gensym' (show name)))
         (return `(= ,name
                    (let ((:: ,tmp (-> Code (Skc Code)))
                          (= ,tmp ,arg ,body))
                      (Macro ,tmp))))))
   #p(INLINABLE macro-decl)

   (:docn "Body function of 'define-macro'.")
   (:: dmac (-> Code (Skc Code)))
   (= dmac form
     (let ((:: make-tsig (-> Code Code))
           (= make-tsig name
             `(:: ,name Macro)))
       (case (unCode form)
         (List [_ name arg body])
         (do (<- decl (macro-decl name arg body))
             (return `(begin
                        ,(make-tsig name)
                        ,decl)))

         (List [_ name doc arg body])
         (| ((<- (Atom (AString _)) (unCode doc))
             (do (<- decl (macro-decl name arg body))
                 (return `(begin
                            ,(make-tsig name)
                            (:docp ,doc)
                            ,decl)))))

         _ (skSrcError form "invalid args in macro definition"))))
   #p(INLINABLE dmac)

   (:docn "Function for body of 'let_macro'.")
   (:: lmac (-> Code (Skc Code)))
   (= lmac form
     (let ((= f x
             (case (unCode x)
               (List [name arg body]) (macro-decl name arg body)
               _ (skSrcError x "lmac: malformed macro"))))
       (case (unCode form)
         (List (: _self (: (LForm (L _l (List ms))) rest)))
         (do (<- ms' (mapM f ms))
             (return `(with-macro (,@ms') ,@rest)))
         _ (skSrcError form "lmac: malformed args"))))
   #p(INLINABLE lmac)))

(eval-when-compile
  (:docn "
==== Syntax

> DEFINE-MACRO ::= 'define-macro' NAME [DOC] ARGS BODY
> NAME         ::= varid
> DOC          ::= '\"' comment '\"'
> ARGS         ::= varid | '[' varid* ']' | '(' varid* ')'
> BODY         ::= form

==== Description

Simple macro for defining macro. This macro is used internally in
\"SK.Core\" module to define other macros.

==== Examples

Without documentation comment:

@
(define-macro m1a
  form
  (case (unCode form)
    (List [_ x]) (return `(print ,x))))
@

With documentation comment:

@
(define-macro m1b
  \"Documentation comment\"
  form
  (case (unCode form)
    (List [_ x]) (return `(print ,x))))
@
")
  (:: define-macro Macro)
  (= define-macro (Macro dmac)))

(eval-when-compile
  (define-macro define-macro'
    "Auxiliary macro to define a macro for both compile time and load
time. Used only in this module until 'defmacro-m'' is defined."
    form
    (do (<- body (dmac form))
        (return `(begin
                   (eval-when-compile
                     ,body)
                   ,body)))))


;;; Exported codes

(define-macro' eval-when
  "
==== Syntax

> EVAL-WHEN ::= 'eval-when' PHASES BODY*
> PHASES    ::= '[' PHASE+ ']' | '(' PHASE+ ')'
> PHASE     ::= 'compile' | 'load'
> BODY      ::= form

==== Description

Macro to specify the /PHASE/s of evaluation of /BODY/ codes. Valid
phases are __@compile@__ and __@load@__. The @compile@ phase evaluates
the body forms at the time of compilation, so that the compilation
context can refer to the function and macros definied in the /BODY/
forms. The @load@ phase simply emit the body forms to compiled result.

==== Example

In following module, the function @f@ is defined inside 'eval_when', so
that the function could be accessed from the function @g@ at run-time,
and temporally macro @m@ at compilation time.

@
(defmodule Main
  (load-use (Prelude)
            (Language.SK)))

(eval-when (compile load)
  (defn (f (-> Code Code))
    [x]
    `(print ,x)))

(defn (g (-> Code (IO ())))
  [x]
  (print (f x)))

(macrolet ((m [x]
             (f x)))
  (defn (main (IO ()))
    (do (g 'foo)
        (m 'bar))))
@
"
  form
  (let ((:: at-compile (-> [Code] Bool))
        (= at-compile (elem 'compile))
        (:: at-load (-> [Code] Bool))
        (= at-load (elem 'load))
        (:: gen-eval-when (-> [Code] [Code] (Skc Code)))
        (= gen-eval-when phases body
          (| ((&& (at-compile phases) (at-load phases))
              (return
                `(begin
                   (eval-when-compile
                     ,@(List body))
                   ,@(List body))))
             ((at-compile phases)
              (return `(eval-when-compile ,@(List body))))
             ((at-load phases)
              (return `(begin ,@(List body))))
             (otherwise
              (skSrcError form (++ "eval-when: invalid phase: "
                                   (show phases)))))))
    (case (unCode form)
      (List (: _ (: (LForm (L _ lst)) body)))
      (| ((<- (List phases) lst) (gen-eval-when phases body))
         ((<- (HsList phases) lst) (gen-eval-when phases body)))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

(eval-when [compile load]
  (:: macro-error (-> Code String (Skc a)))
  (= macro-error form msg
    (skSrcError form (concat [msg ": " (show form)])))
  #p(INLINABLE macro-error)

  (:: replace-hyphens (-> String String))
  (= replace-hyphens
    (map (\ x (if (== x \-) \_ x))))
  #p(INLINABLE replace-hyphens)

  (:: subst-gensyms (-> [(, Atom Atom)] Code Code))
  (= subst-gensyms kvs
    (fmap (\ x (case (lookup x kvs)
                 (Just y) y
                 Nothing  x))))
  #p(INLINABLE subst-gensyms)

  (:: acc-gensym-names (-> [(, Atom Atom)] Atom (Skc [(, Atom Atom)])))
  (= acc-gensym-names acc form
    (case form
      (ASymbol sym) (| ((<- (: \$ (@ cs (: c _))) (unpackFS sym))
                        (elem c [\a .. \z])
                        (<- Nothing (lookup form acc))
                        (do (let ((= cs' (replace-hyphens cs))))
                            (<- x (fmap unCode (gensym' cs')))
                            (return (case x
                                      (Atom gsym) (: (, form gsym) acc)
                                      _           acc)))))
      _             (return acc)))
  #p(INLINABLE acc-gensym-names)

  (:: gensymfy (-> Code (Skc Code)))
  (= gensymfy form
    (do (<- kvs (foldM acc-gensym-names [] form))
        (return (subst-gensyms kvs form))))
  #p(INLINABLE gensymfy)

  ;; Function to make body of `defmacro-m' and `defmacro'.
  ;;
  ;; XXX: Currently does not suuport lambda-list like pattern match in
  ;; macro argument.
  (:: make-defmacro-body (-> String Code Code Code Code (Skc Code)))
  (= make-defmacro-body label whole name0 arg0 body0
    (let ((:: err (-> Code Code Code))
          (= err form-name name
            `(skSrcError ,form-name
                         (concat
                          [(show ',name)
                           "\ninvalid args: `" (show __form__) "'"])))

          (:: atom-body (-> Code Code Code Code Code))
          (= atom-body name arg body form-name
            `(case (unCode ,form-name)
               (List (: _ ,arg)) ,body
               _                 ,(err form-name name)))

          (:: list-body (-> SrcSpan Code [Code] Code Code Code))
          (= list-body l1 name args body form-name
            (let ((:: abind Code)
                  (= abind
                    `(LForm
                      (L _loc
                         (List [_ ,@(LForm (L l1 (List args)))])))))
              `(case ,form-name
                 ,abind  ,body
                 _       ,(err form-name name)))))
      (case (unLForm arg0)
        (L l1 (List args))
        (gensymfy (list-body l1 name0 args body0 '__form__))

        (L l1 (HsList args))
        (gensymfy (list-body l1 name0 args body0 '__form__))

        (L _ (Atom (ASymbol _)))
        (gensymfy (atom-body name0 arg0 body0 '__form__))

        (L _ (Atom AUnit))
        (gensymfy body0)

        _ (skSrcError whole (++ label ": invalid args")))))
  #p(INLINABLE make-defmacro-body)

  ;; Function to make body expression of `macrolet-m' and `macrolet'.
  (:: make-macrolet-body (-> String Code (-> Code Code) (Skc Code)))
  (= make-macrolet-body label whole f
    (let ((:: make-macro (-> Code (Skc Code)))
          (= make-macro code
            (case code
              (LForm (L l (List [name arg body0])))
              (do (let ((= the-form (if (|| (is-unit arg)
                                            (null arg))
                                        '_
                                        '__form__))
                        (= body1 (f body0))))
                  (<- body2
                    (make-defmacro-body label code name arg body1))
                  (return (LForm (L l (List [name the-form body2])))))

              _ (macro-error code (++ label ": invalid form")))))
      (case (unCode whole)
        (List (: _ (: (LForm (L l0 (List forms))) rest)))
        (do (<- macros (mapM make-macro forms))
            (lmac `(let-macro ,(LForm (L l0 (List macros)))
                     ,@(List rest))))

        _ (macro-error whole (++ label ": invalid form")))))
  #p(INLINABLE make-macrolet-body))

(define-macro' defmacro-m
  "
==== Syntax

Same as 'defmacro'.

==== Description

A macro similar to 'defmacro', but the body expression need to be a
value of type 'Skc' 'Code'. This macro has full access to the 'Skc'
environment in compilation context.

==== Examples

A macro to read a file contents at the time of compilation:

@
(defmacro-m m1 [path]
  (| ((<- (Just path') (fromCode path))
      (do (<- contents (liftIO (readFile path')))
          (return `(putStrLn ,contents))))
     (otherwise
      (skSrcError path \"m1: not a file path.\"))))
@

Sample expansion:

>>> (macroexpand '(m1 \"/path/to/a/file.txt\")
(putStrLn \"... contents of the file ...\")
"
  form
  (let ((:: make-def (-> Code (Maybe Code) Code Code (Skc Code)))
        (= make-def name mb-doc arg body0
          (do (<- body1
                (make-defmacro-body "defmacro-m" form name arg body0))
              (let ((= the-form (if (|| (is-unit arg) (null arg))
                                    '_
                                    '__form__))))
              (case mb-doc
                (Just doc) (dmac `(_ ,name ,doc ,the-form ,body1))
                Nothing (dmac `(_ ,name ,the-form ,body1))))))
    (case (unCode form)
      (List [_ name doc arg body])
      (| ((<- (Atom (AString _)) (unCode doc))
          (make-def name (Just doc) arg body)))

      (List [_ name arg body])
      (make-def name Nothing arg body)

      _ (macro-error form "defmacro-m: invalid form"))))

(define-macro' defmacro-m'
  "
==== Syntax

Same as 'defmacro'.

==== Description

Variant of 'defmacro_m'. Wrapped in 'eval_when' with @compile@ and
@load@ phases.

==== Examples

See 'defmacro' and 'defmacro_m'."
  form
  (case (unCode form)
    (List (: _ rest)) (return `(eval-when (compile load)
                                 (defmacro-m ,@rest)))
    _ (macro-error form "defmacro-m': impossible happened.")))

(define-macro' defmacro
  "
==== Syntax

> DEFMACRO ::= 'defmacro' NAME [DOC] ARGS BODY
> NAME     ::= varid
> DOC      ::= '\"' comment '\"'
> ARGS     ::= '(' varid* ')' | '[' varid* ']' | varid
> BODY     ::= form

==== Description

Macro to define a macro named /NAME/, similar to the macro with same
name found in other Lisps, such as Common Lisp, Clojure, LFE, Hy
... etc. The 'defmacro' can take an optional /DOC/ comment string in
second parameter. Next parameter is either a list of /ARGS/, or a single
varid to refer the entire parameter as list of 'Code's. The last
parameter is the /BODY/ expression, which need to be a value of 'Code'
type.

Note that 'defmacro' does not add the defined macro to REPL session. To
add macros in REPL session, use 'defmacro'' or write the macro
definition inside 'eval_when'.

==== Examples

Macro taking single parameter named /x/, returns a form with 'print'
applied to the given parameter:

> (defmacro m1a [x]
>   `(print ,x))

Sample expansion:

>>> (macroexpand '(m1a False))
(print False)

Parameters could be enclosed in parentheses or brackets:

> (defmacro m1b (x)
>   `(print ,x))

Macro with documentation comment:

> (defmacro m2
>   \"Documentation comment.\"
>   [a b]
>   `(do (print ,a)
>        (print ,b)))

Sample expansion:

>>> (macroexpand '(m2 False \\x))
(do (print False) (print \\x))

Macro taking parameter as a list of 'Code':

@
(defmacro m3 args
  (case args
    [a]   `(print ,a)
    [a b] `(>> (print ,a) (print ,b))
    _     `(do ,@(map (\\\\ x `(print ,x)) args))))
@

Expansions of /m3/:

>>> (macroexpand '(m3 False))
(print False)
>>> (macroexpand '(m3 False \\x))
(>> (print False) (print \\x))
>>> (macroexpand '(m3 False \\x \"bar\"))
(do (print False) (print \\x) (print \"bar\"))
"
  form
  (case (unCode form)
    ;; As in `dmac', binding `body' to temporay name to support `where'
    ;; in body expression.
    (List [_ name doc args body])
    (| ((<- (Atom (AString _)) (unCode doc))
        (do (<- tmp (gensym' (show name)))
            (return `(defmacro-m ,name ,doc ,args
                       (let ((= ,tmp ,body))
                         (return ,tmp)))))))

    (List [_ name args body])
    (do (<- tmp (gensym' (show name)))
        (return `(defmacro-m ,name ,args
                   (let ((= ,tmp ,body))
                     (return ,tmp)))))

    _ (macro-error form "defmacro: invalid form.")))

(defmacro-m' defmacro'
  "
==== Syntax

Same as 'defmacro'.

==== Description

Variant of 'defmacro', wrapped in 'eval_when' with @compile@ and
@load@ phases.

==== Examples

See 'defmacro'.
"
  form
  (return `(eval-when (compile load)
             (defmacro ,@form))))

(define-macro macrolet-m
  "
==== Syntax

See 'macrolet'.

==== Description

Variant of 'macrolet', the body of each macro need to be a 'Code' value
wrapped in 'Skc'. This macro has full access to 'Skc' in compilation
context.

==== Example

Rewrite of the example shown in 'macrolet':

@
(macrolet-m ((m1 [x]
               (return `(+ ,x 1)))
             (m2 [a b]
               (return `[(m1 ,a) (m1 ,b)])))
  (m2 19 20))
;;; ==> [20,21]
@

"
  form
  (make-macrolet-body "macrolet-m" form id))

(define-macro macrolet
  "
==== Syntax

> MACROLET ::= 'macrolet' '(' MACRO* ')' BODY
> MACRO    ::= NAME ARGS EXPR
> NAME     ::= varid
> ARGS     ::= '(' varid* ')' | '[' varid* ']' | varid
> EXPR     ::= form
> BODY     ::= form

==== Description

Define temporary macros named /NAME/. The defined macros could be
referred from /BODY/. Each macro takes /ARGS/ parameter, and results in
/EXPR/. The parameter /ARGS/ works as in 'defmacro'.

==== Examples

Temporary macros can refer other temporary macros:

@
(macrolet ((m1 [x]
             `(+ ,x 1))
           (m2 [a b]
             `[(m1 ,a) (m1 ,b)]))
  (m2 19 20))
;;; ==> [20,21]
@
"
  form
  (make-macrolet-body "macrolet" form (\ body `(return ,body))))

;;; Pattern matching macro for `LForm' of `Atom' with `AString'.
(eval-when-compile
  (defmacro pastring
    [val]
    `(LForm (L _ (Atom (AString ,val))))))

(define-macro defn
  "
==== Syntax

> DEFN    ::= 'defn' SIG [DOC] [ARGS] BODY ARGBODY*
> SIG     ::= varid | '(' varid typesig ')'
> DOC     ::= '\"' comment '\"'
> ARGS    ::= '(' varid* ')' | '[' varid* ']'
> BODY    ::= form
> ARGBODY ::= ARGS BODY

==== Description

Macro for defining function. Supports optional function type signature
/SIG/, which could be a name symbol or a list of name symbol and type
signature form. Parameter /ARGS/ could be enclosed in parantheses or
brackets. When multiple pairs of /ARGS/ and /BODY/ were given, does
expand to function definition with argument pattern matchings.

===== Examples

Function without arguments:

> (defn v1 42)

Function without arguments, with type signature:

> (defn (v2 Int) 43)

Function with arguments, type signature, and documentation comment:

@
(defn (fib1 (-> Int Int))
  \"Documentation comment\"
  [n]
  (case n
    0 0
    1 1
    _ (+ (fib1 (- n 1)) (fib1 (- n 2)))))
@

Function with pattern matched arguments, type signature, and
documentation comment:

@
(defn (fib2 (-> Int Int))
  \"Documentation comment\"
  [0] 0
  [1] 1
  [n] (+ (fib2 (- n 1)) (fib2 (- n 2))))
@

The last /fib2/ example is same as below:

@
(:: fib2 (-> Int Int))
(:docp \"Documentation comment\")
(= fib2 0 0)
(= fib2 1 1)
(= fib2 n (+ (fib2 (- n 1)) (fib2 (- n 2))))
@
"
  form
  (let ((:: build-decls (-> Code [Code] [Code]))
        (= build-decls name
          (let ((= go (: args (: body rest))
                  (: `(= ,name ,@args ,body) (go rest)))
                (= go _ []))
            go))
        (:: build-doc (-> (Maybe Code) Code))
        (= build-doc mb-doc
          (case mb-doc
            (Just doc) `((:docp ,doc))
            Nothing     nil))
        (:: build (-> Code (Maybe Code) [Code] (Skc Code)))
        (= build sig mb-doc bodies
          (do (when (odd (length bodies))
                (macro-error form "defn: odd number of forms"))
              (case (unCode sig)
                (List [name ty]) (return
                                   `(begin
                                      (:: ,name ,ty)
                                      ,@(build-doc mb-doc)
                                      ,@(build-decls name bodies)))
                (Atom _) (case (build-decls sig bodies)
                           [x] (case mb-doc
                                 (Just doc) (return `(begin
                                                       ,x
                                                       (:docp ,doc)))
                                 Nothing (return x))
                           xs (return `(begin
                                         ,@xs
                                         ,@(build-doc mb-doc))))
                _ (macro-error sig "defn: invalid signature")))))
    (case (unCode form)
      ;; Declaration of string, without documentation. Need to pattern
      ;; match this first to support defining plain string value without
      ;; documentation.
      (List [_ sig (@ body (pastring _))])
      (build sig Nothing [nil body])

      (List [_ sig (@ doc (pastring _)) body])
      (build sig (Just doc) [nil body])

      (List [_ sig body])
      (build sig Nothing [nil body])

      (List (: _ (: sig (: (@ doc (pastring _)) rest))))
      (build sig (Just doc) rest)

      (List (: _ (: sig bodies)))
      (build sig Nothing bodies)

      _ (macro-error form "defn: invalid form"))))

(defmacro defn'
  "
==== Syntax

Same as 'defn'.

==== Description

Macro to define a function for both of compilation time and load
time. This macro uses 'eval_when' and 'defn'.

==== Examples

See 'defn'."
  form
  `(eval-when [compile load]
     (defn ,@form)))

(define-macro defdo
  "
==== Syntax

> DEFDO ::= SIG [DOC] ARGS BODY*
> SIG   ::= varid | '(' varid typesig ')'
> DOC   ::= '\"' comment '\"'
> ARGS  ::= '(' varid* ')' | '[' varid* ']'
> BODY  ::= form

==== Description

Macro to define a function with 'defn', with wrapping the body
expressions with /do/.

==== Examples

Function taking single argument:

@
(defdo (foo (=> (Show a) (-> a (IO ()))))
  [x]
  (print x)
  (print x)
  (print x))
@

Sample run:

>>> (foo True)
True
True
True
"

  form
  (case (unCode form)
    (List (: _ (: sig (: (@ doc (pastring _)) (: args body)))))
    (return `(defn ,sig ,doc ,args
               (do ,@body)))

    (List (: _ (: sig (: args body))))
    (return `(defn ,sig ,args
               (do ,@body)))

    _ (macro-error form "defdo: invalid form")))

(defmacro' cond
  "
==== Syntax

COND    ::= 'cond' CLAUSE+
CLAUSE+ ::= '(' guard+ expr ')'

==== Description

The 'cond' macro, found in many Lisp languages.  The behaviour is
same as wrapping the body with @case@ expression with dummy unit, or
@if@ with @MultiWayIf@ GHC language extension.

==== Examples

Simple function with weird tests:

@
(defn (c01 (-> Int Int Int))
  [a b]
  (cond
    ((even b) (< a b) b)
    ((odd b) (> a b) b)
    (otherwise a)))
@

Sample run:

>>> (map (c01 5) [1 .. 10])
[1,5,3,5,5,6,5,8,5,10]
"
  body
  `(case ()
     _ (| ,@body)))


;;; Macros for macros

(defmacro-m macroexpand-1
  "
==== Syntax

> MACROEXPAND-1 ::= 'macroexpand-1' form

==== Description

Expand given form if the given form is a macro, otherwise return the
given form. Note that 'macroexpand-1' and 'macroexpand' are macros, not
functions.

==== Examples

>>> (macroexpand-1 '(defmacro f1 [x] `(+ ,x 1)))
(defmacro_m f1 [x]
  (let ((= f1_cs2 (quasiquote (+ (unquote x) 1))))
    (return f1_cs2)))
"
  [form]
  (case (unCode form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand1 x))
                         (return `',expanded))))
    _            (return form)))

(defmacro-m macroexpand
  "
==== Syntax

> MACROEXPAND ::= 'macroexpand' form

==== Description

Macro for expanding macro. This macro recursively expands all sub
forms.

==== Examples

>>> (macroexpand '(defmacro f1 [x] `(+ ,x 1)))
(begin
  (:: f1 Macro)
  (= f1 (let ((:: f1_cnp (-> Code (Skc Code)))
              (= f1_cnp __form__
                (case __form__
                  (LForm (L _loc (List [_ x])))
                  (let ((= f1_cno (quasiquote (+ (unquote x) 1))))
                    (return f1_cno))
                  _ (skSrcError
                     __form__
                     (concat [(show (quote f1))
                              \"\\ninvalid args: `\"
                              (show __form__)
                              \"'\"])))))
          (Macro f1_cnp))))
"
  [form]
  (case (unCode form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (let ((= go expr
                             (do (<- expr' (expand1 expr))
                                 (if (== expr expr')
                                     (return `',expr)
                                     (go expr')))))
                       (go x))))
    _            (return form)))

(defmacro-m exported-macros
  "
==== Syntax

> EXPORTED-MACROS ::= 'exported-macros' modid

==== Description

Macro to return macro names exported from given module as a list of
'String'.

==== Examples

>>> (exported-macros SK.Core)
[\"aps\",\"cond\",\"defdo\",\"defmacro\", ...]
"
  [name]
  (let ((= f dflags mb-thing acc
          (case mb-thing
            (Just (@ thing (AnId var)))
            (| ((isMacro thing)
                (: (showSDoc dflags (ppr (varName var))) acc)))
            _ acc))
        (= get-exported-names name-str
          (do (<- mdl (lookupModule (mkModuleName name-str) Nothing))
              (<- mb-mod-info (getModuleInfo mdl))
              (case mb-mod-info
                Nothing (return [])
                (Just minfo)
                (do (<- mb-things
                      (mapM lookupName (modInfoExports minfo)))
                    (<- dflags getDynFlags)
                    (return (foldr (f dflags) [] mb-things)))))))
    (case (unCode name)
      (Atom (ASymbol _))
      (do (<- names0 (get-exported-names (symbolName name)))
          (let ((= names1 (toCode (map toCode names0)))))
          (return `(:: ,names1 [String])))

      _ (macro-error name "exported-macros: invalid form"))))


;;; Module header

(define-macro defmodule
  "
==== Syntax

> DEFMODULE ::= 'defmodule' NAME IMPEXP*
> NAME      ::= modid
> IMPEXP    ::= '(' 'use' form+ ')'
>             | '(' 'load' form+ ')'
>             | '(' 'load-use' form+ ')'
>             | '(' 'export' form* ')'

==== Description

Macro to define header of module named /NAME/. The /IMPEXP/ are forms
for imports and exports. Imports and exports forms can appear in any
order, and starts with following symbols:

[@use@]: The form elements expand to @import@ declaration.

[@load@]: The form elements expand to @require@ declaration.

[@load-use@]: The form elements are expanded to both @import@ and
@require@.

[@export@]: The form elements expand to export entities.

==== Examples:

Sample module header:

@
(defmodule Foo
  (load (Prelude hiding (head tail))
        (SK.Prelude))
  (load-use (Control.Monad (foldM)))
  (use (Control.Monad (when))
       (qualified Data.ByteString as BS))
  (export foo bar buzz))
@

Expands to below:

@
(begin
  (require Prelude hiding (head tail))
  (require SK.Prelude)
  (require Control.Monad (foldM))
  (module Foo foo bar buzz)
  (import Control.Monad (when))
  (import qualified Data.ByteString as BS)
  (import Control.Monad (foldM)))
@

"
  form
  (case (unCode form)
    (List (: _ rest0))
    (case rest0
      [name]
      (return `(module ,name))

      (: name rest1)
      (do (let ((= merge-sections acc lst
                  (let ((= label (car lst)))
                    (cond
                      ((== label 'export)
                       (return
                         (if (null (cdr lst))
                             (: (, 'export (cons '() nil)) acc)
                             (: (, 'export (cdr lst)) acc))))
                      ((== label 'use)
                       (return
                         (: (, 'import (mapcar (\ es `(import ,@es))
                                               (cdr lst)))
                            acc)))
                      ((== label 'load)
                       (return
                         (: (, 'require (mapcar (\ es `(require ,@es))
                                                (cdr lst)))
                            acc)))
                      ((== label 'load-use)
                       (return (: (, 'load-use (cdr lst)) acc)))

                      (otherwise
                       (macro-error lst
                                    "defmodule: unknown section")))))))
          (<- alist (foldM merge-sections [] rest1))
          (let ((= emit add-load-use header
                  (let ((= e1 (maybe nil id (lookup header alist)))
                        (= e2 (maybe nil
                                     (mapcar (\ es `(,header ,@es)))
                                     (lookup 'load-use alist))))
                    (if add-load-use
                        (append e1 e2)
                        e1)))))
          (return
            `(begin
               ,@(emit True 'require)
               (module ,name ,@(emit False 'export))
               ,@(emit True 'import))))

      _ (macro-error form "defmodule: invalid form"))

    _ (macro-error form "defmodule: invalid form")))


;;; Convenience macros

(define-macro aps
  "
==== Syntax

> APS ::= 'aps' expr+

==== Description

Macro to apply given function in Applicative and Functor context.
Can handle variable number of arguments.

==== Examples

>>> (macroexpand '(aps f (pure a) (pure b) (pure c)))
(<*> (<*> (<$> f (pure a)) (pure b)) (pure c))
"
  form
  (let ((= build op args
          (case args
            (: arg []) (return `(<$> ,op ,arg))
            (: arg as) (do (<- ret (build op as))
                           (return `(<*> ,ret ,arg)))
            [] (return `(<$> ,op)))))
    (case (unCode form)
      (List (: _ (: op args))) (build op (reverse args))
      _ (macro-error form "aps: invalid form"))))

(define-macro pfs
  "
==== Syntax

> PFS ::= 'pfs' expr+

==== Description

Macro for point free style function composition.

==== Examples

>>> (macroexpand '(pfs f1 (f2 arg1) f3))
(. f1 (. (f2 arg1) f3))
"
  form
  (let ((= go exprs
          (case exprs
            [e1 e2] (return `(. ,e1 ,e2))
            (: e1 rest) (do (<- e2 (go rest))
                            (return `(. ,e1 ,e2)))
            _ (macro-error nil "pfs: no args"))))
    (case (unCode form)
      (List (: _ rest)) (go rest)
      _ (macro-error form "pfs: invalid form")) ))
