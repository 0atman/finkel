;;; Loops in REPL.

(require SK.Core)

(defmodule SK.Repl.Loop
  (use
   ;; base
   (Control.Concurrent ((ThreadId) forkIO killThread))
   (Control.Concurrent.MVar ((MVar) newEmptyMVar putMVar takeMVar))
   (Control.Exception ((AsyncException ..) bracket catch
                       fromException throwIO))
   (Control.Monad (void when))
   (Control.Monad.IO.Class (liftIO))
   (Data.List (inits intercalate isPrefixOf isSuffixOf nubBy))
   (System.Exit (exitWith))
   (System.IO ((Handle) hClose hFlush openTempFile stdout))
   (System.IO.Error (isDoesNotExistError))

   ;; bytestring
   (Data.ByteString.Builder (stringUtf8 toLazyByteString))
   (qualified Data.ByteString.Lazy.Char8 as BS)

   ;; directory
   (System.Directory (getTemporaryDirectory removeFile))

   ;; ghc
   (DynFlags ((DynFlags ..) (GhcLink ..) (HscTarget ..)))
   (ErrUtils (pprErrMsgBagWithLoc))
   (Exception (ghandle))
   (GHC (getPrintUnqual setSessionDynFlags))
   (GhcMonad ((GhcMonad ..) getSessionDynFlags withSession))
   (HscMain (hscParsedStmt))
   (HscTypes ((HscEnv ..) (InteractiveContext ..) (InteractiveImport ..)
              (FixityEnv) extendInteractiveContextWithIds
              setInteractivePrintName srcErrorMessages))
   (HsImpExp ((ImportDecl ..)))
   (InteractiveEval (getContext parseName setContext))
   (Linker (extendLinkEnv))
   (Name ((Name) getName nameOccName occNameString))
   (OrdList (toOL))
   (Outputable (ppr mkErrStyle renderWithStyle setStyleColoured
                    showPpr showSDoc vcat))
   (RdrHsSyn (cvTopDecls))
   (SrcLoc (unLoc))
   (TyCoRep ((TyThing ..)))
   (Var ((Id) (Var) varType))

   ;; ghci
   (GHCi (evalStmt))
   (GHCi.Message ((EvalExpr ..) (EvalResult ..) (EvalStatus_ ..)
                  (SerializableException ..)))
   (GHCi.RemoteTypes ((ForeignHValue)))

   ;; haskeline
   (System.Console.Haskeline
    ((InputT) defaultSettings getInputLine handleInterrupt outputStr
     outputStrLn runInputT throwTo withInterrupt))

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Builder ((HDecl) (HImportDecl)  (HStmt)
                         syntaxErrCode syntaxErrMsg evalBuilder))
   (Language.SK.Eval (evalDecls))
   (Language.SK.Expand (expands))
   (Language.SK.Lexer (evalSP))
   (Language.SK.Make (initSessionForMake))
   (Language.SK.Reader (sexpr))
   (Language.SK.Run (runSkc))
   (Language.SK.SKC ((SkEnv ..) failS))
   (Language.SK.Syntax (parseImports parseStmt parseTopDecls))

   ;; internal
   (SK.Repl.IO)
   (SK.Repl.Listen)
   (SK.Repl.Types))

  (export read-form eval-loop read-print-loop init-form start-repl
          make-tmpfile cleanup-tmpfile))


;;; Starting the REPL

;;; Start REPL, maybe listen to given port number when given.
(defn (start-repl (-> (Maybe Int) SkEnv (IO ())))
  [mb-port ske]
  (bracket
   make-tmpfile
   cleanup-tmpfile
   (\ (, _tmpfile hdl)
     (do (<- in-mv newEmptyMVar)
         (start-listener mb-port in-mv)
         (<- eval-tid
           (forkIO (void (runSkc (eval-loop hdl in-mv) ske))))
         (let ((= rpl (read-print-loop in-mv eval-tid))
               (= reader (runInputT defaultSettings rpl))))
         (run-repl reader initial-repl-state)))))

;;; Return a file path and handle for temporary use.
(defn (make-tmpfile (IO (, FilePath Handle)))
  (do (<- dir getTemporaryDirectory)
      (openTempFile dir "sk-repl-.out")))

;;; Start listner in separate thread, and return temporary file for
;;; getting String output from statement.
(defn (start-listener (-> (Maybe Int) (MVar Input) (IO ())))
  [mb-port in-mv]
  (maybe (return ())
         (\ port
           (do (putStrLn (++ "Listening on port " (show port)))
               (void (forkIO (listener (fromIntegral port) in-mv)))))
         mb-port))

;; Clean up temporary file.
(defn (cleanup-tmpfile (-> (, FilePath Handle) (IO ())))
  [(, path hdl)]
  (catch (do (hClose hdl)
             (removeFile path))
    (\ e (if (isDoesNotExistError e)
             (return ())
             (throwIO e)))))


;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(defn (read-print-loop (-> (MVar Input) ThreadId (InputT Repl ())))
  [to-mvar eval-tid]
  (let ((= print-io result-mv
          (do (<- result (liftIO (takeMVar result-mv)))
              (case result
                (Right str) (when (not (null str))
                              (outputStrLn str))
                (Left str)  (when (not (null str))
                              (let ((= pr (| ((isSuffixOf "\n" str)
                                              outputStr)
                                             (otherwise
                                              outputStrLn))))
                                (pr str))))
              (liftIO (hFlush stdout))))
        (= go result-mv
          (do (<- st0 (lift get-repl-state))
              (let ((= prompt
                      (if (null (pending-input st0)) "> " ""))))
              (<- mb-input
                ;; Handle interrupt signals thrown while waiting for
                ;; input, to handle `Ctrl-C' key presses without valid
                ;; evaluation form, and refresh intermediate user inputs
                ;; in Repl state.
                (handleInterrupt
                 (lift (do (<- st1 get-repl-state)
                           (put-repl-state (st1 {pending-input []}))
                           (return (Just []))))
                 (getInputLine prompt)))
              (maybe quit (go1 st0 result-mv) mb-input)))
        (= go1 st0 result-mv line
          (case line
            []       (go result-mv)
            (: h tl) (| ((== line "(quit)") quit)
                        ((&& (null (pending-input st0))
                             (== \, h))
                         (if (elem tl (tail (inits "quit")))
                             quit
                             (go-command result-mv tl)))
                        (otherwise
                         (go2 result-mv line)))))
        (= go-command result-mv lin
          (| ((isPrefixOf "set" lin)
              (go3 result-mv (as-repl-macro lin)))
             (otherwise
              (go2 result-mv (concat ["(repl-macro " lin ")"])))))
        (= go2 result-mv line
          (do (<- mb-form (lift (read-form line)))
              (case mb-form
                (Just form) (go3 result-mv form)
                Nothing     (go result-mv))))
        (= go3 result-mv form
          (do (let ((= input (Input Prompt form result-mv))))
              (liftIO (putMVar to-mvar input))
              (print-io result-mv)
              (go result-mv)))
        (= as-repl-macro str
          `(repl-macro ,@(map qSymbol (words str))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop result-mv
          (handleInterrupt
           (do (throwTo eval-tid UserInterrupt)
               (print-io result-mv)
               (loop result-mv))
           (go result-mv))))

    ;; Print the result from boot expression, then start the loop.
    (withInterrupt
     (do (<- result-mv (liftIO newEmptyMVar))
         (liftIO
          (putMVar to-mvar (Input Prompt init-form result-mv)))
         (print-io result-mv)
         (loop result-mv)))))

;;; Form to initialize the REPL.
(defn (init-form Code)
  '(putStrLn "Hit `Ctrl-d' or type ,q to quit, type ,? for help."))

;;; Read single S-expression form.
(defn (read-form (-> String (Repl (Maybe Code))))
  [input0]
  (do (<- st get-repl-state)
      (let ((= input1
              (++ (pending-input st)
                  [(toLazyByteString (stringUtf8 (: \\n input0)))]))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret)))))
      (case (evalSP sexpr (Just "<repl>") (BS.concat input1))
        (Right forms) (put-and-return [] (Just forms))
        (Left _err)   (put-and-return input1 Nothing))))


;;; Eval loop

(defn (eval-loop (-> Handle (MVar Input) (Skc ())))
  [hdl in-mvar]
  (let ((= initialize
          ;; Default target in interactive context is `HscAsm', updating
          ;; to `HscInterpreted'.  Also, `dynamic' option is enabled in
          ;; REPL, since `sk' executable is compiled with `dynamic'
          ;; option specified in cabal configuration file.
          (do initSessionForMake
              (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))))
              (void (setSessionDynFlags dflags1))))
        (= withAsyncHandler
          (ghandle
           (\ e
             (do (liftIO
                  (case e
                    UserInterrupt (return ())
                    ThreadKilled  (return ())
                    _             (putStrLn (++ "eval-loop: got "
                                                (show e)))))
                 loop))))
        (= src-err-handler src-err
          (do (<- dflags getSessionDynFlags)
              (<- unqual getPrintUnqual)
              (let ((= sdoc (vcat (pprErrMsgBagWithLoc emsgs)))
                    (= style0 (mkErrStyle dflags unqual))
                    (= style1 (setStyleColoured True style0))
                    (= emsgs (srcErrorMessages src-err))))
              (return (Left (renderWithStyle dflags sdoc style1)))))
        (:: throw-async-io (-> AsyncException (Skc a)))
        (= throw-async-io (. liftIO throwIO))
        (= withErrorHandler m
          (ghandle
           (\ e
             (case (fromException e)
               (Just se) (src-err-handler se)
               Nothing   (case (fromException e)
                           (Just ae) (throw-async-io ae)
                           Nothing   (return (Left (show e))))))
           m))
        (= eval-one
          (do (<- (Input itype form out-mv) (liftIO (takeMVar in-mvar)))
              (let ((= print-name "Prelude.print")))
              (<- ret (withErrorHandler
                       (do (<- expanded (expands [form]))
                           (with-print-name print-name
                             (eval-form hdl itype expanded)))))
              (liftIO (putMVar out-mv ret))))
        (= loop
          (withAsyncHandler (>> eval-one loop))))
    (>> initialize loop)))

;;; Temporary set `print-name' as interactive print function and run
;;; `act'.
(defn (with-print-name (-> String (Skc a) (Skc a)))
  [print-name act]
  (withSession
   (\ he
     (do (<- names (parseName print-name))
         (case names
           (: name _) (>> (setSession
                           (he {hsc_IC
                                (setInteractivePrintName (hsc_IC he)
                                                         name)}))
                          act)
           _          (>> (failS "with-print-name: parse error")
                          act))))))

(defn (eval-form (-> Handle InSource [Code] (Skc Result)))
  [hdl itype forms]
  (| ((null forms)
      (return (Right "")))
     ((<- (Right decls) (evalBuilder parseTopDecls forms))
      (eval-decls decls))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement hdl itype stmt))
     (otherwise
      (case (evalBuilder parseImports forms)
        (Right idecl) (eval-imports idecl)
        (Left se)     (skSrcError (syntaxErrCode se)
                                  (syntaxErrMsg se))))))

(defn (eval-statement (-> Handle InSource HStmt (Skc Result)))
  [hdl itype stmt0]
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, is h f)) (update-hsc-env hdl itype hsc-env is h f)
        Nothing (return (Left "eval-statement: no result")))))

(defn (eval-imports (-> [HImportDecl] (Skc Result)))
  [imports]
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= mdls
              (++ "; " (intercalate ", "
                                    (map (. (showSDoc dflags) ppr)
                                         imports))))))
      (setContext (nubBy eq-ii (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(defn (eval-decls (-> [HDecl] (Skc Result)))
  [decls]
  (do (let ((= decls' (cvTopDecls (toOL decls)))))
      (<- (, tythings _ic) (evalDecls decls'))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr
                      (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystrs (foldr show-tything [] tythings))
            (= tystr (intercalate "\n" tystrs))))
      (return (Right tystr))))

(defn (update-hsc-env (-> Handle InSource HscEnv [Id] ForeignHValue
                          FixityEnv (Skc Result)))
  [hdl itype hsc-env ids hvals-io fixity-env]
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its implementation.
  (let ((= success fhvals ret
          (do (let ((= ic (hsc_IC hsc-env))
                    (= ic2 (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic_fix_env fixity-env}))
                    (= names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
              (<- dflags getSessionDynFlags)
              (liftIO (extendLinkEnv (zip names fhvals)))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (case names
                [name] (| ((== (occNameString (nameOccName name)) "it")
                           (return (Right ret))))
                _ (return
                    (Right (names-and-types dflags names ids))))))
        (= exception serialized
          (case serialized
            (EOtherException e) (return (Left (++ "*** Exception: " e)))
            (EExitCode ecode)   (liftIO (exitWith ecode))
            EUserInterrupt      (return (Left "Interrupt"))))
        (= incomplete
          (return (Left "update-hsc-env failed.")))
        (= eval-hvals-io
          (evalStmt hsc-env False (EvalThis hvals-io)))
        (= eval-for-prompt
          (do (<- stat (liftIO eval-hvals-io))
              (return (, stat ""))))
        (= eval-for-connection
          (liftIO (with-io-redirect hdl eval-hvals-io))))
    (do (<- (, status ret)
          ;; Switching behaviour between prompt and network
          ;; connection. Getting printed result as `String' for
          ;; connection by wrapping the execution of compiled result,
          ;; which is a value of `IO [HValue]' type.
          (case itype
            Prompt eval-for-prompt
            Connection eval-for-connection))
        (case status
          (EvalComplete _ (EvalSuccess hvs)) (success hvs ret)
          (EvalComplete _ (EvalException e)) (exception e)
          _                                  incomplete))))


;;; Auxiliary

(defn (var-name-and-type (-> DynFlags Name Var String))
  [dflags name var]
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (intercalate "\n"
                     (map (++ "; ")
                          (lines (++ nstr (++ " :: " typ))))))))

(defn (names-and-types (-> DynFlags [Name] [Var] String))
  [dflags names vars]
  (where (| ((all null tvs) "")
            (otherwise (intercalate "\n" tvs)))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))

(defn (eq-ii (-> InteractiveImport InteractiveImport Bool))
  [(IIModule x) (IIModule y)] (== x y)
  [(IIDecl x)   (IIDecl y)  ] (== (unLoc (ideclName x))
                                  (unLoc (ideclName y)))
  [_            _           ] False)
