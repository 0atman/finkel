;;; Loops in REPL.

(require SK.Core)

(defmodule SK.Repl.Loop
  (use
   ;; base
   (Control.Concurrent ((ThreadId) forkIO killThread))
   (Control.Concurrent.MVar ((MVar) newEmptyMVar putMVar takeMVar))
   (Control.Exception ((AsyncException ..) bracket catch throwIO))
   (Control.Monad (void when))
   (Control.Monad.IO.Class (liftIO))
   (Data.List (inits intercalate isSuffixOf nubBy))
   (System.Exit (exitWith))
   (System.IO ((Handle) hClose hFlush openTempFile stdout))
   (System.IO.Error (isDoesNotExistError))

   ;; bytestring
   (Data.ByteString.Builder (stringUtf8 toLazyByteString))
   (qualified Data.ByteString.Lazy.Char8 as BS)

   ;; directory
   (System.Directory (getTemporaryDirectory removeFile))

   ;; ghc
   (DynFlags ((DynFlags ..) (GhcLink ..) (HscTarget ..) (Way ..)
              addWay' defaultFatalMessager defaultFlushOut))
   (Exception (ghandle))
   (GHC (setSessionDynFlags))
   (GhcMonad ((Ghc ..) (GhcMonad ..) (Session ..) getSessionDynFlags
              withSession))
   (HscMain (hscParsedStmt))
   (HscTypes ((HscEnv ..) (InteractiveContext ..) (InteractiveImport ..)
              (FixityEnv) extendInteractiveContextWithIds
              setInteractivePrintName))
   (HsImpExp ((ImportDecl ..)))
   (InteractiveEval (getContext parseName setContext))
   (Linker (extendLinkEnv))
   (Name ((Name) getName nameOccName occNameString))
   (Outputable (ppr showPpr showSDoc))
   (TyCoRep ((TyThing ..)))
   (Var ((Id) (Var) varType))

   ;; ghci
   (GHCi (evalStmt))
   (GHCi.Message ((EvalExpr ..) (EvalResult ..) (EvalStatus_ ..)
                  (SerializableException ..)))
   (GHCi.RemoteTypes ((ForeignHValue)))

   ;; haskeline
   (System.Console.Haskeline
    ((InputT) defaultSettings getInputLine handleInterrupt outputStr
     outputStrLn runInputT throwTo withInterrupt))

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Builder ((HDecl) (HImportDecl)  (HStmt) evalBuilder))
   (Language.SK.Eval (evalDecls))
   (Language.SK.Lexer (evalSP))
   (Language.SK.Reader (sexpr))
   (Language.SK.Run (runSkc skErrorHandler withSourceErrorHandling))
   (Language.SK.Syntax (parseImports parseStmt parseTopDecls))

   ;; internal
   (SK.Repl.Env)
   (SK.Repl.Listen)
   (SK.Repl.IORedirect)
   (SK.Repl.Types))

  (export
   read-form
   eval-loop read-print-loop init-form start-repl
   make-tmpfile cleanup-tmpfile))


;;; Starting the REPL

;;; Start REPL, maybe listen to given port number.
(defdo (start-repl (-> (Maybe Int) SkEnv (IO ())))
  (mb-listen ske)
  (bracket
   make-tmpfile
   cleanup-tmpfile
   (\ (, _tmpfile hdl)
     (do (<- in-mv newEmptyMVar)
         (start-listener mb-listen in-mv)
         (<- eval-tid
           (forkIO (void (runSkc (eval-loop hdl in-mv) ske))))
         (let ((= rpl (read-print-loop in-mv eval-tid))
               (= reader (runInputT defaultSettings rpl))))
         (run-repl reader initial-repl-state)))))

;;; Return a file path and handle for temporary use.
(defn (make-tmpfile (IO (, FilePath Handle)))
  (do (<- dir getTemporaryDirectory)
      (openTempFile dir "sk-repl-.out")))

;;; Start listner in separate thread, and return temporary file for
;;; getting String output from statement.
(defn (start-listener (-> (Maybe Int) (MVar Input) (IO ())))
  (mb-listen in-mv)
  (maybe (return ())
         (\ port
           (do (putStrLn (++ "Listening on port " (show port)))
               (void (forkIO (listener (fromIntegral port) in-mv)))))
         mb-listen))

;; Clean up temporary file.
(defn (cleanup-tmpfile (-> (, FilePath Handle) (IO ())))
  ((, path hdl))
  (catch (do (hClose hdl)
             (removeFile path))
    (\ e (if (isDoesNotExistError e)
             (return ())
             (throwIO e)))))


;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(defn (read-print-loop (-> (MVar Input) ThreadId (InputT Repl ())))
  (to-mvar eval-tid)
  (let ((= print-io result-mv
          (do (<- result (liftIO (takeMVar result-mv)))
              (case result
                (Right str) (when (not (null str))
                              (outputStrLn str))
                (Left str) ((if (isSuffixOf "\n" str)
                                outputStr
                                outputStrLn)
                            str))
              (liftIO (hFlush stdout))))
        (= as-repl-macro str
          (concat ["(*_ " str ")"]))
        (= go result-mv
          (do (<- st0 (lift get-repl-state))
              (let ((= prompt
                      (if (null (pending-input st0)) "> " ""))))
              (<- mb-input
                ;; Handle interrupt signals thrown while waiting for
                ;; input, to handle `Ctrl-C' key presses without valid
                ;; evaluation form, and refresh intermediate user inputs
                ;; in Repl state.
                (handleInterrupt
                 (lift (do (<- st1 get-repl-state)
                           (put-repl-state (st1 {pending-input []}))
                           (return (Just []))))
                 (getInputLine prompt)))
              (maybe quit (go1 st0 result-mv) mb-input)))
        (= go1 st0 result-mv line
          (case line
            [] (go result-mv)
            (: h tl) (| ((== line "(quit)") quit)
                        ((&& (null (pending-input st0))
                             (== \, h))
                         (if (elem tl (tail (inits "quit")))
                             quit
                             (go2 result-mv (as-repl-macro tl))))
                        (otherwise
                         (go2 result-mv line)))))
        (= go2 result-mv line
          (do (<- mb-form (lift (read-form line)))
              (let ((= input form
                      (Input Prompt form result-mv))))
              (case mb-form
                (Just form) (do (liftIO (putMVar to-mvar (input form)))
                                (print-io result-mv)
                                (go result-mv))
                Nothing (go result-mv))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop result-mv
          (handleInterrupt
           (do (throwTo eval-tid UserInterrupt)
               (print-io result-mv)
               (loop result-mv))
           (go result-mv))))

    ;; Print the result from boot expression, then start the loop.
    (withInterrupt
     (do (<- result-mv (liftIO newEmptyMVar))
         (liftIO
          (putMVar to-mvar (Input Prompt init-form result-mv)))
         (print-io result-mv)
         (loop result-mv)))))

;;; Form to initialize the REPL.
(defn (init-form Code)
  '(begin
    (require Prelude)
    (require SK.Prelude)
    (require SK.Repl.Env)
    (require SK.Repl.Macro)
    (putStrLn
     "Hit `Ctrl-d' to quit, type `,?' for more information.")))

;;; Read single S-expression form.
(defn (read-form (-> String (Repl (Maybe Code))))
  (input0)
  (do (<- st get-repl-state)
      (let ((= input1
              (++ (pending-input st)
                  [(toLazyByteString (stringUtf8 (: \\n input0)))]))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret)))))
      (case (evalSP sexpr (Just "<repl>") (BS.concat input1))
        (Right forms) (put-and-return [] (Just forms))
        (Left _err)   (put-and-return input1 Nothing))))


;;; Eval loop

(defn (eval-loop (-> Handle (MVar Input) (Skc ())))
  (hdl in-mvar)
  (let ((= initialize
          ;; Default target in interactive context is `HscAsm', updating
          ;; to `HscInterpreted'.  Also, `dynamic' option is enabled in
          ;; REPL, since `sk' executable is compiled with `dynamic'
          ;; option specified in cabal configuration file.
          (do (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))
                    (= dflags2 (addWay' WayDyn dflags1))))
              (void (setSessionDynFlags dflags2))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (putTheHscEnv session))))
        (= withAsyncHandler
          (ghandle
           (\ e
             (do (liftIO
                  (case e
                    UserInterrupt (return ())
                    ThreadKilled  (return ())
                    _             (putStrLn
                                   (++ "eval-loop: got " (show e)))))
                 loop))))
        (= withSkErrorHandler m
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))

        (= eval-one
          (do (<- (Input itype form out-mv)
                (liftIO (takeMVar in-mvar)))
              (let ((= print-name
                      (case itype
                        Prompt "Prelude.print"
                        _ "SK.Repl.Env.prit"))))
              (<- ret
                (withSkErrorHandler
                 (do (<- expanded (expands [form]))
                     (with-print-name print-name
                       (eval-form hdl itype expanded)))))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (do (putTheHscEnv session)
                          (putMVar out-mv ret)))))
        (= loop
          (withAsyncHandler (>> eval-one loop))))
    (>> initialize loop)))

;;; Temporary set `print-name' as interactive print function and run
;;; `act'.
(defn (with-print-name (-> String (Skc a) (Skc a)))
  (print-name act)
  (withSession
   (\ he
     (do (<- names (parseName print-name))
         (case names
           (: name _) (>> (setSession
                           (he {hsc_IC
                                (setInteractivePrintName (hsc_IC he)
                                                         name)}))
                          act)
           _          (>> (failS "with-print-name: parse error")
                          act))))))

(defn (eval-form (-> Handle InSource [Code] (Skc Result)))
  (hdl itype forms)
  (| ((null forms)
      (return (Right "")))
     ((<- (Right decls) (evalBuilder parseTopDecls forms))
      (eval-decls decls))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement hdl itype stmt))
     (otherwise
      (case (evalBuilder parseImports forms)
        (Right idecl) (eval-imports idecl)
        (Left err) (return (Left (++ err "\n")))))))

(defn (eval-statement (-> Handle InSource HStmt (Skc Result)))
  (hdl itype stmt0)
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, is h f)) (update-hsc-env hdl itype hsc-env is h f)
        Nothing (return (Left "eval-statement: no result")))))

(defn (eval-imports (-> [HImportDecl] (Skc Result)))
  (imports)
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= mdls
              (++ "; " (intercalate ", "
                                    (map (. (showSDoc dflags) ppr)
                                         imports))))))
      (setContext (nubBy eq-ii (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(defn (eval-decls (-> [HDecl] (Skc Result)))
  (decls)
  (do (<- (, tythings _ic) (evalDecls decls))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr
                      (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystrs (foldr show-tything [] tythings))
            (= tystr (intercalate "\n" tystrs))))
      (return (Right tystr))))

(defn (update-hsc-env (-> Handle InSource HscEnv [Id] ForeignHValue
                          FixityEnv (Skc Result)))
  (hdl itype hsc-env ids hvals-io fixity-env)
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its implementation.
  (let ((= success fhvals ret
          (do (let ((= ic (hsc_IC hsc-env))
                    (= ic2 (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic_fix_env fixity-env}))
                    (= names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
              (<- dflags getSessionDynFlags)
              (liftIO (extendLinkEnv (zip names fhvals)))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (case names
                [name] (| ((== (occNameString (nameOccName name)) "it")
                           (return (Right ret))))
                _ (return
                    (Right (names-and-types dflags names ids))))))
        (= exception serialized
          (case serialized
            (EOtherException str) (return (Left str))
            (EExitCode ecode)     (liftIO (exitWith ecode))
            EUserInterrupt        (return (Left "Interrupt"))))
        (= incomplete
          (return (Left "update-hsc-env failed.")))
        (= eval-hvals-io
          (evalStmt hsc-env False (EvalThis hvals-io)))
        (= eval-for-prompt
          (do (<- stat (liftIO eval-hvals-io))
              (return (, stat ""))))
        (= eval-for-connection
          (liftIO (with-io-redirect hdl eval-hvals-io))))
    (do (<- (, status ret)
          ;; Switching behaviour between prompt and network
          ;; connection. Getting printed result as `String' for
          ;; connection by wrapping the execution of compiled result,
          ;; which is a value of `IO [HValue]' type.
          (case itype
            Prompt eval-for-prompt
            Connection eval-for-connection))
        (case status
          (EvalComplete _ (EvalSuccess hvs)) (success hvs ret)
          (EvalComplete _ (EvalException e)) (exception e)
          _                                  incomplete))))


;;; Auxiliary

(defn (var-name-and-type (-> DynFlags Name Var String))
  (dflags name var)
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (intercalate "\n"
                     (map (++ "; ")
                          (lines (++ nstr (++ " :: " typ))))))))

(defn (names-and-types (-> DynFlags [Name] [Var] String))
  (dflags names vars)
  (where (| ((all null tvs) "")
            (otherwise (intercalate "\n" tvs)))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))

(defn (eq-ii (-> InteractiveImport InteractiveImport Bool))
  [(IIModule x) (IIModule y)] (== x y)
  [(IIDecl x)   (IIDecl y)  ] (== (unLoc (ideclName x))
                                  (unLoc (ideclName y)))
  [_            _           ] False)
