;;;; Macros used in REPL.

;;; This module contains macros accessible from REPL. Main purpose of
;;; using macros for REPL is to access runtime value of `SkEnv'. Macro
;;; body can contain codes accessing `SkEnv', and then the code could be
;;; invoked from REPL via evaluating the typed in forms.

;; ghc
(require Config (cProjectVersionInt))

;; Internal
(require SK.Core)

(defmodule SK.Repl.Macro
  (use
   ;; base
   (Control.Exception ((Exception ..)))
   (Control.Monad (filterM void))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.Function (on))
   (Data.List (find intersperse partition sortBy))
   (Data.Maybe (catMaybes))

   ;; bytestring
   (qualified Data.ByteString.Char8 as C8)

   ;; directory
   (System.Directory
    (getCurrentDirectory getDirectoryContents setCurrentDirectory))

   ;; filepath
   (System.FilePath (isAbsolute makeRelative))

   ;; ghc
   (DynFlags ((DynFlags ..) (GhcMode ..) (HasDynFlags ..)
              (HscTarget ..) (PackageFlag ..) thisPackage))
   (ErrUtils (pprErrMsgBagWithLoc))
   (Exception (gcatch gbracket))
   (FamInstEnv (pprFamInst))
   (FastString ((FastString) unpackFS))
   (Finder (flushFinderCaches uncacheModule))
   (GHC ((ModuleInfo) getBindings getModuleGraph getModuleInfo
         getPrintUnqual isLoaded lookupName lookupModule modInfoExports
         parseDynamicFlags setSessionDynFlags setTargets))
   (GhcMake ((LoadHowMuch ..)))
   (GhcMonad ((GhcMonad ..) getSessionDynFlags withSession))
   (HscMain (hscTcRnLookupRdrName))
   (HscTypes ((HscEnv ..) (InteractiveContext ..) (InteractiveImport ..)
              (ModSummary) (ModuleGraph) (SourceError)
              emptyInteractiveContext handleFlagWarnings ms_mod_name
              srcErrorMessages tyThingParent_maybe))
   (HsImpExp (simpleImportDecl))
   (IfaceSyn (showToHeader))
   (InstEnv (pprInstance))
   (InteractiveEval (abandonAll getContext getInfo parseName setContext
                                showModule))
   (Linker (initDynLinker linkModule showLinkerState unload))
   (Module (mkModuleNameFS moduleNameString))
   (Name ((Name) getName nameIsFromExternalPackage nameModule
          nameOccName nameSrcSpan))
   (NameSet (elemNameSet mkNameSet))
   (Outputable ((SDoc) $$ <+> dcolon nest ppr sep showPpr showSDoc
                showSDocForUser text vcat))
   (Module ((Module ..) mkModuleName))
   (Packages ((PackageConfig) componentId packageNameString
              readPackageConfigs))
   (PprTyThing (pprTyThing pprTyThingInContextLoc pprTypeForUser))
   (SrcLoc (isGoodSrcSpan noLoc))
   (TyCoRep ((TyThing ..)))
   (Util (looksLikeModuleName))

   (qualified GhcMake as GhcMake)

   ;; ghc-boot
   (GHC.PackageDb (toStringRep))

   ;; ghci
   (Debugger (pprTypeAndContents))

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Builder (mkRdrName))
   (Language.SK.Eval (evalExprType evalTypeKind))
   (Language.SK.Make (asModuleName make))
   (Language.SK.Run (buildHsSyn))
   (Language.SK.Syntax (parseExpr parseType))

   ;; internal
   (SK.Core))

  (export *_))


;;; Compile time helper for GHC version compatibility

(eval-when (compile)
  (defn (ghc-version Int)
    (read cProjectVersionInt)))

(macrolet ((extra-imports _
              (if (<= 804 ghc-version)
                  '(import qualified HscTypes as HscTypes)
                  '(begin))))
  (extra-imports))

(eval-when (compile)
  (defmacro child-filter _
    (if (< ghc-version 804)
        '(\ (, t _f _ci _fi) t)
        '(\ (, t _f _ci _fi _sd) t)))

  (defmacro ppr-info-args _
    (if (< ghc-version 804)
        '(, thing _fixity cls-insts fam-insts)
        '(, thing _fixity cls-insts fam-insts _sd)))

  (defmacro ppr-tt-args _
    (if (< ghc-version 804)
        '(, thing _fixity _cls-insts _fam-insts)
        '(, thing _fixity _cls-insts _fam-insts _sd))))

(defn (graph->summaries (-> ModuleGraph [ModSummary]))
  (macrolet ((body _
               (if (< ghc-version 804)
                   'id
                   'HscTypes.mgModSummaries)))
    (body)))


;;; Auxiliary

(type ReplCommand
  (-> [Code] (Skc Code)))

(defn (mk-ii-fs (-> FastString InteractiveImport))
  (name)
  (IIDecl (simpleImportDecl (mkModuleNameFS name))))

(defn (mk-ii (-> String InteractiveImport))
  (. mk-ii-fs fsLit))

(defn (code->mb-string (-> Code (Maybe String)))
  (code)
  (case (unCode code)
    (Atom (ASymbol sym)) (Just (unpackFS sym))
    (Atom (AString str)) (Just str)
    _                    Nothing))

(defn (located-list (-> [Code] Code))
  (xs)
  (case xs
    [] nil
    _ (let ((= l (getLoc (mkLocatedForm xs))))
        (LForm (L l (List xs))))))

(defn (show-sdoc-for-user-m (-> SDoc (Skc String)))
  (sdoc)
  (do (<- dflags getDynFlags)
      (<- unqual getPrintUnqual)
      (return (showSDocForUser dflags unqual sdoc))))

(defn (invalid-form-error (-> String [Code] (Skc a)))
  [label forms]
  (let ((= form (car (located-list forms)))
        (= msg (concat [label ": invalid form `" (show form) "'"])))
    (skSrcError form msg)))

(defn (compile-to-obj-file (-> String (Skc Code)))
  (str)
  (gbracket
   (do (<- dflags getSessionDynFlags)
       (<- context getContext)
       (return (, dflags context)))
   (\ (, dflags context)
     (do (setDynFlags dflags)
         (setContext context)))
   (\ (, dflags _context)
     (do (setDynFlags (dflags {hscTarget HscAsm}))
         (make [(, str Nothing)] True Nothing)
         (return '(begin))))))

(defn (link-module-obj (-> FastString (Skc Code)))
  (name)
  (do (<- hsc-env getSession)
      (let ((= mname (mkModuleNameFS name))
            (= uid (thisPackage (hsc_dflags hsc-env)))))
      (liftIO (do (unload hsc-env [])
                  (linkModule hsc-env (Module uid mname))))
      (return '(begin))))

(defn (compile-and-import (-> FilePath (Skc Code)))
  (path)
  (do (let ((= mname (asModuleName path))))
      (<- _ (compile-to-obj-file path))
      (<- mods (fmap envContextModules getSkEnv))
      (setContext (map mk-ii (: mname mods)))
      (return '(begin))))

(defn (env-context-on-exception (-> (Skc a) (Skc ())))
  (action)
  (gcatch
   (void action)
   (\ e
     (do (case (:: (fromException e) (Maybe SourceError))
           (Just se)
           (do (<- dflags getSessionDynFlags)
               (liftIO
                (putStr (unlines (map (showSDoc dflags)
                                      (pprErrMsgBagWithLoc
                                       (srcErrorMessages se)))))))
           _ (liftIO (print e)))
         (<- mods (fmap envContextModules getSkEnv))
         (setContext (map mk-ii mods))))))

(defn (lookup-package-config
       (-> DynFlags String (IO (Maybe PackageConfig))))
  "Lookup `PackageConfig' of given package in `DynFlags'."
  (dflags pkgname)
  (do (<- confs (liftIO (readPackageConfigs dflags)))
      (return
        (find (. (== pkgname) packageNameString)
              (concat (map snd confs))))))

(defn (browse-module (-> Module ModuleInfo (Skc Code)))
  "Simplified version of `GHCi.UI.browseModule'."
  (mdl mod-info)
  (do (let ((= names (modInfoExports mod-info))
            (= sorted-names
              (++ (loc-sort local) (occ-sort external)))
            (= (, local external)
              (partition (. (== mdl) nameModule) names))
            (= occ-sort (sortBy (on compare nameOccName)))
            (= loc-sort ns
              (| ((<- (: n _) ns) (isGoodSrcSpan (nameSrcSpan n))
                  (sortBy (on compare nameSrcSpan) ns))
                 (otherwise (occ-sort ns))))
            (= pretty
              (pprTyThing showToHeader))))
      (<- mb-things (mapM lookupName sorted-names))
      (let ((= things (catMaybes mb-things))
            (= prettyThings (map pretty things))))
      (<- str (show-sdoc-for-user-m (vcat prettyThings)))
      (return `(putStrLn ,str))))

;;; Mostly translated from `GHCi.UI.infoThing'.
(defn (info-name (-> Code (Skc Code)))
  (thing)
  (do (<- sdoc (info-thing True (show thing)))
      (<- str (show-sdoc-for-user-m sdoc))
      (return `(putStrLn ,str))))

(defn (info-thing (-> Bool String (Skc SDoc)))
  (all-info str)
  (do (<- names (parse-name str))
      (<- mb_stuffs (mapM (getInfo all-info) names))
      (let ((= filtered (filter-out-children
                         (child-filter)
                         (catMaybes mb_stuffs)))
            (= ppr-info (ppr-info-args)
              ($$ (pprTyThingInContextLoc thing)
                  ($$ (vcat (map pprInstance cls-insts))
                      (vcat (map pprFamInst fam-insts)))))))
      (return
        (vcat (intersperse (text "") (map ppr-info filtered))))))

(defn (parse-name (-> String (Skc [Name])))
  (str)
  (if (elem str ["()" "[]"])
      (parseName str)
      (withSession
       (\ hsc-env
         (liftIO
          (let ((= lrdr-name (genSrc (mkRdrName (fsLit str)))))
            (hscTcRnLookupRdrName hsc-env lrdr-name)))))))

(defn (filter-out-children (-> (-> a TyThing) [a] [a]))
  (get-thing xs)
  (let ((= all-names (mkNameSet (map (. getName get-thing) xs)))
        (= has-parent x
          (case (tyThingParent_maybe (get-thing x))
            (Just p) (elemNameSet (getName p) all-names)
            Nothing  False)))
    (filter (. not has-parent) xs)))


;;; REPL commands

(defn (compile-obj-cmd ReplCommand)
  "Compile source code to object code."
  (forms)
  (let ((= err
          (skSrcError (located-list forms)
                      (++ "compile-obj: not a FilePath: "
                          (show forms)))))
    (case forms
      [form] (maybe err
                    (\ src
                      (do (liftIO
                           (putStrLn (++ "; compile-obj: " src)))
                          (compile-to-obj-file src)))
                    (code->mb-string form))
      _ err)))

(defn (link-module-cmd ReplCommand)
  "Link the object code of given module."
  (forms)
  (let ((= go name
          (do (liftIO
               (putStrLn (++ "; link-module: " (unpackFS name))))
              (link-module-obj name)))
        (= err
          (skSrcError form (++ "link-module: not a symbol: "
                               (show form))))
        (= form
          (case forms
            [] nil
            _ (head forms))))
    (case (map unCode forms)
      [(Atom (ASymbol sym))] (go sym)
      _ err)))

(defn (load-cmd ReplCommand)
  "Load a module source code file. Handles absolute paths and relative
paths from import directories."
  (forms)
  (let ((= find-file idirs path
          (if (isAbsolute path)
              (find-absolute idirs path)
              (compile-and-import path)))
        (= find-absolute dirs path
          (case dirs
            (: dir dirs') (find-absolute' dir dirs' path)
            []            (cant-find-err path)))
        (= find-absolute' dir dirs path
          (do (<- dir' (if (== dir ".")
                           (liftIO getCurrentDirectory)
                           (return dir)))
              (find-file dirs (makeRelative dir' path))))
        (= cant-find-err file
          (skSrcError (located-list forms)
                      (++ "load: cannot find: " file)))
        ;; From `GhcMake.discardIC'.
        (= discardIC hsc-env
          (let ((= empty-ic (emptyInteractiveContext dflags))
                (= new-ic-monad (keep-external-name ic_monad))
                (= old-ic (hsc_IC hsc-env))
                (= dflags (hsc_dflags hsc-env))
                (= keep-external-name ic-name
                  (where
                      (| ((nameIsFromExternalPackage this-pkg
                                                     old-name)
                          old-name)
                         (otherwise
                          (ic-name empty-ic)))
                    (= this-pkg (thisPackage dflags))
                    (= old-name (ic-name old-ic)))))
            (hsc-env {hsc_IC (empty-ic {ic_monad new-ic-monad})})))
        (= clear-all
          ;; Cleare various states: resume, finder cache, targets,
          ;; interactive context ... etc.
          (do (<- graph0 getModuleGraph)
              (<- _ abandonAll)
              (<- _ (setTargets []))
              (<- _ (GhcMake.load LoadAllTargets))
              (<- hsc-env getSession)
              (let ((= graph1 (graph->summaries graph0))
                    (= uncache
                      (. (uncacheModule hsc-env) ms_mod_name))))
              (liftIO (do (mapM_ uncache graph1)
                          (flushFinderCaches hsc-env)))
              (setSession (discardIC hsc-env)))))
    (case forms
      [form] (maybe
              (skSrcError form (++ "load: not a FilePath: "
                                   (show form)))
              (\ path
                (do (liftIO (putStrLn (++ "; load: " path)))
                    ;; Clear current state first.
                    clear-all
                    ;; Find the source file path and compile, load, and
                    ;; link the module.
                    (<- dflags getSessionDynFlags)
                    (env-context-on-exception
                     (find-file (importPaths dflags) path))
                    (return '(begin))))
              (fromCode form))
      _ (skSrcError (located-list forms)
                    (++ "load: invalid form: " (show forms))))))

(defn (set-cmd ReplCommand)
  "Set command line flags, see `GHCi.UI.newDynFlags'."
  (forms)
  (case forms
    (: _ _) (| ((all symbol? forms)
                ;; Always using `setSessionDynFlags' for `set' REPL
                ;; command to support `-package' flag.
                (do (<- dflags0 getSessionDynFlags)
                    (let ((= flags (map (. noLoc symbolName) forms))))
                    (<- (, dflags1 _leftovers warns)
                      (parseDynamicFlags dflags0 flags))
                    (liftIO (handleFlagWarnings dflags1 warns))
                    (<- _ (setSessionDynFlags dflags1))
                    (return '(begin)))))
    _ (skSrcError nil "$set: empty form")))

(defn (debug-cmd ReplCommand)
  "Modify debug settings in REPL."
  (forms)
  (case forms
    [] (do (<- bool (fmap envDebug getSkEnv))
           (return (toCode bool)))
    [form] (| ((<- (Just bool) (fromCode form))
               (do (modifySkEnv (\ e (e {envDebug bool})))
                   (return '(begin)))))
    _ (let ((= lst (located-list forms)))
        (skSrcError lst (++ "debug: invalid form: " (show lst))))))

(defn (cd-cmd ReplCommand)
  "Function to change current directory."
  (forms)
  (case forms
    [arg1] (| ((<- (Just path) (code->mb-string arg1))
               (do (liftIO (setCurrentDirectory path))
                   (return '(begin)))))
    _ (skSrcError (head forms)
                  (++ "cd: expecting symbol or string but got "
                      (show forms)))))

(defn (pwd-cmd ReplCommand)
  "Function to show current directory."
  (const (fmap toCode (liftIO getCurrentDirectory))))

(defn (ls-cmd ReplCommand)
  "List directory contents."
  (forms)
  (do (<- mb-path
        (case forms
          [path] (return (code->mb-string path))
          [] (return (Just "./"))
          _ (skSrcError (located-list forms)
                        (++ "ls: invalid args: " (show forms)))))
      (case mb-path
        (Just path) (do (liftIO
                         (>>= (getDirectoryContents path)
                              (mapM_ putStrLn)))
                        (return '(begin)))
        _ (skSrcError (located-list forms)
                      (++ "ls: invalid path: " (show forms))))))

(defn (bindings-cmd ReplCommand)
  "Almost same as `GHCi.UI.showBindings'."
  (_forms)
  (where (do (<- bs getBindings)
             (<- docs (mapM make-doc (reverse bs)))
             (<- str (show-sdoc-for-user-m (vcat docs)))
             (return `(putStrLn ,str)))
    (:: make-doc (-> TyThing (Skc SDoc)))
    (= make-doc tt
      (case tt
        (AnId i) (pprTypeAndContents i)
        _        (do (<- mb-stuff (getInfo False (getName tt)))
                     (return (maybe (text "") ppr-tt mb-stuff)))))
    (= ppr-tt (ppr-tt-args)
      (pprTyThing showToHeader thing))))

(defn (context-cmd ReplCommand)
  (_form)
  (where (do (<- context getContext)
             (<- dflags getSessionDynFlags)
             (return `(putStr ,(result dflags context))))
    (= result dflags context
      (unlines (: "; context" (map (context-string dflags) context))))
    (= context-string dflags ctx
      (case ctx
        (IIDecl decl)
        (++ ";  IIDecl: " (showSDoc dflags (ppr decl)))
        (IIModule mname)
        (++ ";  IIModule: " (moduleNameString mname))))))

(defn (dflags-cmd ReplCommand)
  (_form)
  (do (<- dflags getDynFlags)
      (let ((= ss
              ["; dflags:"
               (++ ";  ghcLink: " (show (ghcLink dflags)))
               (++ ";  ghcMode: " (showGhcMode (ghcMode dflags)))
               (++ ";  hscTarget: " (show (hscTarget dflags)))
               (++ ";  objectDir: " (show (objectDir dflags)))
               (++ ";  thisInstalledUnitId: "
                   (showPpr dflags (thisInstalledUnitId dflags)))])
            (= showGhcMode m
              (case m
                CompManager "CompManager"
                OneShot     "OneShot"
                MkDepend    "MkDepend"))))
      (return `(putStr ,(unlines ss)))))

(defn (linker-cmd ReplCommand)
  (_form)
  ;; XXX: `Linker.showLinkerState' reads from `v_PersistentLinkerState',
  ;; which is not exposed from the module its defined ... not sure how
  ;; to get resulting output as `String' other than redirecting output
  ;; to stdout.
  (do (<- hsc-env getSession)
      (liftIO (do (initDynLinker hsc-env)
                  (showLinkerState (hsc_dflags hsc-env))))
      (return '(begin))))

(defn (macros-cmd ReplCommand)
  (_form)
  (do (<- macros (fmap envMacros getSkEnv))
      (let ((= macro-strings
              (unlines
               (: "; macros: "
                  (map (++ ";  ") (macroNames macros)))))))
      (return `(putStr ,macro-strings))))

(defn (modules-cmd ReplCommand)
  (_form)
  (do (<- graph0 getModuleGraph)
      (let ((= graph1 (graph->summaries graph0))))
      (<- graph2 (filterM (. isLoaded ms_mod_name) graph1))
      (<- mods (mapM showModule graph2))
      (return `(putStr ,(unlines mods)))))

(defn (packages-cmd ReplCommand)
  (_form)
  (do (<- dflags getDynFlags)
      (let ((= pr (++ ";   "))
            (= pr-flag flag
              (case flag
                (ExposePackage n _ _) (pr n)
                (HidePackage n)       (pr (++ "hiding " n))))
            (= pkgs
              (: "; packages" (map pr-flag (packageFlags dflags))))))
      (return `(putStr ,(unlines pkgs)))))

(defn (paths-cmd ReplCommand)
  (_form)
  (do (<- dflags getDynFlags)
      (<- cwd (liftIO getCurrentDirectory))
      (let ((= ipaths (importPaths dflags))
            (= result
              (unlines
               (concat
                [["; current working directory:"
                  (++ ";   " cwd)
                  "; module import search paths:"]
                 (if (null ipaths)
                     [";    none"]
                     (map (++ ";    ") ipaths))])))))
      (return `(putStr ,result))))

(defn (info-cmd ReplCommand)
  (forms)
  (case forms
    [form] (| ((<- (Atom (ASymbol _)) (unCode form))
               (info-name form)))
    _ (invalid-form-error "info" forms)))

;; From `GHCi.UI.typeOfExpr'.
(defn (type-cmd ReplCommand)
  (forms)
  (case forms
    [form] (do (<- expr (buildHsSyn parseExpr forms))
               (<- ty (evalExprType expr))
               (let ((= sdoc
                       (sep [(text (show form))
                             (nest 2 (<+> dcolon
                                          (pprTypeForUser ty)))]))))
               (<- str (show-sdoc-for-user-m sdoc))
               (return `(putStrLn ,str)))
    _ (invalid-form-error "type" forms)))

;; From `GHCi.UI.kindOfType'
(defn (kind-cmd ReplCommand)
  (forms)
  (case forms
    [form] (do (<- ty0 (buildHsSyn parseType forms))
               (<- (, _ kind) (evalTypeKind ty0))
               (let ((= sdoc
                       (<+> (text (show form))
                            (<+> dcolon (pprTypeForUser kind))))))
               (<- str (show-sdoc-for-user-m sdoc))
               (return `(putStrLn ,str)))
    _ (invalid-form-error "kind" forms)))

;;; Mostly taken from `GHCi.UI.browseCmd'.
(defn (browse-cmd ReplCommand)
  (forms)
  (let ((= go name
          (| ((looksLikeModuleName name)
              (do (<- mdl (lookupModule (mkModuleName name) Nothing))
                  (<- mb-mod-info (getModuleInfo mdl))
                  (case mb-mod-info
                    (Just mod-info) (browse-module mdl mod-info)
                    Nothing (return
                              `(putStrLn
                                (++ "unknown module: " ,name))))))
             (otherwise err)))
        (= err
          (skSrcError (located-list forms)
                      (++ "browse: invalid form: " (show forms)))))
    (case (map unCode forms)
      [(Atom (ASymbol sym))] (go (unpackFS sym))
      _ err)))

;;; Lookup matching linkable with given name, and set
;;; `thisInstalledUnitId' field in current `DynFlags' to the component
;;; when linkable were found.  By setting component, REPL will recompile
;;; module from SK source code, by ignoring module found in pre-compiled
;;; library linkable.  This behaviour may useful when working with cabal
;;; package library modules from REPL.
(defn (component-cmd ReplCommand)
  (forms)
  (do (<- name (case forms
                 [form] (| ((<- (Just str) (fromCode form))
                            (return str)))
                 _ (let ((= lst (located-list forms)))
                     (skSrcError lst (++ "component: invalid form: "
                                         (show lst))))))
      (<- dflags0 getDynFlags)
      (let ((= set-this-unit-id cid
              (do (let ((= flags (map noLoc ["-this-unit-id" cid]))))
                  (<- (, dflags1 _ _)
                    (parseDynamicFlags dflags0 flags))
                  (setDynFlags dflags1)
                  (liftIO
                   (putStrLn
                    (concat ["; this unit id set to `" cid "'"])))))
            (= not-found
              (liftIO
               (putStrLn
                (concat ["; package " (show name) " not found"]))))))
      (<- mb-component-id
        (liftIO
         (do (<- mb-pc (maybe (return Nothing)
                              (lookup-package-config dflags0)
                              (code->mb-string name)))
             (return (fmap (. C8.unpack
                              (. toStringRep componentId))
                           mb-pc)))))
      (case mb-component-id
        (Just cid) (set-this-unit-id cid)
        Nothing    (| ((elem name ['this 'main])
                       (set-this-unit-id (show name)))
                      (otherwise not-found)))
      (return '(begin))))

(defn (help-cmd ReplCommand)
  (_form)
  (return
    `(putStrLn "DESCRIPTION:

  REPL meta macro, ARGS varies per COMMAND.

COMMANDS:

  bindings      - show current bindings in REPL
  cd DIR        - change working directory to DIR
  context       - show current REPL context
  dflags        - show current DynFlags information
  help          - show this help
  info NAME     - show info of NAME
  linker        - show linker information
  load FILE     - compile and load FILE
  ls            - list files in currency directory
  macros        - show macros defined in REPL environment
  modules       - show loaded modules
  packages      - show accessible packages
  paths         - show paths
  pwd           - print working directory
  set FLAGS ... - parse and set FLAGS
  type FORM     - show type of FORM
")))


;;; REPL command macro

(defn (commands [(, Code ReplCommand)])
  [(, 'bindings bindings-cmd)
   (, 'browse browse-cmd)
   (, 'cd cd-cmd)
   (, 'compile-obj compile-obj-cmd)
   (, 'component component-cmd)
   (, 'context context-cmd)
   (, 'debug debug-cmd)
   (, 'dflags dflags-cmd)
   (, 'help help-cmd)
   (, 'info info-cmd)
   (, 'kind kind-cmd)
   (, 'link-module link-module-cmd)
   (, 'linker linker-cmd)
   (, 'load load-cmd)
   (, 'ls ls-cmd)
   (, 'macros macros-cmd)
   (, 'modules modules-cmd)
   (, 'packages packages-cmd)
   (, 'paths paths-cmd)
   (, 'pwd pwd-cmd)
   (, 'set set-cmd)
   (, 'type type-cmd)])

(defmacro* *_ form
  (case form
    (: cmd args) (| ((<- (Just fn) (lookup cmd commands))
                     (fn args)))
    _ (let ((= lst (located-list form)))
        (skSrcError lst (++ "invalid args: " (show lst))))))
