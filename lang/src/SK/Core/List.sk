;;; Fundamental functions for list

#p(LANGUAGE FlexibleInstances
            TypeSynonymInstances)

(:docn "List related functions.

This module is compiled before defining core macros, since some of the
functions defined in this modules are used in macro defined in
\"SK.Core\" module.")

(module SK.Core.List
  ;; exception
  (SkListException ..)

  ;; cxrs
  car caar cadr caaar caadr cadar caddr
  caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr

  cdr cdar cddr cdaar cdadr cddar cdddr
  cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr

  ;; predicates
  is-atom is-pair is-list is-hslist
  is-symbol is-string is-char is-integer is-fractional is-unit

  ;; list constructors
  cons list (ListableType ..) append

  ;; higher order functions
  mapcar)

;;; Requires

;; base
(require Prelude)
(require Control.Exception (throw))

;; sk-kernel
(require Language.SK)
(require Language.SK.SKC ((SkException ..)))

;;; Imports

;; base
(import Control.Exception ((Exception ..) throw))

;; ghc
(import SrcLoc ((GenLocated ..) getLoc))

;; sk-kernel
(import Language.SK)
(import Language.SK.Form (mkLocatedForm))


;;; Exception

(data SkListException
  (NonListValue String))

(instance (Show SkListException)
  (= show e
    (case e
      (NonListValue str) str)))

(instance (Exception SkListException))

(:: error-non-list (-> String Code a))
(= error-non-list fname what
  (throw (NonListValue
          (concat ["SK.Core.List." fname
                   ": non-list value `" (show what) "'"]))))


;;; CXR

(:docn "Get first element of list 'Code'.

The function 'car' returns the first element of 'List' and 'HsList'
constructor, or 'nil' value when the 'List' or 'HsList' were empty.
Throws 'SkListException' when the given argument was non-list value.

Examples:

@
> (car '(a b c))
a
> (car '[a b c])
a
> (car 'foo)
*** Exception: SK.Core.List.car: non-list value \\`foo\\'
@")
(:: car (-> Code Code))
(= car (@ whole (LForm (L l code)))
  (case code
    (List (: x _))   x
    (List [])        (LForm (L l (List [])))
    (HsList (: x _)) x
    (HsList [])      (LForm (L l (List [])))
    _                (error-non-list "car" whole)))
#p(INLINABLE car)

(:docn "Get list without the first element.

The function 'cdr' returns list value without the first element of
'List' or 'HsList' argument. When the argument is a 'HsList', returned
value is converted to a 'List'. Like 'car', throws 'SkListException'
then the argument were non-list value.

Examples:

@
> (cdr '(a b c))
(b c)
> (cdr '[a b c])
(b c)
> (cdr nil)
nil
> (cdr 'foo)
*** Exception: SK.Core.List.cdr: non-list value \\`foo\\'
@")
(:: cdr (-> Code Code))
(= cdr (@ whole (LForm (L l code)))
  (let ((= f xs
          (let ((= l' (getLoc (mkLocatedForm xs))))
            (case xs
              [] (LForm (L l' (List [])))
              _  (LForm (L l' (List xs)))))))
    (case code
      (List (: _ xs))   (f xs)
      (List [])         (LForm (L l (List [])))
      (HsList (: _ xs)) (f xs)
      (HsList [])       (LForm (L l (List [])))
      _                 (error-non-list "cdr" whole))))
#p(INLINABLE cdr)

(eval-when-compile
  (:: ads [String])
  (= ads
    (let ((= f (concatMap (\ x [(: \a x) (: \d x)]))))
      (concat (take 3 (tail (iterate f [[\a] [\d]]))))))

  (:: cxr-name (-> String Code))
  (= cxr-name x
    (qSymbol (concat ["c" x "r"])))

  (:: cxr (-> String [Code]))
  (= cxr xs
    (let ((= name (cxr-name xs)))
      (case xs
        (: hd tl) [`(:: ,name (-> Code Code))
                   `(= ,name
                      (. ,(cxr-name (return hd)) ,(cxr-name tl)))
                   `#p(INLINABLE ,name)]
        _         (throw (SkException (++ "cxr: invalid arg: " xs)))))))

(with-macro ((= cxrs
               (Macro (\ _ (return `(begin
                                      ,@(concatMap cxr ads)))))))
  (cxrs))


;;; Predicates

(:: is-atom (-> Code Bool))
(= is-atom (LForm (L _ form))
  (case form
    (Atom _)  True
    (List []) True
    _         False))

(:: is-pair (-> Code Bool))
(= is-pair (LForm (L _ form))
  (case form
    (List []) False
    (List _)  True
    _         False))

(with-macro ((= defpred
               (Macro (\ form
                        (case (unCode form)
                          (List [_ name pat])
                          (return `(begin
                                     (:: ,name (-> Code Bool))
                                     (= ,name (LForm (L _ form))
                                       (case form
                                         ,pat True
                                         _    False))))
                          _ (skSrcError form "defpred"))))))
  (defpred is-list (List _))
  (defpred is-hslist (HsList _))
  (defpred is-symbol (Atom (ASymbol _)))
  (defpred is-string (Atom (AString _)))
  (defpred is-char (Atom (AChar _)))
  (defpred is-integer (Atom (AInteger _)))
  (defpred is-fractional (Atom (AFractional _)))
  (defpred is-unit (Atom AUnit)))


;;; CONS

(:docn "Extend the second argument with the first argument by appending
to the tip.")
(:: cons (=> (Homoiconic a) (-> a Code Code)))
(= cons x (@ whole (LForm (L _ xs)))
  (let ((= (@ x' (LForm (L l0 _))) (toCode x)))
    (LForm (L l0 (case xs
                   (List xs')   (List (: x' xs'))
                   (HsList xs') (List (: x' xs'))
                   _            (List [x' whole]))))))
#p(INLINABLE cons)

(:docn "Append two lists.")
(:: append (-> Code Code Code))
(= append xs ys
  (| ((not (|| (is-list xs) (is-hslist xs)))
      (error-non-list "append" xs))
     ((not (|| (is-list ys) (is-hslist ys)))
      (error-non-list "append" ys))
     (otherwise
      (let ((:: go (-> Code Code Code))
            (= go as bs
              (if (null as)
                  bs
                  (cons (car as) (go (cdr as) ys)))))
        (go xs ys)))))
#p(INLINABLE append)

(class (ListableType l)
  (:: list_ (-> [Code] l)))

(instance (ListableType Code)
  (= list_ (. qList reverse)))

(instance (=> (Homoiconic elem) (ListableType l)
              (ListableType (-> elem l)))
  (= list_ acc
    (\ x (list_ (: (toCode x) acc)))))

(:docn "Make a list from given arguments.

This function can take variable number of arguments, but requires
explicit specified type signature.")
(:: list (=> (ListableType lst) lst))
(= list (list_ []))



;;; Higher Order Functions

(:docn "Apply given function to immediate elements of 'List' and
'HsList'. When the second argument was 'HsList', the resulting value
converted to 'List'.")
(:: mapcar (-> (-> Code Code) Code Code))
(= mapcar f (@ form (LForm (L l lst)))
  (case lst
    (List xs)   (LForm (L l (List (map f xs))))
    (HsList xs) (LForm (L l (List (map f xs))))
    _           (error-non-list "mapcar" form)))
