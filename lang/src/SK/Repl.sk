;;;; | Simple SK REPL.
;;;;
;;;; This implementation uses two threads: one for reading and printing,
;;;; and another for evaluating and modifying the SkEnv. Using `MVar'
;;;; containing `Code' to communicate between the threads. This design
;;;; shall be easier to support reading forms from other sources than
;;;; line oriented user input, e.g. network sockets.

(require SK.Core)

(defmodule SK.Repl
  (load
   ;; base
   (Prelude)

   ;; sk-kernel
   (Language.SK)

   ;; internal
   (SK.Repl.Macro))
  (use
   ;; base
   (Control.Monad (mplus))
   (System.Exit (exitFailure))
   (System.Console.GetOpt
    ((ArgDescr ..) (ArgOrder ..) (OptDescr ..) getOpt usageInfo))
   (System.Environment (getProgName))

   ;; sk-kernel
   (Language.SK.Expand (specialForms))
   (Language.SK.Make (defaultSkEnv))
   (Language.SK.SKC ((SkEnv ..) (EnvMacros) makeEnvMacros mergeMacros))

   ;; internal
   (SK.Core)
   (SK.Repl.Macro)
   (SK.Repl.Loop))
  (export replMain
          repl-env))


;;; Main

(defn (replMain (-> [String] (IO ())))
  [args]
  (case (getOpt Permute descrs args)
    (, o _ []) (act (foldl (flip id) initial-option o))
    (, _ _ es) (print-errors es)))


;;; Option types

(data ReplMode
  Help Listen Run
  (deriving (Eq Show)))

(data ReplOption
  (ReplOption {repl-mode ReplMode
               repl-listen-port (Maybe Int)}))

(defn (initial-option ReplOption)
  (ReplOption {repl-mode Run
               repl-listen-port (Just 12305)}))

(defn (descrs [OptDescr (-> ReplOption ReplOption)])
  [(Option [\h] ["help"]
           (NoArg (\ o (o {repl-mode Help})))
           "Show this help and exit")
   (Option [\l] ["listen"]
           (OptArg (\ mb-port o
                     (let ((= port
                             (mplus (fmap read mb-port)
                                    (repl-listen-port o))))
                       (o {repl-mode Listen
                           repl-listen-port port})))
                   "PORT")
           "Listen to port (default: 12305)")])

(defn (act (-> ReplOption (IO ())))
  [ro]
  (case (repl-mode ro)
    Help print-usage
    Listen (run (repl-listen-port ro))
    Run (run Nothing)))


;;; Actions

(defn (print-errors (-> [String] (IO ())))
  [errs]
  (do (mapM_ putStr errs)
      (putChar \\n)
      print-usage
      exitFailure))

(defn (print-usage (IO ()))
  (do (<- name getProgName)
      (putStr
       (unlines
        [(concat ["USAGE: " name " repl [OPTIONS]"])
         ""
         "Start interactive REPL."
         ""
         (usageInfo "OPTIONS:\n" descrs)]))))

(defn (run (-> (Maybe Int) (IO ())))
  [listen]
  (start-repl listen repl-env))

(defn (repl-env SkEnv)
  (let ((= modules ["Prelude"])
        (= macros (mergeMacros specialForms replMacros)))
    (defaultSkEnv {envContextModules modules
                   envMacros macros
                   envDefaultMacros macros})))

;;; Default macros imported in REPL. These macros always get imported
;;; after loading compiled modules.
(macrolet ((the-macros ()
             `[,@(map (\ mac `(, ,mac ,(qSymbol mac)))
                      (++ (exported-macros SK.Core)
                          (exported-macros SK.Repl.Macro)))]))
  (defn (replMacros EnvMacros)
    (makeEnvMacros (the-macros))))
