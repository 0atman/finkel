;;;; | Simple SK REPL.
;;;;
;;;; This implementation uses two threads: one for reading and printing,
;;;; and another for evaluating and modifying the SkEnv. Using `MVar'
;;;; containing `Code' to communicate between the threads. This design
;;;; shall be easier to support reading forms from other sources than
;;;; line oriented user input, e.g. network sockets.

(require SK.Core)
(require SK.Repl.Macro)

(defmodule SK.Repl
  (use
   ;; base
   (Control.Monad (mplus))
   (Data.Version (showVersion))
   (System.Environment (getArgs))
   (System.Exit (exitFailure))
   (System.Console.GetOpt)

   ;; ghc
   (Config (cProjectVersion))

   ;; sk-kernel
   (Language.SK.Expand (specialForms))
   (Language.SK.Make (defaultSkEnv))
   (Language.SK.SKC ((SkEnv ..) (EnvMacros) makeEnvMacros mergeMacros))
   (qualified Paths_sk_kernel)

   ;; internal
   (SK.Core)
   (SK.Repl.Macro)
   (SK.Repl.Loop)
   (qualified Paths_sk_lang))
  (export replMain repl-env))


;;; Main

(defn (replMain (IO ()))
  (do (<- args getArgs)
      (case (getOpt Permute descrs args)
        (, o _ []) (act (foldl (flip id) initial-option o))
        (, _ _ es) (print-errors es))))


;;; Option types

(data ReplMode
  Help Version Listen Run
  (deriving (Eq Show)))

(data ReplOption
  (ReplOption {repl-mode ReplMode
               repl-listen-port (Maybe Int)}))

(defn (initial-option ReplOption)
  (ReplOption {repl-mode Run
               repl-listen-port (Just 12305)}))

(defn (descrs [OptDescr (-> ReplOption ReplOption)])
  [(Option [\h] ["help"]
           (NoArg (\ o (o {repl-mode Help})))
           "Show this help and exit.")
   (Option [\V] ["version"]
           (NoArg (\ o (o {repl-mode Version})))
           "Show version information and exit.")
   (Option [\l] ["listen"]
           (OptArg (\ mb-port o
                     (let ((= port
                             (mplus (fmap read mb-port)
                                    (repl-listen-port o))))
                       (o {repl-mode Listen
                           repl-listen-port port})))
                   "PORT")
           "Listen to port (default: 12305)")])

(defn (act (-> ReplOption (IO ())))
  (ro)
  (case (repl-mode ro)
    Help print-usage
    Version print-version
    Listen (run (repl-listen-port ro))
    Run (run Nothing)))


;;; Actions

(defn (print-errors (-> [String] (IO ())))
  (errs)
  (do (mapM_ putStr errs)
      (putChar \\n)
      print-usage
      exitFailure))

(defn (print-usage (IO ()))
  (putStr
   (unlines
    ["USAGE: sk [OPTIONS]"
     ""
     "With no OPTIONS, start interactive REPL."
     ""
     (usageInfo "OPTIONS:" descrs)])))

(defn (print-version (IO ()))
  (putStrLn (++ "sk " sk-lang-version)))

(defn (run (-> (Maybe Int) (IO ())))
  (listen)
  (do (putStrLn (concat ["SK REPL (sk-lang " sk-lang-version
                         ", sk-kernel " sk-kernel-version
                         ", ghc " cProjectVersion ")"]))
      (start-repl listen repl-env)))

(defn (sk-lang-version String)
  (showVersion Paths_sk_lang.version))

(defn (sk-kernel-version String)
  (showVersion Paths_sk_kernel.version))

(defn (repl-env SkEnv)
  (let ((= modules
          ["Prelude" "SK.Prelude" "SK.Repl.Env" "SK.Repl.Macro"])
        (= defaultMacros
          (mergeMacros specialForms replMacros)))
    (defaultSkEnv {envContextModules modules
                   envDefaultMacros defaultMacros
                   envAddInDefineMacro True})))

;;; Default macros imported in REPL. These macros always get imported
;;; after loading compiled modules.
(macrolet* ((the-macros ()
              (return
                `[,@(map (\ mac `(, ,mac ,(aSymbol mac)))
                         (++ (exported-macros SK.Core)
                             (exported-macros SK.Repl.Macro)))])))
  (defn (replMacros EnvMacros)
    (makeEnvMacros (the-macros))))
