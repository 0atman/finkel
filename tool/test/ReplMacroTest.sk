;;;; Tests for REPL macros

(require SK.Core)

(defmodule ReplMacroTest
  (export
   replMacroTests)
  (use
   ;; base
   (Data.List (intercalate isSubsequenceOf))

   ;; filepath
   (System.FilePath (</>))

   ;; directory
   (System.Directory (getCurrentDirectory))

   ;; hspec
   (Test.Hspec)

   ;; sk-kernel
   (Language.SK)

   ;; Internal
   (TestAux)))

(defn (replMacroTests Spec)
  (describe "ReplMacro" replMacroTests'))

(defn (replMacroTests' Spec)
  (do (let ((= delines (intercalate "\n"))
            (= testdata name
              (</> "test" (</> "data" name)))))

      (<- current-dir (runIO getCurrentDirectory))
      (<- (EvalTestFns ok ng satisfy cleanup) (runIO makeEvalTestFns))
      (afterAll_
       cleanup
       (do
         ;; !
         (ok '(repl-macro ! echo foo) "")

         ;; ?, help
         (satisfy
          '(repl-macro help)
          (\ result
            (case result
              (Right str) (isSubsequenceOf ",type EXPR" str)
              _ False)))

         ;; browse
         (ok '(repl-macro browse Unsafe.Coerce)
             "Unsafe.Coerce.unsafeCoerce :: a -> b")

         ;; cd
         (ok `(repl-macro cd ,(testdata "")) "")
         (ok '(repl-macro cd ../../) "")

         ;; debug
         (ok '(repl-macro debug) "Debug flag is False")
         (ok '(repl-macro debug True) "Debug flag set to True")
         (ok '(repl-macro debug False) "Debug flag set to False")

         ;; info
         (ok '(repl-macro info putStr)
             "putStr :: String -> IO () \t-- Defined in ‘System.IO’")

         ;; kind
         (ok '(repl-macro kind Maybe)
             "Maybe :: * -> *")

         ;; pwd
         (ok '(repl-macro pwd) (show current-dir))

         ;; show
         (ok '(defn (f1 (-> Int Int)) [n] (+ n 1))
             "; f1 :: Int -> Int")
         (satisfy
          '(repl-macro show bindings)
          (\ ret
            (case ret
              (Right str) (elem "f1 :: Int -> Int = _" (lines str))
              _ False)))
         (ok '(repl-macro show context)
             (delines
              ["; context"
               ";  IIDecl: import Prelude"]))
         (ok '(repl-macro show dflags)
             (delines
              ["; dflags:"
               ";  ghcLink: LinkInMemory"
               ";  ghcMode: CompManager"
               ";  hscTarget: HscInterpreted"
               ";  objectDir: Nothing"
               ";  thisInstalledUnitId: main"
               ";  forceRecomp: False"]))
         (ok '(begin
               (repl-macro set -odir /tmp)
               (repl-macro show dflags))
             (delines
              ["; dflags:"
               ";  ghcLink: LinkInMemory"
               ";  ghcMode: CompManager"
               ";  hscTarget: HscInterpreted"
               ";  objectDir: Just \"/tmp\""
               ";  thisInstalledUnitId: main"
               ";  forceRecomp: False"]))
         (ok '(repl-macro show hpt)
             "show: no home package table found")
         (ok '(repl-macro show language)
             (delines
              ["base language is: Haskell2010"
               "with the following modifiers:"
               "  -XNoDatatypeContexts"
               "  -XNondecreasingIndentation"]))
         ;; show linker command uses 'showLinkerState' from ghc package,
         ;; which does printing action, so not returning 'String' value.
         (ok '(repl-macro show linker) "")
         (satisfy
          '(repl-macro show macros)
          (\ ret
            (case ret
              (Right str) (elem ";  defmacro_m'" (lines str))
              _ False)))
         (ok '(repl-macro show modules) "")
         (satisfy
          '(repl-macro show options)
          (\ ret
            (case ret
              (Right str) (isSubsequenceOf
                           "-fimplicit-import-qualified"
                           str)
              _ False)))
         (satisfy
          '(repl-macro show packages)
          (\ ret
            (case ret
              (Right str) (isSubsequenceOf "; packages" str)
              _ False)))
         (ok '(repl-macro show paths)
             (concat
              ["; current working directory:\n"
               ";   " current-dir "\n"
               "; module import search paths:\n"
               ";    ."]))
         (ok '(repl-macro show targets)
             ";; targets: none")

         ;; type
         (ok '(repl-macro type putStrLn)
             "putStrLn :: String -> IO ()")
         (ok '(repl-macro type (foldr + (:: 0 Int)))
             "(foldr + (:: 0 Int)) :: Foldable t => t Int -> Int")

         ;; load and reload
         (let ((= m01-dot-sk (testdata "m01.sk"))
               (= dir01-m01 (testdata (</> "Dir01" "M01.sk")))))
         (ok `(begin
                (repl-macro load ,(qSymbol m01-dot-sk))
                main)
             "=== m01.sk ===")
         (ok '(repl-macro reload)
             "; reloaded test/data/m01.sk")
         (ok '(repl-macro browse)
             (delines
              ["main :: IO ()"
               "foo :: String"
               "bar :: Int -> Int"]))

         ;; Errors
         (ng '(repl-macro info (foo bar))
             "<quoted code>: error: info: invalid form `(foo bar)'")))))
