;;; Tests for REPL.

#p(language OverloadedStrings)

(require SK.Core)

(defmodule ReplTest
  (export replTests)
  (use
   ;; base
   (Control.Concurrent
    (forkIO newEmptyMVar killThread putMVar takeMVar threadDelay))
   (Control.Exception (bracket))
   (Control.Monad (void))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.List (intercalate isSubsequenceOf))

   ;; directory
   (System.Directory (getCurrentDirectory))

   ;; haskeline
   (System.Console.Haskeline (defaultSettings runInputT))

   ;; hspec
   (Test.Hspec)

   ;; network
   (Network.Socket
    ((AddrInfo ..) (SocketType ..)
     connect defaultHints close getAddrInfo socket))
   (Network.Socket.ByteString (sendAll recv))

   ;; sk-kernel
   (Language.SK)
   (Language.SK.SKC (runSkc))

   ;; Internal
   (SK.Tool.Repl)
   (SK.Tool.Repl.Eval)
   (SK.Tool.Repl.Loop)
   (SK.Tool.Repl.IO)
   (SK.Tool.Repl.Types)
   (TestIO)))


(defn (replTests Spec)
  (do (describe "ReplState" replStateTests)
      (describe "Read" readTests)
      (describe "ReadPrint" readPrintTests)
      (describe "Eval" evalTests)
      (describe "Listen" listenTests)))

(defn (replStateTests Spec)
  (do (let ((= d describe)
            (= rs1 (ReplState {pending-input ["(foo"]}))
            (= rs2 (ReplState {pending-input [" bar)"]}))))
      (d "Show instance"
         (it "should show pending inputs"
             (shouldBe "ReplState {pending_input = [\"(foo\"]}"
                       (show rs1))))
      (d "Eq instance"
         (do (it "should equal to itself" (shouldBe rs1 rs1))
             (it "should not equal with different pending input"
                 (shouldNotBe rs1 rs2))))
      (d "Monoid laws for ReplState"
         (do (it "should have an identity element"
                 (shouldBe rs1 (<> mempty rs1)))
             (it "should satisfy associativity law"
                 (shouldBe (<> rs1 (<> mempty rs2))
                           (<> (<> rs1 mempty) rs2)))))
      (d "get and put ReplState for InputT"
         (do (let ((= act
                     (run-repl (runInputT defaultSettings work)
                               mempty))
                   (= work
                     (do (putReplState mempty)
                         getReplState))))
             (it "should return the given ReplState"
                 (shouldReturn act mempty))))
      (let ((= run-repl' (flip run-repl mempty))
            (= repl1 (pure True))))
      (d "Functor instance of Repl"
         (do (it "should satisfy identity law"
                 (shouldReturn (run-repl' (fmap id repl1)) True))
             (it "should satisfy composition law"
                 (shouldReturn
                  (run-repl' (fmap show (fmap not repl1)))
                  (show (not True))))
             (it "should return second arg with <$"
                 (shouldReturn
                  (run-repl' (<$ True (pure False)))
                  True))))
      (d "Applicative instance of Repl"
         (it "should satisfy applicative law"
             (shouldReturn
              (run-repl' (<*> (pure not) repl1))
              False)))))

(defn (readTests Spec)
  (do (let ((= d describe)))
      (d "reading single line form"
         (it "returns '(foo bar buzz)"
             (do (<- form (run-repl (read-form "(foo bar buzz)")
                                    initial-repl-state))
                 (shouldBe (Just '(foo bar buzz)) form))))
      (d "reading multi line form"
         (it "returns '(a b c)"
             (do (<- form (run-repl (do (<- _ (read-form "(a "))
                                        (<- _ (read-form "b "))
                                        (read-form "c)"))
                                    initial-repl-state))
                 (shouldBe (Just '(a b c)) form))))))

(defn (readPrintTests Spec)
  (describe
   "read and print loop"
   (do (rptest "multi line form" ["(print" "(+" "10" "32" "))"])
       (rptest "quitting with \"(quit)\"" ["(quit)"])
       (rptest "\",t\" command" [",t False"])
       (rptest "\",!\" command" [",! echo foo bar"])
       (rptest "\",q\" command" [",q"]))))

(defn (rptest (-> String [String] Spec))
  [label inputs]
  (describe
   label
   (do (let ((= run
               (do (<- (@ resources (, _ hdl in-mv)) acquire-repl)
                   (<- eval-tid
                     (forkIO (runSkc (eval-loop hdl in-mv) repl-env)))
                   (let ((= act
                           (runTestIO (read-print-loop in-mv eval-tid)
                                      inputs))))
                   (return (, resources act))))))
       (<- (, resources act) (runIO run))
       (after_ (cleanup-repl resources)
               (it "should evaluate successfully"
                   (do (<- tst (fmap snd (liftIO act)))
                       (shouldSatisfy (pending-input (tst-replstate tst))
                                      null)))))))

(defn (evalTests Spec)
  (do (let ((= d describe)
            (= delines (intercalate "\n"))))
      (<- out-mv (runIO newEmptyMVar))
      (<- (, tmpfile hdl in-mv) (runIO acquire-repl))
      (<- current-dir (runIO getCurrentDirectory))
      (<- etid
        (runIO (forkIO (runSkc (eval-loop hdl in-mv) repl-env))))
      (let ((= eval-form right-or-left form expect
              (d (concat ["evaluate " (show form)])
                 (it "evaluates to expected result"
                     (do (putMVar in-mv (Input Connection form out-mv))
                         (<- ret (takeMVar out-mv))
                         (shouldBe ret (right-or-left expect))))))
            (= ok (eval-form Right))
            (= ng (eval-form Left))
            (= satisfy form test
              (d (concat ["evaluate " (show form)])
                 (it "satisfies predicate"
                     (do (putMVar in-mv (Input Connection form out-mv))
                         (<- ret (takeMVar out-mv))
                         (shouldSatisfy ret test)))))))
      (beforeAll_
       (do (putMVar in-mv (Input Connection init-form out-mv))
           (void (takeMVar out-mv)))
       (afterAll_
        (do (killThread etid)
            (cleanup-repl (, tmpfile hdl ())))
        (do
          ;; Statements and declarations
          (ok '(+ 10 32) "42")
          (ok '(defn (f1 (-> Int Int))
                [n]
                (+ n 1))
              "; f1 :: Int -> Int")
          (ok '(f1 41) "42")
          (ok '(begin
                (:: (x y) Int)
                (= x 1)
                (= y 2))
              "; x :: Int\n; y :: Int")
          (ok '(<- z (return True))
              "; z :: Bool")
          (ok '(defn (f2 (-> (Maybe Int) Int))
                [(Just n)] (* n 2)
                [Nothing]  0)
              "; f2 :: Maybe Int -> Int")
          (ok '(f2 (Just 21)) "42")
          (ok '(data Foo (Foo Int))
              (concat ["; $tcFoo :: TyCon\n"
                       "; $tc'Foo :: TyCon\n"
                       "; Type constructor ‘Foo’"]))
          (ok '(import Control.Monad)
              "; import Control.Monad")

          ;; REPL macros
          (ok '(exported-macros Prelude) "[]")
          (ok '(repl-macro browse Unsafe.Coerce)
              "Unsafe.Coerce.unsafeCoerce :: a -> b")
          (ok '(repl-macro info putStr)
              "putStr :: String -> IO () \t-- Defined in ‘System.IO’")
          (ok '(repl-macro kind Maybe)
              "Maybe :: * -> *")
          (ok '(repl-macro pwd) (show current-dir))
          (satisfy
           '(repl-macro show bindings)
           (\ ret
             (case ret
               (Right str) (elem "f1 :: Int -> Int = _" (lines str))
               _ False)))
          (ok '(repl-macro show context)
              (delines
               ["; context"
                ";  IIDecl: import Control.Monad"
                ";  IIDecl: import Prelude"]))
          (ok '(repl-macro show dflags)
              (delines
               ["; dflags:"
                ";  ghcLink: LinkInMemory"
                ";  ghcMode: CompManager"
                ";  hscTarget: HscInterpreted"
                ";  objectDir: Nothing"
                ";  thisInstalledUnitId: main"
                ";  forceRecomp: False"]))
          (ok '(begin
                (repl-macro set -odir /tmp)
                (repl-macro show dflags))
              (delines
               ["; dflags:"
                ";  ghcLink: LinkInMemory"
                ";  ghcMode: CompManager"
                ";  hscTarget: HscInterpreted"
                ";  objectDir: Just \"/tmp\""
                ";  thisInstalledUnitId: main"
                ";  forceRecomp: False"]))
          (satisfy
           '(repl-macro show macros)
           (\ ret
             (case ret
               (Right str) (elem ";  defmacro_m'" (lines str))
               _ False)))
          (ok '(repl-macro show modules) "")
          (satisfy '(repl-macro show packages)
                   (\ ret
                     (case ret
                       (Right str) (isSubsequenceOf "; packages" str)
                       _ False)))
          (ok '(repl-macro show paths)
              (concat
               ["; current working directory:\n"
                ";   " current-dir "\n"
                "; module import search paths:\n"
                ";    ."]))
          (ok '(repl-macro type putStrLn)
              "putStrLn :: String -> IO ()")
          (ok '(repl-macro type (foldr + (:: 0 Int)))
              "(foldr + (:: 0 Int)) :: Foldable t => t Int -> Int")

          ;; Errors
          (ng 'buzz
              (concat ["<interactive>:1:1: error: "
                       "Variable not in scope: buzz"]))
          (ng '(= f a (+ a 1) (+ a 2))
              (concat ["<quoted code>: error:\n    syntax error on input "
                       "`(= f a (+ a 1) (+ a 2))'"]))
          (ng '(head []) "*** Exception: Prelude.head: empty list")
          (ng '(repl-macro info (foo bar))
              "<quoted code>: error: info: invalid form `(foo bar)'"))))))

(defn (listenTests Spec)
  (let ((= act
          (do (<- tid (forkIO (replMain ["--listen=50322"])))
              ;; Pause for a bit after forking server action.
              (threadDelay 500000)
              (<- addr (resolve "127.0.0.1" "50322"))
              (bracket (open-sock addr) (cleanup tid) send-forms)))
        (= resolve host port
          (do (let ((= hints
                      (defaultHints {addrSocketType Stream}))))
              (<- addrs
                (getAddrInfo (Just hints) (Just host) (Just port)))
              (case addrs
                (: addr _) (return addr)
                _ (error "REPL client: address error"))))
        (= cleanup tid sock
          (do (killThread tid)
              (close sock)))
        (= open-sock addr
          (do (<- sock (socket (addrFamily addr)
                               (addrSocketType addr)
                               (addrProtocol addr)))
              (connect sock (addrAddress addr))
              (return sock)))
        (= send-forms sock
          (do (<- _msg1 (recv sock 1024))
              (sendAll sock "(* 7 (+ 4 2))")
              (<- msg2 (recv sock 1024))
              (return msg2))))
    (describe "listener"
              (it "should evaluate form sent from connected client"
                  (shouldReturn (liftIO act) "42")))))
