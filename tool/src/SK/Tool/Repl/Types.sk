#p(LANGUAGE FlexibleInstances
            GeneralizedNewtypeDeriving)

;;;; Types for REPL.

(require SK.Core)

(defmodule SK.Tool.Repl.Types
  (export
   ;; repl
   (Repl ..) run-repl put-repl-state get-repl-state

   ;; repl state
   (ReplState ..) (HasReplState ..) initial-repl-state

   ;; input and result
   (Input ..) (InSource ..) (Result)

   ;; re-export
   (MonadTrans ..))
  (load
   ;; base
   (Prelude)

   ;; sk-lang
   (SK.Prelude)

   ;; Internal
   (SK.Tool.Compat))
  (use
   ;; base
   (Control.Concurrent ((MVar)))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.Function (on))
   (Data.IORef ((IORef) atomicWriteIORef newIORef readIORef))

   ;; bytestring
   (qualified Data.ByteString.Lazy.Char8 as BS)

   ;; haskeline
   (System.Console.Haskeline.MonadException
    ((MonadException ..) (RunIO ..)))

   ;; transformers
   (Control.Monad.Trans.Class ((MonadTrans ..)))

   ;; sk-kernel
   (Language.SK ((Code)))))

;;; REPL, REPL state, input, and result types

;;; Repl state type to hold intermediate line-wise inputs.
(data ReplState
  (ReplState {pending-input [BS.ByteString]})
  (deriving (Eq Show)))

(instance (Monoid ReplState)
  (= mempty initial-repl-state)
  (= mappend r1 r2
    (ReplState {pending-input (on mappend pending-input r1 r2)})))

(with-ghc-version-cond ver
  ((<= 804 ver)
   (instance (Semigroup ReplState)
     (= <> mappend)))
  (otherwise
   (begin)))

(defn (initial-repl-state ReplState)
  (ReplState {pending-input []}))

;;; Newtype wrapper for REPL prompt.
(newtype (Repl a)
  (Repl {unRepl (-> (IORef ReplState) (IO a))}))

(instance (Functor Repl)
  (= fmap f (Repl repl)
    (Repl (. (fmap f) repl)))
  #p(INLINE fmap))

(instance (Applicative Repl)
  (= pure x (Repl (\ _ (pure x))))
  #p(INLINE pure)

  (= <*> (Repl mf) (Repl mx)
    (Repl (\ ref (<*> (mf ref) (mx ref)))))
  #p(INLINE <*>))

(instance (Monad Repl)
  (= >>= (Repl repl) k
    (Repl (\ ref (>>= (repl ref) (. (flip unRepl ref) k)))))
  #p(INLINE >>=))

(instance (MonadIO Repl)
  (= liftIO io (Repl (\ _ io)))
  #p(INLINE liftIO))

(instance (MonadException Repl)
  (= controlIO f
    (Repl (\ ref
            (controlIO
             (\ (RunIO run)
               (let ((= run'
                       (RunIO (. (fmap (. Repl const))
                                 (. run (flip unRepl ref))))))
                 (fmap (flip unRepl ref) (f run'))))))))
  #p(INLINE controlIO))

(defn (run-repl (-> (Repl a) ReplState (IO a)))
  [(Repl repl) st]
  (>>= (newIORef st) repl))

(defn (get-repl-state (Repl ReplState))
  (Repl readIORef))

(defn (put-repl-state (-> ReplState (Repl ())))
  [st]
  (Repl (flip atomicWriteIORef st)))

;;; Type class for getting and putting 'ReplState'.
(class (HasReplState r)
  (:: getReplState (r ReplState))
  (:: putReplState (-> ReplState (r ()))))

(instance (HasReplState Repl)
  (= getReplState get-repl-state)
  #p(INLINE getReplState)
  (= putReplState put-repl-state)
  #p(INLINE putReplState))

(instance (=> (MonadTrans t) (Monad m) (HasReplState m)
              (HasReplState (t m)))
  (= getReplState (lift getReplState))
  #p(INLINE getReplState)
  (= putReplState (. lift putReplState))
  #p(INLINE putReplState))

;;; Input data type to hold form to evaluate, and MVar to receive
;;; result from evaluation thread.
(data Input
  (Input InSource Code (MVar Result)))

;;; Type for input, to distinguish prompt from network connections to
;;; REPL server.
(data InSource
  Prompt
  Connection)

;;; Synonym for evaluation result.
(type Result
  (Either String String))
