;;; Main entry point

(require SK.Core)

(defmodule SK.Tool.Main
  (export
   main
   commands)
  (load
   ;; sk-lang
   (SK.Prelude))
  (use
   ;; base
   (System.Environment (getArgs getProgName withArgs withProgName))

   ;; sk-kernel
   (Language.SK.Main (defaultMainWith))

   ;; sk-lang
   (SK.Prelude)

   ;; Internal
   (SK.Tool.Help)
   (SK.Tool.Repl)
   (SK.Tool.Version)))


;;; Exported function

(defn (main (IO ()))
  "Main entry point function for @sk@ executable."
  (do (<- args getArgs)
      (case args
        (: name rest) (maybe (show-usage commands)
                             (flip cmd-act rest)
                             (find-command commands name))
        _ (show-usage commands))))

(defn (commands [Command])
  "Available commands in sk executable."
  [(Command "help" "show help information" (helpMain commands))
   (Command "make" "compile source codes" makeMain)
   (Command "repl" "start interactive REPL" replMain)
   (Command "version" "show version" versionMain)])


;;; Internal

(defn (makeMain (-> [String] (IO ())))
  "Main function for compiler with macros from `SK.Prelude'."
  [args]
  (macrolet ((preloaded ()
               `[,@(map (\ mac (, mac (qSymbol mac)))
                        (exported-macros SK.Prelude))]))
    (do (<- name getProgName)
        (let ((= name' (++ name " make"))))
        (withArgs args (withProgName name'
                                     (defaultMainWith (preloaded)))))))
