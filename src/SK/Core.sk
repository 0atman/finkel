;;;; Fundamental macros and functions.

(module SK.Core)

(require Language.SK.GHC (unpackFS))

(import Language.SK)
(import Language.SK.GHC (unpackFS))


;;; Macro to specify the phases of evaluation.
(define-macro eval-when form
  (let ((:: compile? (-> [Code] Bool))
        (= compile? (elem 'compile))
        (:: load? (-> [Code] Bool))
        (= load? (elem 'load)))
    (case (unLocLForm form)
      (List (: _ (: (LForm (L _ (List phases))) body)))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@(List body))
               ,@(List body))))
         ((compile? phases)
          (return `(eval-when-compile ,@(List body))))
         ((load? phases)
          (return `(begin ,@(List body))))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

(eval-when (compile load)
  (:: subst-gensyms (-> [(, Atom Atom)] Code Code))
  (= subst-gensyms kvs
    (fmap (\ x (case (lookup x kvs)
                 (Just y) y
                 Nothing  x))))

  (:: gensym-name? (-> Atom Bool))
  (= gensym-name? x
    (case x
      (ASymbol sym) (| ((<- (: \$ (: c _)) (unpackFS sym))
                        (elem c [\a .. \z])))
      _             False))

  (:: collect-names (-> Code [Atom]))
  (= collect-names form
    (let ((:: f (-> Atom [Atom] [Atom]))
          (= f x acc
            (if (&& (gensym-name? x) (notElem x acc))
                (: x acc)
                acc)))
      (foldr f [] form)))

  (:: gensymfy (-> Code (Skc Code)))
  (= gensymfy (@ form (LForm (L l0 _)))
    (do (let ((:: to-replace [Atom])
              (= to-replace (collect-names form))
              (:: make-replacement (-> Atom (Skc (, Atom Atom))))
              (= make-replacement (@ x (ASymbol sym))
                (do (<- (LForm (L _ (Atom g)))
                        (gensym' (tail (unpackFS sym))))
                    (return (, x g))))))
        (<- kvs (mapM make-replacement to-replace))
        (case (subst-gensyms kvs form)
          (LForm (L _ ret)) (return (LForm (L l0 ret))))))

  ;; Function to make body expression of `defmacro*' and `defmacro'.
  (:: make-defmacro-body (-> String Code Code Code Code (Skc Code)))
  (= make-defmacro-body label whole name0 arg0 body0
    (let ((:: err (-> Code Code Code))
          ;; (= err undefined)
          (= err form-name name
            `(skSrcError ,form-name
                         (concat
                          [(show ',name)
                           "\ninvalid args: `" (show *form*) "'"])))

          (:: atom-body (-> Code Code Code Code Code))
          (= atom-body name arg body form-name
            (if (null arg)
                body
                `(case (unLocLForm ,form-name)
                   (List (: _ ,arg)) ,body
                   _                 ,(err form-name name))))

          (:: list-body (-> SrcSpan Code [Code] Code Code Code))
          (= list-body l1 name args body form-name
            (let ((:: abind Code)
                  (= abind
                    `(LForm
                      (L _loc
                         (List [_ ,@(LForm (L l1 (List args)))])))))
              `(case ,form-name
                 ,abind  ,body
                 _       ,(err form-name name)))))
      (case (unLForm arg0)
        (L l1 (List args))
        (gensymfy (list-body l1 name0 args body0 '*form*))

        (L _l1 (Atom _))
        (gensymfy (atom-body name0 arg0 body0 '*form*))

        _
        (skSrcError whole (++ label ": invalid args")))))

  ;; Function to make body expression of `macrolet*' and `macrolet'.
  (:: make-macrolet-body (-> String Code (-> Code Code) (Skc Code)))
  (= make-macrolet-body label whole f
    (let ((:: g (-> Code (Skc Code)))
          (= g code
            (case (unLocLForm code)
              (List [name arg body0])
              (do (<- body1 (make-defmacro-body label code name
                                                arg (f body0)))
                  (return `(,name *form* ,body1)))
              _ (skSrcError whole label))))
      (case (unLocLForm whole)
        (List (: _ (: (LForm (L _ (List forms))) rest)))
        (do (<- macros (mapM g forms))
            (return `(let-macro ,(List macros)
                       ,@(List rest))))
        _
        (skSrcError whole
                    (concat
                     [label ": invalid form: " (show whole)]))))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (case (unLocLForm form)
    (List [_ name arg body0])
    (do (<- body1 (make-defmacro-body "defmacro*" form name arg body0))
        (return
          `(define-macro ,name *form*
             ,body1)))

    _
    (skSrcError form "defmacro*: invalid form")))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return `(defmacro* ,name ,args
             (return ,body0))))

;;; Variant of `let-macro', with `make-macro-body'.
(define-macro macrolet* form
  (make-macrolet-body "macrolet*" form id))

;;; Variant of `let-macro', with `make-macro-body', and body expression
;;; wrapped with `return'.
(define-macro macrolet form
  (make-macrolet-body "macrolet" form (\ body `(return ,body))))

;;; Macro for defining function. This macro preserves the location of
;;; function name, arguments, and body. Supports function declaration
;;; with and without type signature,
(define-macro defn form
  (case (unLocLForm form)
    (List [_ sig args body])
    (case (unLocLForm sig)
      (List [name tsig])
      (return `(begin (:: ,name ,tsig)
                      (= ,name ,@args ,body)))

      (Atom _)
      (return `(= ,sig ,@args ,body))
      _
      (skSrcError sig
                  (concat
                   ["defn: invalid signature: `" (show sig) "'"])))
    _
    (skSrcError form (++ "defn: invalid form:\n" (show form)))))

;;; Macro to define function for both of compilation time and load time.
(defmacro defn+ form
  `(eval-when (compile load)
     (defn ,@form)))

;;; Expand given form if the given form is a macro form, otherwise
;;; return the given form as is. Note that `macroexpand-1' and
;;; `macroexpand' are macro, not function.
(defmacro* macroexpand-1 (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand1 x))
                         (return `',expanded))))
    _            (return form)))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (let ((= go expr
                             (do (<- expr' (expand1 expr))
                                 (if (== expr expr')
                                     (return `',expr)
                                     (go expr')))))
                       (go x))))
    _            (return form)))

;;; The `cond' macro, found in many Lisp languages.  The behaviour is
;;; same as wrapping the body with `case' expression with dummy unit, or
;;; `if' with `MultiWayIf' GHC language extension.
(defmacro cond body
  `(case ()
     _ (| ,@body)))

(defn+ (cons (=> (Homoiconic a) (-> a Code Code)))
  (x (LForm (L _l0 xs)))
  (let ((= x' (toCode x))
        (= l1 (getLoc (unLForm x'))))
    (LForm (L l1 (case xs
                   (List xs') (List (: x' xs'))
                   _          (List [x']))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((:: codes (-> [Code] [Code]))
        (= codes
          (map (\ arg (cons 'toCode (cons arg '())))))
        (:: body (-> [Code] Code))
        (= body args
          `(foldr cons '() [,@(List (codes args))])))
    (case (unLocLForm form)
      (List (: _ args)) (return (body args))
      _                 (skSrcError form "list: invalid args"))))

(defn (car (-> Code Code))
  ((LForm (L l code)))
  (case code
    (List (: x _xs)) x
    _                (LForm (L l (List [])))))

(defn (cdr (-> Code Code))
  ((LForm (L l code)))
  (case code
    (List (: _ xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                      (case xs
                        [] (LForm (L l' (List [])))
                        _  (LForm (L l' (List xs)))))
    _               (LForm (L l (List [])))))

;;; 'True' when given 'Code' is a 'List'.
(defn (list? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (List _) True
    _        False))

;;; 'True' when given 'Code' is an 'Atom'.
(defn (atom? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (Atom _) True
    _        False))

;;; 'True' when given 'Code' is an atom of 'ASymbol'.
(defn (symbol? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (Atom (ASymbol _)) True
    _                  False))

;;; 'True' when given 'Code' is an atom of 'AString'.
(defn (string? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (Atom (AString _)) True
    _                  False))

;;; Apply given function to immediate elements of `List' and `HsList'.
(defn (mapcar (-> (-> Code Code) Code Code))
  (f (@ form (LForm (L l lst))))
  (case lst
    (List xs)   (LForm (L l (List (map f xs))))
    (HsList xs) (LForm (L l (HsList (map f xs))))
    _           (error (++ "mapcar: not a list " (show form)))))

;;; Append two lists.
(defn (append (-> Code Code Code))
  (xs ys)
  (if (null xs)
      ys
      (cons (car xs) (append (cdr xs) ys))))
