;;;; Fundamental macros and functions.

(module SK.Core)

(require Language.SK.Expand)

(import Language.SK)
(import Language.SK.Expand)


;;; Macro to specify the phases of evaluation.
(define-macro eval-when form
  (let ((= compile? (elem 'compile))
        (= load? (elem 'load)))
    (case (unLocLForm form)
      (List (: _ (: (LForm (L _ (List phases))) body)))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@body)
               ,@body)))
         ((compile? phases)
          (return `(eval-when-compile ,@body)))
         ((load? phases)
          (return `(begin ,@body)))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

;;; Functions used for defining macros in this file.
(eval-when (compile load)
  (:: cons (=> (Homoiconic a) (-> a Code Code)))
  (= cons x (LForm (L l0 xs))
    (let ((= x' (toCode x))
          (= l1 (getLoc (unLForm x'))))
      (LForm (L l1 (case xs
                     (List xs') (List (: x' xs'))
                     _          (List [x'])))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((= codes (map (\ arg (cons 'toCode (cons arg '())))))
        (= body args `(foldr cons '() [,@(codes args)])))
    (case (unLocLForm form)
      (List (: _ args)) (return (body args))
      _                 (skSrcError form "list: invalid args"))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (let ((= make-body name arg body
          (case (unLForm arg)
            (L l1 (List arg')) (list-arg l1 name arg' body)
            (L l1 (Atom arg')) (atom-arg name arg body)
            _                  (merr "defmacro*: invalid args")))
        (= atom-arg name arg body
          (let ((= arg'
                  (| ((== arg '()) '_unused)
                     (otherwise    arg))))
            (return
              `(define-macro ,name *form*
                 ,(if (== arg '())
                      body
                      `(case *form*
                         (LForm (L _ (List (: _ ,arg)))) ,body))))))
        (= list-arg l1 name arg body
          (let ((= hlist xs
                  (LForm (L l1 (HsList xs))))
                (= err
                  `(skSrcError *form*
                               (concat
                                [(show ',name) [\lf]
                                 "invalid args: `"
                                 (show *form*) "'"])))
                (= abind
                  (list 'LForm
                        (list 'L '_loc
                              (list 'List (hlist (: '_ arg))))))
                (= body2
                  (list 'define-macro name '*form*
                        (list 'case '*form*
                              abind body
                              '_ err))))
            (return body2)))
        (= merr label
          (skSrcError form label)))
    (case (unLocLForm form)
      (List [_ name arg body]) (make-body name arg body)
      _                        (merr "defmacro*: invalid form"))))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return `(defmacro* ,name ,args
             (return ,body0))))

;;; Macro for defining simple function. This macro preserves the
;;; location of function name, arguments, and body.
(define-macro defn form
  (case (unLocLForm form)
    (List [_ sig args body])
    (return (case (unLocLForm sig)
              ;; Declaration with type signature.
              (List [name tsig]) `(begin
                                    (:: ,name ,tsig)
                                    (= ,name ,@args
                                      ,body))
              ;; Declaration without type signature.
              (Atom _)           `(= ,sig ,@args
                                    ,body)))
    _
    (skSrcError form
                (++ "`defn': invalid form:\n"
                    (show form)))))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand x))
                         (return `',expanded))))
    _            (skSrcError form (++ "macroexpand: invalid form\n"
                                      (show form)))))

;;; The `cond' macro, found in many Lisp languages.  The behaviour is
;;; same as wrapping the body with `case' expression with dummy unit, or
;;; `if' with `MultiWayIf' GHC language extension.
(defmacro cond body
  `(case ()
     _ (| ,@body)))

(defn (car (-> Code Code))
    ((LForm (L l code)))
  (case code
    (List (: x _xs)) x
    _                (LForm (L l (List [])))))

(defn (cdr (-> Code Code))
    ((LForm (L l code)))
  (case code
    (List (: x xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                      (case xs
                        []      (LForm (L l' (List [])))
                        (: y _) (LForm (L l' (List xs)))))
    _               (LForm (L l (List [])))))

;;; 'True' when given 'Code' is a 'List'.
(defn (list? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (List _) True
    _        False))

;;; 'True' when given 'Code' is an 'Atom'.
(defn (atom? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (Atom _) True
    _        False))

;;; 'True' when given 'Code' is an atom of 'Symbol'.
(defn (symbol? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (Atom (ASymbol _)) True
    _                  False))

(defn (mapcar (-> (-> Code Code) Code Code))
    (f (@ form (LForm (L l lst))))
  (case lst
    (List xs)   (LForm (L l (List (map f xs))))
    (HsList xs) (LForm (L l (HsList (map f xs))))
    _           (error (++ "mapcar: not a list " (show form)))))
