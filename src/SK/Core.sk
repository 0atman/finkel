;;;; Fundamental macros and functions.

(module SK.Core)

(import Language.SK)


;;; Macro to specify the phases of evaluation.
(define-macro eval-when form
  (let ((= compile? (elem 'compile))
        (= load? (elem 'load)))
    (case (unLocLForm form)
      (List (: _ (: (LForm (L _ (List phases))) body)))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@body)
               ,@body)))
         ((compile? phases)
          (return `(eval-when-compile ,@body)))
         ((load? phases)
          (return `(begin ,@body)))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

(eval-when (compile load)
  ;; Function to make body expression of `defmacro*' and `defmacro'.
  (:: make-defmacro-body (-> String Code Code Code Code (Skc Code)))
  (= make-defmacro-body label whole name0 arg0 body0
    (let ((= err form-name name
            `(skSrcError ,form-name
                         (concat
                          [(show ',name)
                           "\ninvalid args: `" (show *form*) "'"])))
          (= atom-body name arg body form-name
            (if (== arg '())
                body
                `(case (unLocLForm ,form-name)
                   (List (: _ ,arg)) ,body
                   _                 ,(err form-name name))))
          (:: list-body (-> SrcSpan Code [Code] Code Code Code))
          (= list-body l1 name args body form-name
            (let ((= abind
                    `(LForm
                      (L _loc
                         (List [_ ,@(LForm (L l1 (List args)))])))))
              `(case ,form-name
                 ,abind  ,body
                 _       ,(err form-name name)))))
      (case (unLForm arg0)
        (L l1 (List args)) (return
                             (list-body l1 name0 args body0 '*form*))
        (L _l1 (Atom _))   (return
                             (atom-body name0 arg0 body0 '*form*))
        _                  (skSrcError whole
                                       (++ label ": invalid args")))))

  ;; Function to make body expression of `macrolet*' and `macrolet'.
  (:: make-macrolet-body (-> String Code (-> Code Code) (Skc Code)))
  (= make-macrolet-body label whole f
    (let ((:: g (-> Code (Skc Code)))
          (= g code
            (case (unLocLForm code)
              (List [name arg body])
              (do (<- body2 (make-defmacro-body label code name
                                                arg (f body)))
                  (return `(,name *form* ,body2)))
              _ (skSrcError whole label))))
      (case (unLocLForm whole)
        (List (: _ (: (LForm (L _ (List forms))) rest)))
        (do (<- macros (mapM g forms))
            (return `(let-macro ,(List macros)
                       ,@(List rest))))
        _
        (skSrcError whole
                    (concat
                     [label ": invalid form: " (show whole)]))))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (case (unLocLForm form)
    (List [_ name arg body])
    (do (<- body2 (make-defmacro-body "defmacro*" form name arg body))
        (return
          `(define-macro ,name *form*
             ,body2)))

    _
    (skSrcError form "defmacro*: invalid form")))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return `(defmacro* ,name ,args
             (return ,body0))))

;;; Variant of `let-macro', with `make-macro-body'.
(define-macro macrolet* form
  (make-macrolet-body "macrolet*" form id))

;;; Variant of `let-macro', with `make-macro-body', and body expression
;;; wrapped with `return'.
(define-macro macrolet form
  (make-macrolet-body "macrolet" form (\ body `(return ,body))))

;;; Macro for defining function. This macro preserves the location of
;;; function name, arguments, and body. Supports function declaration
;;; with and without type signature,
(define-macro defn form
  (case (unLocLForm form)
    (List [_ sig args body])
    (case (unLocLForm sig)
      (List [name tsig])
      (return `(begin (:: ,name ,tsig)
                      (= ,name ,@args ,body)))

      (Atom _)
      (return `(= ,sig ,@args ,body))
      _
      (skSrcError sig
                  (concat
                   ["defn: invalid signature: `" (show sig) "'"])))
    _
    (skSrcError form (++ "defn: invalid form:\n" (show form)))))

;;; Expand given form if the given form is a macro form, otherwise
;;; return the given form as is. Note that `macroexpand-1' and
;;; `macroexpand' are macro, not function.
(defmacro* macroexpand-1 (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand1 x))
                         (return `',expanded))))
    _            (return form)))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (let ((= go expr
                             (do (<- expr' (expand1 expr))
                                 (if (== expr expr')
                                     (return `',expr)
                                     (go expr')))))
                       (go x))))
    _            (return form)))

;;; The `cond' macro, found in many Lisp languages.  The behaviour is
;;; same as wrapping the body with `case' expression with dummy unit, or
;;; `if' with `MultiWayIf' GHC language extension.
(defmacro cond body
  `(case ()
     _ (| ,@body)))

(eval-when (compile load)
  (defn (cons (=> (Homoiconic a) (-> a Code Code)))
    (x (LForm (L _l0 xs)))
    (let ((= x' (toCode x))
          (= l1 (getLoc (unLForm x'))))
      (LForm (L l1 (case xs
                     (List xs') (List (: x' xs'))
                     _          (List [x'])))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((= codes (map (\ arg (cons 'toCode (cons arg '())))))
        (= body args `(foldr cons '() [,@(codes args)])))
    (case (unLocLForm form)
      (List (: _ args)) (return (body args))
      _                 (skSrcError form "list: invalid args"))))

(defn (car (-> Code Code))
  ((LForm (L l code)))
  (case code
    (List (: x _xs)) x
    _                (LForm (L l (List [])))))

(defn (cdr (-> Code Code))
  ((LForm (L l code)))
  (case code
    (List (: _ xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                      (case xs
                        [] (LForm (L l' (List [])))
                        _  (LForm (L l' (List xs)))))
    _               (LForm (L l (List [])))))

;;; 'True' when given 'Code' is a 'List'.
(defn (list? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (List _) True
    _        False))

;;; 'True' when given 'Code' is an 'Atom'.
(defn (atom? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (Atom _) True
    _        False))

;;; 'True' when given 'Code' is an atom of 'Symbol'.
(defn (symbol? (-> Code Bool))
  ((LForm (L _ form)))
  (case form
    (Atom (ASymbol _)) True
    _                  False))

;;; Apply given function to immediate elements of `List' and `HsList'.
(defn (mapcar (-> (-> Code Code) Code Code))
  (f (@ form (LForm (L l lst))))
  (case lst
    (List xs)   (LForm (L l (List (map f xs))))
    (HsList xs) (LForm (L l (HsList (map f xs))))
    _           (error (++ "mapcar: not a list " (show form)))))
