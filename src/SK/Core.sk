;;;; Fundamental macros and functions.

(module SK.Core)

(require Language.SK.Expand)

(import Language.SK)
(import Language.SK.Expand)


;;; Macro to specify the phases of evaluation.
(define-macro eval-when form
  (let ((= compile? (elem 'compile))
        (= load? (elem 'load)))
    (case (unLocLForm form)
      (List (: _ (: (LForm (L _ (List phases))) body)))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@body)
               ,@body)))
         ((compile? phases)
          (return `(eval-when-compile ,@body)))
         ((load? phases)
          (return `(begin ,@body)))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

;;; Functions used for defining macros in this file.
(eval-when (compile load)
  (:: cons (=> (Homoiconic a) (-> a Code Code)))
  (= cons x (LForm (L l0 xs))
    (let ((= x' (toCode x))
          (= l1 (getLoc (unLForm x'))))
      (LForm (L l1 (case xs
                     (List xs') (List (: x' xs'))
                     _          (List [x'])))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((= codes (map (\ arg (cons 'toCode (cons arg '())))))
        (= body args `(foldr cons '() [,@(codes args)])))
    (case (unLocLForm form)
      (List (: _ args)) (return (body args))
      _                 (skSrcError form "list: invalid args"))))

(eval-when (compile load)
  ;;; Function to make body expression of macro-defining-macros.
  (:: make-macro-body (-> String Code Code Code Code (Skc Code)))
  (= make-macro-body label whole name arg body
    (let ((= atom-body arg body form-name
            (if (== arg '())
                body
                `(case ,form-name
                   (LForm (L _ (List (: _ ,arg)))) ,body)))
          (= list-body l1 name arg body form-name
            (let ((= hlist xs
                    (LForm (L l1 (HsList xs))))
                  (= err
                    `(skSrcError ,form-name
                                 (concat
                                  [(show ',name) [\lf]
                                   "invalid args: `"
                                   (show *form*) "'"])))
                  (= abind
                    (list 'LForm
                          (list 'L '_loc
                                (list 'List (hlist (: '_ arg)))))))
              `(case ,form-name
                 ,abind  ,body
                 _       ,err))))
      (case (unLForm arg)
        (L l1 (List args)) (return
                             (list-body l1 name args body '*form*))
        (L l1 (Atom _))    (return (atom-body arg body '*form*))
        _                  (skSrcError whole
                                       (++ label ": invalid args"))))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (case (unLocLForm form)
    (List [_ name arg body])
    (do (<- body2 (make-macro-body "defmacro*" form name arg body))
        (return
          `(define-macro ,name *form*
             ,body2)))

    _
    (skSrcError form "defmacro*: invalid form")))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return `(defmacro* ,name ,args
             (return ,body0))))

(eval-when (compile load)
  (:: make-macrolets (-> String Code (-> Code Code) (Skc Code)))
  (= make-macrolets label whole f
    (let ((= g code
            (case (unLocLForm code)
              (List [name arg body])
              (do (<- body2 (make-macro-body label code name
                                             arg (f body)))
                  (return `(,name *form* ,body2)))
              _ (skSrcError whole label))))
      (case (unLocLForm whole)
        (List (: _ (: (LForm (L _ (List forms))) rest)))
        (do (<- macros (fmap List (mapM g forms)))
            (return `(let-macro ,macros
                       ,@rest)))
        _
        (skSrcError whole
                    (concat
                     [label ": invalid form: " (show whole)]))))))

;;; Variant of `let-macro', with `make-macro-body'.
(define-macro macrolet* form
  (make-macrolets "macrolet*" form id))

;;; Variant of `let-macro', with `make-macro-body', and body expression
;;; wrapped with `return'.
(define-macro macrolet form
  (make-macrolets "macrolet" form (\ body `(return ,body))))

;;; Macro for defining simple function. This macro preserves the
;;; location of function name, arguments, and body.
(define-macro defn form
  (case (unLocLForm form)
    (List [_ sig args body])
    (return (case (unLocLForm sig)
              ;; Declaration with type signature.
              (List [name tsig]) `(begin
                                    (:: ,name ,tsig)
                                    (= ,name ,@args
                                      ,body))
              ;; Declaration without type signature.
              (Atom _)           `(= ,sig ,@args
                                    ,body)))
    _
    (skSrcError form
                (++ "`defn': invalid form:\n"
                    (show form)))))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand x))
                         (return `',expanded))))
    _            (skSrcError form (++ "macroexpand: invalid form\n"
                                      (show form)))))

;;; The `cond' macro, found in many Lisp languages.  The behaviour is
;;; same as wrapping the body with `case' expression with dummy unit, or
;;; `if' with `MultiWayIf' GHC language extension.
(defmacro cond body
  `(case ()
     _ (| ,@body)))

(defn (car (-> Code Code))
    ((LForm (L l code)))
  (case code
    (List (: x _xs)) x
    _                (LForm (L l (List [])))))

(defn (cdr (-> Code Code))
    ((LForm (L l code)))
  (case code
    (List (: x xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                      (case xs
                        []      (LForm (L l' (List [])))
                        (: y _) (LForm (L l' (List xs)))))
    _               (LForm (L l (List [])))))

;;; 'True' when given 'Code' is a 'List'.
(defn (list? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (List _) True
    _        False))

;;; 'True' when given 'Code' is an 'Atom'.
(defn (atom? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (Atom _) True
    _        False))

;;; 'True' when given 'Code' is an atom of 'Symbol'.
(defn (symbol? (-> Code Bool))
    ((LForm (L _ form)))
  (case form
    (Atom (ASymbol _)) True
    _                  False))

(defn (mapcar (-> (-> Code Code) Code Code))
    (f (@ form (LForm (L l lst))))
  (case lst
    (List xs)   (LForm (L l (List (map f xs))))
    (HsList xs) (LForm (L l (HsList (map f xs))))
    _           (error (++ "mapcar: not a list " (show form)))))
