;;;; Module containing codes for environment management of current REPL.

(require SK.Core)

(defmodule SK.Repl.Env
  (use
   ;; base
   (Data.IORef)
   (System.IO.Unsafe)
   (Unsafe.Coerce)

   ;; sk-kernel
   (Language.SK.Builder (mkRdrName))
   (Language.SK.Form)
   (Language.SK.GHC
    ((HValue) (HscEnv) fsLit getHValue hscTcRnLookupRdrName
              hsc_IC localRef modifySession noLoc withForeignRef))
   (Language.SK.SKC ((Skc ..)))

   ;; internal
   (SK.Repl.GHC (parseName setInteractivePrintName)))
  (export
   ;; Funcall and environment management.
   funcall1 symbolValue lookupHValue putTheHscEnv getTheHscEnv

   ;; Printer
   prit))


;;; Funcall and lookup

(defn (funcall1 (-> Code a (IO r)))
  (name arg1)
  (do (<- f (symbolValue name))
      (f arg1)))

(defn (symbolValue (-> Code (IO a)))
  (form)
  (do (<- mb-hval (lookupHValue form))
      (case mb-hval
        Nothing   (error (++ "symbolValue: symbol not found "
                             (show form)))
        (Just hv) (return (unsafeCoerce hv)))))

(defn (lookupHValue (-> Code (IO (Maybe HValue))))
  (form)
  (where (case (unCode form)
           (Atom (ASymbol name)) (go name)
           (Atom (AString name)) (go (fsLit name))
           _                     (return Nothing))
    (= go name
      (do (let ((= rname (noLoc (mkRdrName name)))))
          (<- env getTheHscEnv)
          (<- (: name' _) (hscTcRnLookupRdrName env rname))
          (<- fref (getHValue env name'))
          (fmap Just (withForeignRef fref localRef))))))
##(NOINLINE lookupHValue)


;;; Global `HscEnv'

;;; Global value managed with IORef, brought to non-IO world with
;;; `unsafePerformIO', as usual.
(defn (theHscEnv (IORef (IORef HscEnv)))
  ()
  (unsafePerformIO (newIORef (error "theHscEnv: not initialized"))))
##(NOINLINE theHscEnv)

(defn (putTheHscEnv  (-> (IORef HscEnv) (IO ())))
  ()
  (writeIORef theHscEnv))

(defn (getTheHscEnv (IO HscEnv))
  ()
  (>>= (readIORef theHscEnv) readIORef))


;;; Printer

;;; Like `Prelude.print', but without newline at the end.
(defn (prit (=> (Show a) (-> a (IO ()))))
  (x)
  (putStr (show x)))
