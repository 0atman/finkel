;;;; Macros used in REPL.

;;; This module contains macros used inside REPL. Main purpose of using
;;; macros for REPL is to access runtime value of `SkEnv'. Macro body
;;; can contain codes accessing `SkEnv', and then the code could be
;;; invoked from REPL via evaluating the macro forms.

(module SK.Repl.Macro)

(require System.Directory)
(require System.FilePath)
(require Language.SK.GHC)
(require Language.SK.Make)
(require SK.Core)

(import System.Directory)
(import System.FilePath)
(import Language.SK)
(import Language.SK.GHC)
(import Language.SK.Make)
(import SK.Core)

;;; Functions for compiling and loading SK module.
(eval-when (compile load)
  (:: %compile-obj (-> String (Skc Code)))
  (= %compile-obj str
    (gbracket (do (liftIO initStaticOpts)
                  getSessionDynFlags)
              setSessionDynFlags
              (\ dflags
                (do (setSessionDynFlags (dflags {hscTarget HscAsm}))
                    (make [(, str Nothing)] False Nothing)
                    (return `(begin))))))

  (:: %link-module (-> FastString (Skc Code)))
  (= %link-module name
    (do (<- hsc-env getSession)
        (let ((= name' (unpackFS name))
              (= mname (mkModuleNameFS name))))
        (liftIO (do (unload hsc-env [])
                    (linkModule hsc-env (Module mainUnitId mname))))
        (return '(begin))))

  (:: %compile-and-import (-> FilePath (Skc Code)))
  (= %compile-and-import path
    (do (let ((= mname (asModuleName path))))
        (%compile-obj path)
        (%link-module (fsLit mname))
        (return `(import ,(aSymbol mname))))))

;;; Compile source code file to object code.
(defmacro* compile-obj (form)
  (maybe (skSrcError form (++ "compile-obj: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-obj: " file)))
               (%compile-obj file)))
         (fromCode form)))

;;; Link the object code of given module.
(defmacro* link-module (form)
  (let ((= go name
          (do (liftIO (putStrLn (++ "; link-module: " (unpackFS name))))
              (%link-module name)))
        (= err
          (skSrcError form (++ "link-module: not a symbol: "
                               (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      _                    err)))

;;; Compile module source code file to object code, then link it, and
;;; then import the compiled module.
(defmacro* compile-file (form)
  (maybe (skSrcError form (++ "compile-file: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-file: " file)))
               (%compile-and-import file)))
         (fromCode form)))

;;; Load a module source code file. Handles both absolute paths and
;;; relative paths from import directories.
(defmacro* load-file (form)
  (let ((= find-file idirs path0
          (if (isAbsolute path0)
              (find-absolute idirs path0)
              (%compile-and-import path0)))
        (= find-absolute dirs path
          (case dirs
            (: dir dirs') (find-absolute' dir dirs' path)
            []            (cant-find-err path)))
        (= find-absolute' dir dirs path
          (do (<- dir' (if (== dir ".")
                           (liftIO getCurrentDirectory)
                           (return dir)))
              (find-file dirs (makeRelative dir' path))))
        (= cant-find-err file
          (skSrcError form (++ "load-file: cannot find: " file))))
    (maybe (skSrcError form (++ "load-file: not a FilePath: "
                                (show form)))
           (\ path
             (do (liftIO (putStrLn (++ "; load-file: " path)))
                 (<- dflags getSessionDynFlags)
                 (find-file (importPaths dflags) path)))
           (fromCode form))))

;;; Modify settings in REPL.
(defmacro* set-repl (key val)
  (let ((= set-dflags f
          (do (<- dflags getSessionDynFlags)
              (setSessionDynFlags (f dflags))
              (return `(begin))))
        (= val-err expect
          (skSrcError val (concat ["set-repl (" (show key)
                                   "): expecting " expect
                                   ", got " (show val)])))
        (= set-verbosity v
          (case (unLocLForm v)
            (Atom (AInteger n)) (set-dflags
                                 (\ d (d {verbosity (fromInteger n)})))
            _                   (val-err "Integer")))
        (= set-symbol k
          (case (unpackFS k)
            "verbosity" (set-verbosity val)
            _           set-repl-err))
        (= set-repl-err
          (skSrcError key (++ "set-repl: unknown key: " (show key)))))
    (case (unLocLForm key)
      (Atom (ASymbol k)) (set-symbol k)
      _                  set-repl-err)))

;;; Functions for `info' macro.
(eval-when (compile load)
  (:: show-context (Skc ()))
  (= show-context
    (where (do (<- context getContext)
               (<- dflags getSessionDynFlags)
               (liftIO (putStrLn "\n; context:"))
               (liftIO (mapM_ (printContext dflags)
                              context)))
      (= printContext dflags ctx
        (case ctx
          (IIDecl decl)    (putStrLn (++ ";  IIDecl: "
                                         (showSDoc dflags (ppr decl))))
          (IIModule mname) (putStrLn (++ ";  IIModule: "
                                         (moduleNameString mname)))))))

  (:: show-info (Skc ()))
  (= show-info
    (liftIO
     (do (putStrLn
          "Usage: (info COMMANDS)

DESCRIPTION:

  Show info of current REPL session.

COMMANDS:

  context   - Show current context.
  linker    - Show linker.
  packages  - Show accessible packages.
  paths     - Show paths.
  info      - Show this help.
"))))

  (:: show-linker (Skc ()))
  (= show-linker
    (do (<- hsc-env getSession)
        (liftIO (do (initDynLinker hsc-env)
                    (showLinkerState (hsc_dflags hsc-env))))))

  (:: show-packages (Skc ()))
  (= show-packages
    (do (<- dflags getDynFlags)
        (let ((= pr str
                (putStrLn (++ ";   " str)))
              (= pr-flag flag
                (case flag
                  (ExposePackage n _ _) (pr n)
                  (HidePackage n)       (pr (++ "hiding " n))))))
        (liftIO (do (putStrLn "; packages")
                    (mapM_ pr-flag (packageFlags dflags))))))

  (:: show-paths (Skc ()))
  (= show-paths
    (do (<- dflags getDynFlags)
        (liftIO (do (<- cwd getCurrentDirectory)
                    (putStrLn "\n; current working directory: ")
                    (putStrLn (++ ";   " cwd))
                    (let ((= ipaths (importPaths dflags))))
                    (putStrLn "; module import search paths: ")
                    (if (null ipaths)
                        (putStrLn ";   none")
                        (mapM_ (\ ipath
                                 (putStrLn (++ ";   " ipath)))
                               ipaths)))))))

(defmacro* info (form)
  (let ((= go sym
          (case (unpackFS sym)
            "context"  show-context
            "linker"   show-linker
            "packages" show-packages
            "paths"    show-paths
            "info"     show-info
            _          err))
        (= err
          (skSrcError form (++ "info: invalid form: " (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (do (liftIO initStaticOpts)
                               (go sym)
                               (return '(begin)))
      _                    err)))
