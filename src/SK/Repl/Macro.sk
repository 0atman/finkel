;;;; Macros used in REPL.

;;; This module contains macros accessible from REPL. Main purpose of
;;; using macros for REPL is to access runtime value of `SkEnv'. Macro
;;; body can contain codes accessing `SkEnv', and then the code could be
;;; invoked from REPL via evaluating the typed in forms.

(module SK.Repl.Macro)

(require SK.Core)
(import SK.Core)

(macrolet ((use idecl
             `(begin
                (require ,@idecl)
                (import ,@idecl))))
  (use Control.Monad)
  (use qualified Data.ByteString.Char8 as BS.C8)
  (use Data.Foldable)
  (use Data.Function)
  (use Data.List)
  (use Data.Maybe)
  (use System.Directory)
  (use System.FilePath)
  (use System.IO)
  (use Language.SK)
  (use Language.SK.Builder)
  (use Language.SK.GHC)
  (use Language.SK.Make)
  (use SK.Repl.GHC))


;;; Compilation
;;; -----------

;;; Functions for compiling and loading SK module.
(eval-when (compile load)
  (:: mk-ii-fs (-> FastString InteractiveImport))
  (= mk-ii-fs name
    (IIDecl (simpleImportDecl (mkModuleNameFS name))))

  (:: mk-ii (-> String InteractiveImport))
  (= mk-ii (. mk-ii-fs fsLit))

  (:: code->mb-string (-> Code (Maybe String)))
  (= code->mb-string code
    (case (unLocLForm code)
      (Atom (ASymbol sym)) (Just (unpackFS sym))
      (Atom (AString str)) (Just str)
      _                    Nothing))

  (:: %compile-obj (-> String (Skc Code)))
  (= %compile-obj str
    (gbracket (do (<- dflags getSessionDynFlags)
                  (<- context getContext)
                  (return (, dflags context)))
              (\ (, dflags context)
                (do (<- _ (setSessionDynFlags dflags))
                    (setContext context)))
              (\ (, dflags _context)
                (do (<- _ (setSessionDynFlags
                           (dflags {hscTarget HscAsm})))
                    (make [(, str Nothing)] False Nothing)
                    (return '(begin))))))

  (:: %link-module (-> FastString (Skc Code)))
  (= %link-module name
    (do (<- hsc-env getSession)
        (let ((= mname (mkModuleNameFS name))
              (= uid (thisPackage (hsc_dflags hsc-env)))))
        (liftIO (do (unload hsc-env [])
                    (linkModule hsc-env (Module uid mname))))
        (return '(begin))))

  (:: %compile-link-and-import (-> FilePath (Skc Code)))
  (= %compile-link-and-import path
    (do (let ((= mname (asModuleName path))))
        (<- _ (%compile-obj path))
        (<- _ (%link-module (fsLit mname)))
        (<- mods (fmap envContextModules getSkEnv))
        (setContext (map mk-ii (: mname mods)))
        (return '(begin)))))

;;; Compile source code to object code.
(defmacro* compile-obj (form)
  (maybe (skSrcError form (++ "compile-obj: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-obj: " file)))
               (%compile-obj file)))
         (code->mb-string form)))

;;; Link the object code of given module.
(defmacro* link-module (form)
  (let ((= go name
          (do (liftIO (putStrLn (++ "; link-module: " (unpackFS name))))
              (%link-module name)))
        (= err
          (skSrcError form (++ "link-module: not a symbol: "
                               (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      _                    err)))

;;; Load a module source code file. Handles absolute paths and relative
;;; paths from import directories.
(defmacro* load-file (form)
  (let ((= find-file idirs path
          (if (isAbsolute path)
              (find-absolute idirs path)
              (%compile-link-and-import path)))
        (= find-absolute dirs path
          (case dirs
            (: dir dirs') (find-absolute' dir dirs' path)
            []            (cant-find-err path)))
        (= find-absolute' dir dirs path
          (do (<- dir' (if (== dir ".")
                           (liftIO getCurrentDirectory)
                           (return dir)))
              (find-file dirs (makeRelative dir' path))))
        (= cant-find-err file
          (skSrcError form (++ "load-file: cannot find: " file)))
        ;; From `GhcMake.discardIC'.
        (= discardIC hsc-env
          (let ((= empty-ic (emptyInteractiveContext dflags))
                (= new-ic-monad (keep-external-name ic_monad))
                (= old-ic (hsc_IC hsc-env))
                (= dflags (hsc_dflags hsc-env))
                (= keep-external-name ic-name
                  (where
                      (| ((nameIsFromExternalPackage this-pkg
                                                     old-name)
                          old-name)
                         (otherwise
                          (ic-name empty-ic)))
                    (= this-pkg (thisPackage dflags))
                    (= old-name (ic-name old-ic)))))
            (hsc-env {hsc_IC (empty-ic {ic_monad new-ic-monad})})))
        (= clear-all
          ;; Cleare various states: resume, finder cache, targets,
          ;; interactive context ... etc.
          (do (<- graph0 getModuleGraph)
              (<- _ abandonAll)
              (<- _ (setTargets []))
              (<- _ (load LoadAllTargets))
              (<- hsc-env getSession)
              (let ((= uncache
                      (. (uncacheModule hsc-env) ms_mod_name))))
              (liftIO (do (mapM_ uncache graph0)
                          (flushFinderCaches hsc-env)))
              (setSession (discardIC hsc-env)))))
    (maybe (skSrcError form (++ "load-file: not a FilePath: "
                                (show form)))
           (\ path
             (do (liftIO (putStrLn (++ "; load-file: " path)))
                 ;; Clear current state first.
                 (clear-all)
                 ;; Find the source file path and compile, load, and
                 ;; link the module.
                 (<- dflags getSessionDynFlags)
                 (find-file (importPaths dflags) path)))
           (fromCode form))))


;;; Settings
;;; --------

;;; Set command line flags, see `GHCi.UI.newDynFlags'.
(defmacro* set-flags forms
  (case forms
    (: _ _)
    (| ((all symbol? forms)
        (do (<- dflags0 getSessionDynFlags)
            (let ((= flags
                    (map (. noLoc symbolName) forms))))
            (<- (, dflags1 _leftovers warns)
                (parseDynamicFlags dflags0 flags))
            (liftIO (handleFlagWarnings dflags1 warns))
            (<- _ (setSessionDynFlags dflags1))
            (<- _ (setInteractiveDynFlags dflags1))
            (return '(begin)))))

    _
    (skSrcError nil "set-flags: empty form")))

;;; Modify settings in REPL.
(defmacro* set-repl (key val)
  (let ((= set-dflags f
          (do (<- dflags getSessionDynFlags)
              (<- _ (setSessionDynFlags (f dflags)))
              (return '(begin))))
        (= val-err expect
          (skSrcError val (concat ["set-repl (" (show key)
                                   "): expecting " expect
                                   ", got " (show val)])))
        (= set-cwd v
          (case (code->mb-string v)
            (Just path) (do (liftIO (setCurrentDirectory path))
                            (return '(begin)))
            Nothing     (val-err "Symbol or String")))
        (= set-debug v
          (case (fromCode v)
            (Just bool) (do (modifySkEnv (\ e (e {envDebug bool})))
                            (return '(begin)))
            Nothing     (val-err "Bool")))
        (= set-verbosity v
          (case (unLocLForm v)
            (Atom (AInteger n)) (set-dflags
                                 (\ d (d {verbosity (fromInteger n)})))
            _                   (val-err "Integer")))
        (= set-symbol k
          (case (unpackFS k)
            "cwd"       (set-cwd val)
            "debug"     (set-debug val)
            "verbosity" (set-verbosity val)
            _           set-repl-err))
        (= set-repl-err
          (skSrcError key (++ "set-repl: unknown key: " (show key)))))
    (case (unLocLForm key)
      (Atom (ASymbol k)) (set-symbol k)
      _                  set-repl-err)))

;;; Alias macro for a `set-repl' sub-command `cwd'.
(defmacro cd (path)
  `(set-repl cwd ,path))

;;; Functions for `info' macro.
(eval-when (compile load)
  ;; Mostly translated from `GHCi.UI.infoThing'.
  (:: info-name (-> Code (Skc Code)))
  (= info-name thing
    (do (<- unqual getPrintUnqual)
        (<- dflags getDynFlags)
        (<- sdoc (info-thing True (show thing)))
        (liftIO (putStrLn (showSDocForUser dflags unqual sdoc)))
        (return '(begin))))

  (:: info-thing (-> Bool String (Skc SDoc)))
  (= info-thing all-info str
    (do (<- names (parse-name str))
        (<- mb_stuffs (mapM (getInfo all-info) names))
        (let ((= filtered (filter-out-children
                           (\ (, t _f _ci _fi) t)
                           (catMaybes mb_stuffs)))
              (= ppr-info (, thing _fixity cls-insts fam-insts)
                ($$ (pprTyThingInContextLoc thing)
                    ($$ (vcat (map pprInstance cls-insts))
                        (vcat (map pprFamInst fam-insts)))))))
        (return (vcat (intersperse (text "")
                                   (map ppr-info filtered))))))

  (:: parse-name (-> String (Skc [Name])))
  (= parse-name str
    (if (elem str ["()" "[]"])
        (parseName str)
        (withSession
         (\ hsc-env
           (liftIO
            (let ((= lrdr-name (genSrc (mkRdrName (fsLit str)))))
              (hscTcRnLookupRdrName hsc-env lrdr-name)))))))

  (:: filter-out-children (-> (-> a TyThing) [a] [a]))
  (= filter-out-children get-thing xs
    (let ((= all-names (mkNameSet (map (. getName get-thing) xs)))
          (= has-parent x
            (case (tyThingParent_maybe (get-thing x))
              (Just p) (elemNameSet (getName p) all-names)
              Nothing  False)))
      (filter (. not has-parent) xs)))

  ;; Almost same as `GHCi.UI.showBindings'.
  (:: info-bindings (Skc ()))
  (= info-bindings
    (where (do (<- bindings getBindings)
               (<- docs (mapM makeDoc (reverse bindings)))
               (mapM_ pprForUserPartWay docs))
      (:: makeDoc (-> TyThing (Skc SDoc)))
      (= makeDoc tt
        (case tt
          (AnId i) (pprTypeAndContents i)
          _        (do (<- mb-stuff (getInfo False (getName tt)))
                       (return (maybe (text "") pprTT mb-stuff)))))
      (:: pprTT (-> (, TyThing Fixity [ClsInst] [FamInst]) SDoc))
      (= pprTT (, thing _ _ _)
        (pprTyThing showToHeader thing))
      (:: pprForUserPartWay (-> SDoc (Skc ())))
      (= pprForUserPartWay sdoc
        (do (<- unqual getPrintUnqual)
            (<- dflags getDynFlags)
            (liftIO (printForUserPartWay dflags
                                         stdout
                                         (pprUserLength dflags)
                                         unqual
                                         sdoc))))))

  (:: info-context (Skc ()))
  (= info-context
    (where (do (<- context getContext)
               (<- dflags getSessionDynFlags)
               (liftIO (putStrLn "\n; context:"))
               (liftIO (mapM_ (printContext dflags)
                              context)))
      (= printContext dflags ctx
        (case ctx
          (IIDecl decl)    (putStrLn (++ ";  IIDecl: "
                                         (showSDoc dflags (ppr decl))))
          (IIModule mname) (putStrLn (++ ";  IIModule: "
                                         (moduleNameString mname)))))))

  (:: info-dflags (Skc ()))
  (= info-dflags
    (do (<- dflags getDynFlags)
        (let ((= s
                ["; dflags:"
                 (++ ";  ghcLink: " (show (ghcLink dflags)))
                 (++ ";  ghcMode: " (showGhcMode (ghcMode dflags)))
                 (++ ";  hscTarget: " (show (hscTarget dflags)))
                 (++ ";  objectDir: " (show (objectDir dflags)))
                 (++ ";  thisInstalledUnitId: "
                     (showPpr dflags (thisInstalledUnitId dflags)))])
              (= showGhcMode m
                (case m
                  CompManager "CompManager"
                  OneShot     "OneShot"
                  MkDepend    "MkDepend"))))
        (liftIO (putStrLn (intercalate "\n" s)))))

  (:: info-info (Skc ()))
  (= info-info
    (liftIO
     (do (putStrLn
          "USAGE: (info COMMANDS)

DESCRIPTION:

  Show info of current REPL session.

COMMANDS:

  'NAME     - Show info of NAME.
  context   - Show current context.
  dflags    - Show current DynFlags information.
  info      - Show this help.
  linker    - Show linker.
  macros    - Show macros defined in REPL environment.
  modules   - Show loaded modules.
  packages  - Show accessible packages.
  paths     - Show paths.
"))))

  (:: info-linker (Skc ()))
  (= info-linker
    (do (<- hsc-env getSession)
        (liftIO (do (initDynLinker hsc-env)
                    (showLinkerState (hsc_dflags hsc-env))))))

  (:: info-macros (Skc ()))
  (= info-macros
    (do (<- macros (fmap envMacros getSkEnv))
        (liftIO (putStrLn "; macros:"))
        (mapM_ (\ m (liftIO (putStrLn (++ ";  " m))))
               (macroNames macros))))

  (:: info-modules (Skc ()))
  (= info-modules
    (do (<- graph0 getModuleGraph)
        (<- graph1 (filterM (. isLoaded ms_mod_name) graph0))
        (let ((= show-one m
                (>>= (showModule m) (. liftIO putStrLn)))))
        (mapM_ show-one graph1)))

  (:: info-packages (Skc ()))
  (= info-packages
    (do (<- dflags getDynFlags)
        (let ((= pr str
                (putStrLn (++ ";   " str)))
              (= pr-flag flag
                (case flag
                  (ExposePackage n _ _) (pr n)
                  (HidePackage n)       (pr (++ "hiding " n))))))
        (liftIO (do (putStrLn "; packages")
                    (mapM_ pr-flag (packageFlags dflags))))))

  (:: info-paths (Skc ()))
  (= info-paths
    (do (<- dflags getDynFlags)
        (liftIO (do (<- cwd getCurrentDirectory)
                    (putStrLn "\n; current working directory: ")
                    (putStrLn (++ ";   " cwd))
                    (let ((= ipaths (importPaths dflags))))
                    (putStrLn "; module import search paths: ")
                    (if (null ipaths)
                        (putStrLn ";   none")
                        (mapM_ (\ ipath
                                 (putStrLn (++ ";   " ipath)))
                               ipaths)))))))

(defmacro* info (form)
  (let ((= go sym
          (do (case (unpackFS sym)
                "bindings" info-bindings
                "context"  info-context
                "dflags"   info-dflags
                "linker"   info-linker
                "macros"   info-macros
                "modules"  info-modules
                "packages" info-packages
                "paths"    info-paths
                _          info-info)
              (return '(begin))))
        (= err
          (skSrcError form (++ "info: invalid form: " (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      (List [q name])      (| ((|| (== q 'quote) (== q 'quasiquote))
                               (info-name name)))
      _                    err)))

;;; Simplified version of `GHCi.UI.browseModule'.
(eval-when (compile load)
  (:: browse-module (-> Module ModuleInfo (Skc ())))
  (= browse-module mdl mod-info
    (do (let ((= names (modInfoExports mod-info))
              (= sorted-names
                (++ (loc-sort local) (occ-sort external)))
              (= (, local external)
                (partition (. (== mdl) nameModule) names))
              (= occ-sort (sortBy (on compare nameOccName)))
              (= loc-sort ns
                (| ((<- (: n _) ns) (isGoodSrcSpan (nameSrcSpan n))
                    (sortBy (on compare nameSrcSpan) ns))
                   (otherwise
                    (occ-sort ns))))
              (= pretty
                (pprTyThing showToHeader))))
        (<- mb-things (mapM lookupName sorted-names))
        (<- dflags getDynFlags)
        (<- unqual getPrintUnqual)
        (let ((= things (catMaybes mb-things))
              (= prettyThings (map pretty things))))
        (liftIO
         (putStrLn
          (showSDocForUser dflags unqual (vcat prettyThings)))))))

;;; Mostly taken from `GHCi.UI.browseCmd'.
(defmacro* browse (form)
  (let ((= go name
          (| ((looksLikeModuleName name)
              (do (<- mdl (lookupModule (mkModuleName name) Nothing))
                  (<- mb-mod-info (getModuleInfo mdl))
                  (case mb-mod-info
                    Nothing         (liftIO
                                     (putStrLn
                                      (++ "unknown module: " name)))
                    (Just mod-info) (browse-module mdl mod-info))
                  (return '(begin))))
             (otherwise err)))
        (= err
          (skSrcError form (++ "browse: invalid form: " (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go (unpackFS sym))
      _                    err)))


;;; Package
;;; -------

;;; Lookup `PackageConfig' of given package in `DynFlags'.
(defn+ (lookup-package-config
        (-> DynFlags String (IO (Maybe PackageConfig))))
  (dflags pkgname)
  (do (<- confs (liftIO (readPackageConfigs dflags)))
      (return
        (find (. (== pkgname) packageNameString)
              (concat (map snd confs))))))

;;; Lookup matching linkable with given name, and set
;;; `thisInstalledUnitId' field in current `DynFlags' to the component
;;; when linkable were found.  By setting component, REPL will recompile
;;; module from SK source code, by ignoring module found in pre-compiled
;;; library linkable.  This behaviour may useful when working with cabal
;;; package library modules from REPL.
(defmacro* in-component (name)
  (do (<- dflags0 getDynFlags)
      (let ((= set-this-unit-id cid
              (do (let ((= flags (map noLoc ["-this-unit-id" cid]))))
                  (<- (, dflags1 _ _)
                      (parseDynamicFlags dflags0 flags))
                  (<- _ (setSessionDynFlags dflags1))
                  (liftIO
                   (putStrLn
                    (concat ["; this unit id set to `" cid "'"])))))
            (= not-found
              (liftIO
               (putStrLn
                (concat ["; package " (show name) " not found"]))))))
      (<- mb-component-id
          (liftIO
           (do (<- mb-pc (maybe (return Nothing)
                                (lookup-package-config dflags0)
                                (code->mb-string name)))
               (return (fmap (. BS.C8.unpack
                                (. toStringRep componentId))
                             mb-pc)))))
      (case mb-component-id
        (Just cid) (set-this-unit-id cid)
        Nothing    (| ((elem name ['this 'main])
                       (set-this-unit-id (show name)))
                      (otherwise not-found)))
      (return '(begin))))
