;;;; Macros used in REPL.

;;; This module contains macros used inside REPL. Main purpose of using
;;; macros for REPL is to access runtime value of `SkEnv'. Macro body
;;; can contain codes accessing `SkEnv', and then the code could be
;;; invoked from REPL via evaluating the macro forms.

(module SK.Repl.Macro)

(require Control.Monad)
(require Data.List)
(require Data.Maybe)
(require System.Directory)
(require System.FilePath)
(require Language.SK.Builder)
(require Language.SK.GHC)
(require Language.SK.Make)
(require SK.Core)
(require SK.Repl.GHC)

(import Control.Monad)
(import Data.List)
(import Data.Maybe)
(import System.Directory)
(import System.FilePath)
(import Language.SK)
(import Language.SK.Builder)
(import Language.SK.GHC)
(import Language.SK.Make)
(import SK.Core)
(import SK.Repl.GHC)


;;; Functions for compiling and loading SK module.
(eval-when (compile load)
  (:: mk-ii-fs (-> FastString InteractiveImport))
  (= mk-ii-fs name
    (IIDecl (simpleImportDecl (mkModuleNameFS name))))

  (:: mk-ii (-> String InteractiveImport))
  (= mk-ii (. mk-ii-fs fsLit))

  (:: code->mb-string (-> Code (Maybe String)))
  (= code->mb-string code
    (case (unLocLForm code)
      (Atom (ASymbol sym)) (Just (unpackFS sym))
      (Atom (AString str)) (Just str)
      _                    Nothing))

  (:: %compile-obj (-> String (Skc Code)))
  (= %compile-obj str
    (gbracket (do (<- dflags getSessionDynFlags)
                  (<- context getContext)
                  (return (, dflags context)))
              (\ (, dflags context)
                (do (setSessionDynFlags dflags)
                    (setContext context)))
              (\ (, dflags _context)
                (do (setSessionDynFlags (dflags {hscTarget HscAsm}))
                    (make [(, str Nothing)] False Nothing)
                    (return '(begin))))))

  (:: %link-module (-> FastString (Skc Code)))
  (= %link-module name
    (do (<- hsc-env getSession)
        (let ((= name' (unpackFS name))
              (= mname (mkModuleNameFS name))))
        (liftIO (do (unload hsc-env [])
                    (linkModule hsc-env (Module mainUnitId mname))))
        (return '(begin))))

  (:: %compile-link-and-import (-> FilePath (Skc Code)))
  (= %compile-link-and-import path
    (do (let ((= mname (asModuleName path))))
        (%compile-obj path)
        (%link-module (fsLit mname))
        (<- mods (fmap envContextModules getSkEnv))
        (setContext (map mk-ii (: mname mods)))
        (return '(begin)))))

;;; Compile source code to object code.
(defmacro* compile-obj (form)
  (maybe (skSrcError form (++ "compile-obj: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-obj: " file)))
               (%compile-obj file)))
         (code->mb-string form)))

;;; Link the object code of given module.
(defmacro* link-module (form)
  (let ((= go name
          (do (liftIO (putStrLn (++ "; link-module: " (unpackFS name))))
              (%link-module name)))
        (= err
          (skSrcError form (++ "link-module: not a symbol: "
                               (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      _                    err)))

;;; Compile module source code file to object code, then link it, and
;;; then import the compiled module.
(defmacro* compile-file (form)
  (maybe (skSrcError form (++ "compile-file: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-file: " file)))
               (%compile-link-and-import file)))
         (fromCode form)))

;;; Load a module source code file. Handles absolute paths, and
;;; relative paths from import directories.
(defmacro* load-file (form)
  (let ((= find-file idirs path0
          (if (isAbsolute path0)
              (find-absolute idirs path0)
              (%compile-link-and-import path0)))
        (= find-absolute dirs path
          (case dirs
            (: dir dirs') (find-absolute' dir dirs' path)
            []            (cant-find-err path)))
        (= find-absolute' dir dirs path
          (do (<- dir' (if (== dir ".")
                           (liftIO getCurrentDirectory)
                           (return dir)))
              (find-file dirs (makeRelative dir' path))))
        (= cant-find-err file
          (skSrcError form (++ "load-file: cannot find: " file))))
    (maybe (skSrcError form (++ "load-file: not a FilePath: "
                                (show form)))
           (\ path
             (do (liftIO (putStrLn (++ "; load-file: " path)))
                 (<- dflags getSessionDynFlags)
                 (find-file (importPaths dflags) path)))
           (fromCode form))))

(defmacro* in-module (form)
  (case (unLocLForm form)
    (Atom (ASymbol name)) (do (liftIO (putStrLn
                                       (++ "; in-module: "
                                           (unpackFS name))))
                              (setContext [(mk-ii-fs name)
                                           (mk-ii "SK.User")])
                              (return '(begin)))
    _ (skSrcError form (++ "in-module: not a module name: "
                           (show form)))))

;;; Modify settings in REPL.
(defmacro* set-repl (key val)
  (let ((= set-dflags f
          (do (<- dflags getSessionDynFlags)
              (setSessionDynFlags (f dflags))
              (return '(begin))))
        (= val-err expect
          (skSrcError val (concat ["set-repl (" (show key)
                                   "): expecting " expect
                                   ", got " (show val)])))
        (= set-cwd v
          (case (code->mb-string v)
            (Just path) (do (liftIO (setCurrentDirectory path))
                            (return '(begin)))
            Nothing     (val-err "Symbol or String")))
        (= set-debug v
          (case (fromCode v)
            (Just bool) (do (modifySkEnv (\ e (e {envDebug bool})))
                            (return '(begin)))
            Nothing     (val-err "Bool")))
        (= set-verbosity v
          (case (unLocLForm v)
            (Atom (AInteger n)) (set-dflags
                                 (\ d (d {verbosity (fromInteger n)})))
            _                   (val-err "Integer")))
        (= set-symbol k
          (case (unpackFS k)
            "cwd"       (set-cwd val)
            "debug"     (set-debug val)
            "verbosity" (set-verbosity val)
            _           set-repl-err))
        (= set-repl-err
          (skSrcError key (++ "set-repl: unknown key: " (show key)))))
    (case (unLocLForm key)
      (Atom (ASymbol k)) (set-symbol k)
      _                  set-repl-err)))

;;; Alias macro for a `set-repl' sub-command `cwd'.
(defmacro cd (path)
  `(set-repl cwd ,path))

;;; Functions for `info' macro.
(eval-when (compile load)
  (:: info-context (Skc ()))
  (= info-context
    (where (do (<- context getContext)
               (<- dflags getSessionDynFlags)
               (liftIO (putStrLn "\n; context:"))
               (liftIO (mapM_ (printContext dflags)
                              context)))
      (= printContext dflags ctx
        (case ctx
          (IIDecl decl)    (putStrLn (++ ";  IIDecl: "
                                         (showSDoc dflags (ppr decl))))
          (IIModule mname) (putStrLn (++ ";  IIModule: "
                                         (moduleNameString mname)))))))

  (:: info-info (Skc ()))
  (= info-info
    (liftIO
     (do (putStrLn
          "USAGE: (info COMMANDS)

DESCRIPTION:

  Show info of current REPL session.

COMMANDS:

  context   - Show current context.
  dflags    - Show current DynFlags information.
  info      - Show this help.
  linker    - Show linker.
  macros    - Show macros defined in REPL environment.
  modules   - Show loaded modules.
  packages  - Show accessible packages.
  paths     - Show paths.
"))))

  (:: info-linker (Skc ()))
  (= info-linker
    (do (<- hsc-env getSession)
        (liftIO (do (initDynLinker hsc-env)
                    (showLinkerState (hsc_dflags hsc-env))))))

  (:: info-packages (Skc ()))
  (= info-packages
    (do (<- dflags getDynFlags)
        (let ((= pr str
                (putStrLn (++ ";   " str)))
              (= pr-flag flag
                (case flag
                  (ExposePackage n _ _) (pr n)
                  (HidePackage n)       (pr (++ "hiding " n))))))
        (liftIO (do (putStrLn "; packages")
                    (mapM_ pr-flag (packageFlags dflags))))))

  (:: info-paths (Skc ()))
  (= info-paths
    (do (<- dflags getDynFlags)
        (liftIO (do (<- cwd getCurrentDirectory)
                    (putStrLn "\n; current working directory: ")
                    (putStrLn (++ ";   " cwd))
                    (let ((= ipaths (importPaths dflags))))
                    (putStrLn "; module import search paths: ")
                    (if (null ipaths)
                        (putStrLn ";   none")
                        (mapM_ (\ ipath
                                 (putStrLn (++ ";   " ipath)))
                               ipaths))))))

  (:: info-dflags (Skc ()))
  (= info-dflags
    (do (<- dflags getDynFlags)
        (let ((= s
                ["; dflags:"
                 (++ ";  ghcLink:   " (show (ghcLink dflags)))
                 (++ ";  hscTarget: " (show (hscTarget dflags)))
                 (++ ";  ghcMode:   " (showGhcMode (ghcMode dflags)))])
              (= showGhcMode m
                (case m
                  CompManager "CompManager"
                  OneShot     "OneShot"
                  MkDepend    "MkDepend"))))
        (liftIO (putStrLn (intercalate "\n" s)))))

  (:: info-macros (Skc ()))
  (= info-macros
    (do (<- macros getEnvMacros)
        (liftIO (putStrLn "; macros:"))
        (mapM_ (\ m (liftIO (putStrLn (++ ";  " m))))
               (macroNames macros))))

  (:: info-modules (Skc ()))
  (= info-modules
    (do (<- graph0 getModuleGraph)
        (<- graph1 (filterM (. isLoaded ms_mod_name) graph0))
        (let ((= show-one m
                (>>= (showModule m) (. liftIO putStrLn)))))
        (mapM_ show-one graph1)))

  ;; Mostly translated from `GHCi.UI.infoThing'.
  (:: info-name (-> Code (Skc Code)))
  (= info-name thing
    (do (<- unqual getPrintUnqual)
        (<- dflags getDynFlags)
        (<- sdoc (info-thing True (show thing)))
        (liftIO (putStrLn (showSDocForUser dflags unqual sdoc)))
        (return '(begin))))

  (:: info-thing (-> Bool String (Skc SDoc)))
  (= info-thing all-info str
    (do (<- names (parse-name str))
        (<- mb_stuffs (mapM (getInfo all-info) names))
        (let ((= filtered (filter-out-children
                           (\ (, t _f _ci _fi) t)
                           (catMaybes mb_stuffs)))
              (= ppr-info (, thing fixity cls-insts fam-insts)
                ($$ (pprTyThingInContextLoc thing)
                    ($$ (vcat (map pprInstance cls-insts))
                        (vcat (map pprFamInst fam-insts)))))))
        (return (vcat (intersperse (text "")
                                   (map ppr-info filtered))))))

  (:: parse-name (-> String (Skc [Name])))
  (= parse-name str
    (if (elem str ["()" "[]"])
        (parseName str)
        (withSession
         (\ hsc-env
           (liftIO
            (let ((= lrdr-name (genSrc (mkRdrName (fsLit str)))))
              (hscTcRnLookupRdrName hsc-env lrdr-name)))))))

  (:: filter-out-children (-> (-> a TyThing) [a] [a]))
  (= filter-out-children get-thing xs
    (let ((= all-names (mkNameSet (map (. getName get-thing) xs)))
          (= has-parent x
            (case (tyThingParent_maybe (get-thing x))
              (Just p) (elemNameSet (getName p) all-names)
              Nothing  False)))
      (filter (. not has-parent) xs))))

(defmacro* info (form)
  (let ((= go sym
          (do (case (unpackFS sym)
                "context"  info-context
                "dflags"   info-dflags
                "linker"   info-linker
                "macros"   info-macros
                "modules"  info-modules
                "packages" info-packages
                "paths"    info-paths
                _          info-info)
              (return '(begin))))
        (= err
          (skSrcError form (++ "info: invalid form: " (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      (List [q name])      (| ((|| (== q 'quote) (== q 'quasiquote))
                               (info-name name)))
      _                    err)))
