##(LANGUAGE GeneralizedNewtypeDeriving)

;;;; Types for REPL.

(require SK.Core)

(defmodule SK.Repl.Types
  (use
   ;; base
   (Control.Concurrent ((MVar)))
   (Control.Monad.IO.Class ((MonadIO ..)))

   ;; bytestring
   (qualified Data.ByteString.Lazy.Char8 as BS)

   ;; haskeline
   (System.Console.Haskeline ((MonadException ..)))

   ;; transformers
   (Control.Monad.Trans.Class (lift))
   (Control.Monad.Trans.State.Strict ((StateT ..) evalStateT get put))

   ;; sk-kernel
   (Language.SK ((Code))))

  (export
   ;; repl
   (Repl ..) run-repl put-repl-state get-repl-state lift-repl

   ;; repl state
   (ReplState ..) initial-repl-state

   ;; input and result
   (Input ..) (InputType ..) (Result)

   ;; re-export
   lift))


;;; Repl, state, and result types

;;; Repl state type to hold intermediate line-wise inputs.
(data ReplState
  (ReplState {pending-input [BS.ByteString]
              input-count Int})
  (deriving (Eq Show)))

(defn (initial-repl-state ReplState)
  ()
  (ReplState {pending-input [] input-count 0}))

(newtype (Repl a)
  (Repl {unRepl (StateT ReplState IO a)})
  (deriving (Functor Applicative Monad MonadIO MonadException)))

(defn (run-repl (-> (Repl a) ReplState (IO a)))
  (repl st)
  (evalStateT (unRepl repl) st))

(defn (put-repl-state (-> ReplState (Repl ())))
  ()
  (. Repl put))

(defn (get-repl-state (Repl ReplState))
  ()
  (Repl get))

(defn (lift-repl (-> (IO a) (Repl a)))
  ()
  (. Repl lift))

(data Input
  (Input InputType Code (MVar Result)))

(data InputType
  Prompt
  Connection
  (deriving (Eq Show)))

(type Result (Either String String))
