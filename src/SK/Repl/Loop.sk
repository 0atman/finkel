;;; Loops in REPL.

(require SK.Core)

(defmodule SK.Repl.Loop
  (use
   ;; base
   (Control.Concurrent ((ThreadId) forkIO killThread))
   (Control.Concurrent.MVar ((MVar) newEmptyMVar putMVar takeMVar))
   (Control.Exception ((AsyncException ..) bracket catch throwIO))
   (Control.Monad (void))
   (Control.Monad.IO.Class (liftIO))
   (Data.List (intercalate isSuffixOf nubBy))
   (System.Exit (exitWith))
   (System.IO (hClose hFlush openTempFile stdout))
   (System.IO.Error (isDoesNotExistError))

   ;; bytestring
   (Data.ByteString.Builder (stringUtf8 toLazyByteString))
   (qualified Data.ByteString.Lazy.Char8 as BS)

   ;; directory
   (System.Directory (getTemporaryDirectory removeFile))

   ;; haskeline
   (System.Console.Haskeline
    ((InputT) defaultSettings getInputLine handleInterrupt outputStr
              outputStrLn runInputT throwTo withInterrupt))

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Builder ((HDecl) (HImportDecl)  (HStmt) evalBuilder))
   (Language.SK.Eval (evalDecls))
   (Language.SK.GHC)
   (Language.SK.Lexer (evalSP))
   (Language.SK.Reader (sexpr))
   (Language.SK.Run (runSkc skErrorHandler withSourceErrorHandling))
   (Language.SK.Syntax (parseImports parseStmt parseTopDecls))

   ;; internal
   (SK.Repl.Env)
   (SK.Repl.GHC)
   (SK.Repl.Listen)
   (SK.Repl.IORedirect)
   (SK.Repl.Types))

  (export
   eval-loop read-print-loop init-form start-repl
   make-tmpfile cleanup-tmpfile))


;;; Starting the REPL

;;; Start REPL, maybe listen to given port number.
(defdo (start-repl (-> (Maybe Int) SkEnv (IO ())))
  (mb-listen ske)
  (bracket
   make-tmpfile
   cleanup-tmpfile
   (\ tmpfile
     (do (<- in-mv newEmptyMVar)
         (start-listener mb-listen in-mv)
         (<- eval-tid
           (forkIO (void (runSkc (eval-loop tmpfile in-mv) ske))))
         (let ((= rpl (read-print-loop in-mv eval-tid))
               (= reader (runInputT defaultSettings rpl))))
         (run-repl reader initial-repl-state)))))

;;; Return a file path for temporary use.
(defn (make-tmpfile (IO FilePath))
  ()
  (do (<- dir getTemporaryDirectory)
      (<- (, name hdl) (openTempFile dir "sk-repl-.out"))
      (hClose hdl)
      (return name)))

;;; Start listner in separate thread, and return temporary file for
;;; getting String output from statement.
(defn (start-listener (-> (Maybe Int) (MVar Input) (IO ())))
  (mb-listen in-mv)
  (maybe (return ())
         (\ port
           (do (putStrLn (++ "Listening on port " (show port)))
               (void (forkIO (listener (fromIntegral port) in-mv)))))
         mb-listen))

;; Clean up temporary file, if the server was started with listener.
(defn (cleanup-tmpfile (-> FilePath (IO ())))
  (tmpfile)
  (catch (removeFile tmpfile)
    (\ e (if (isDoesNotExistError e)
             (return ())
             (throwIO e)))))


;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(defn (read-print-loop (-> (MVar Input) ThreadId (InputT Repl ())))
  (to-mvar eval-tid)
  (let ((= print-io result-mv
          (do (<- result (liftIO (takeMVar result-mv)))
              (case result
                (Right str) (>> (outputStr str)
                                (outputStr "\n"))
                (Left str) ((if (isSuffixOf "\n" str)
                                outputStr
                                outputStrLn)
                            str))
              (liftIO (hFlush stdout))))
        (= go result-mv
          (do (<- st0 (lift get-repl-state))
              (let ((= prompt
                      (if (null (pending-input st0)) "> " ""))))
              (<- mb-input
                ;; Handle interrupt signals thrown while waiting for
                ;; input, to handle `Ctrl-C' key presses without valid
                ;; evaluation form, and refresh intermediate user inputs
                ;; in Repl state.
                (handleInterrupt
                 (lift (do (<- st1 get-repl-state)
                           (put-repl-state (st1 {pending-input []}))
                           (return (Just []))))
                 (getInputLine prompt)))
              (case mb-input
                (Just line) (| ((== line "(quit)") quit)
                               ((null line) (go result-mv))
                               (otherwise (go' result-mv line)))
                Nothing quit)))
        (= go' result-mv line
          (do (<- mb-form (lift (read-form line)))
              (case mb-form
                (Just form)
                (do (liftIO
                     (putMVar to-mvar (Input Prompt form result-mv)))
                    (print-io result-mv)
                    (go result-mv))
                Nothing (go result-mv))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop result-mv
          (handleInterrupt
           (do (throwTo eval-tid UserInterrupt)
               (print-io result-mv)
               (loop result-mv))
           (go result-mv))))

    ;; Print the result from boot expression, then start the loop.
    (withInterrupt
     (do (<- result-mv (liftIO newEmptyMVar))
         (liftIO
          (putMVar to-mvar (Input Prompt init-form result-mv)))
         (print-io result-mv)
         (loop result-mv)))))

;;; Form to initialize the REPL.
(defn (init-form Code)
  ()
  '(begin
    (require Prelude)
    (require SK.Prelude)
    (require SK.Repl.Env)
    (require SK.Repl.Macro)
    (putStr
     "REPL ready, hit `Ctrl-d' or type `(quit)' to exit.")))

;;; Read single S-expression form.
(defn (read-form (-> String (Repl (Maybe Code))))
  (input0)
  (do (<- st get-repl-state)
      (let ((= input1
              (++ (pending-input st)
                  [(toLazyByteString (stringUtf8 (: \\n input0)))]))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret))))
        (case (evalSP sexpr (Just "<repl>") (BS.concat input1))
          (Right forms) (put-and-return [] (Just forms))
          (Left _err)   (put-and-return input1 Nothing)))))


;;; Eval loop

(defn (eval-loop (-> FilePath (MVar Input) (Skc ())))
  (tmpfile in-mvar)
  (let ((= initialize
          ;; Default target in interactive context is `HscAsm',
          ;; updating to `HscInterpreted'.  Also, `dynamic' option is
          ;; enabled in REPL.
          (do (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))
                    (= dflags2 (addWay' WayDyn dflags1))))
              (void (setSessionDynFlags dflags2))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (putTheHscEnv session))))
        (= withAsyncHandler
          (ghandle
           (\ e
             (do (liftIO
                  (case e
                    UserInterrupt (return ())
                    ThreadKilled  (return ())
                    _             (putStrLn
                                   (++ "eval-loop: got " (show e)))))
                 loop))))
        (= withSkHandler m
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))
        (= eval-one
          (do (<- (Input itype form out-mv)
                (liftIO (takeMVar in-mvar)))
              (<- ret (withSkHandler
                       (do (<- expanded (expands [form]))
                           (eval-form tmpfile itype expanded))))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (do (putTheHscEnv session)
                          (putMVar out-mv ret)))))
        (= loop
          (withAsyncHandler (>> eval-one loop)))
        (= post-eval-init next
          (do eval-one
              set-repl-print-name
              next)))
    (do initialize
        (post-eval-init loop))))

(defn (eval-form (-> FilePath InputType [Code] (Skc Result)))
  (tmpfile itype forms)
  (| ((null forms)
      (return (Right "")))
     ((<- (Right decls) (evalBuilder parseTopDecls forms))
      (eval-decls decls))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement tmpfile itype stmt))
     (otherwise
      (case (evalBuilder parseImports forms)
        (Right idecl) (eval-imports idecl)
        (Left err) (return (Left (++ err "\n")))))))

(defn (eval-statement (-> FilePath InputType HStmt (Skc Result)))
  (tmpfile itype stmt0)
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, is h f)) (update-hsc-env tmpfile itype hsc-env is h f)
        Nothing (return (Left "eval-statement: no result")))))

(defn (eval-imports (-> [HImportDecl] (Skc Result)))
  (imports)
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= mdls
              (++ "; " (intercalate ", "
                                    (map (. (showSDoc dflags) ppr)
                                         imports))))))
      (setContext (nubBy eq-ii (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(defn (eval-decls (-> [HDecl] (Skc Result)))
  (decls)
  (do (<- (, tythings _ic) (evalDecls decls))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr
                      (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystrs (foldr show-tything [] tythings))
            (= tystr (intercalate "\n" tystrs))))
      (return (Right tystr))))

(defn (update-hsc-env (-> FilePath InputType HscEnv [Id] ForeignHValue
                          FixityEnv (Skc Result)))
  (tmpfile itype hsc-env ids hvals-io fixity-env)
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its implementation.
  (let ((= success fhvals ret
          (do (let ((= ic (hsc_IC hsc-env))
                    (= ic2 (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic_fix_env fixity-env}))
                    (= names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
              (<- dflags getSessionDynFlags)
              (liftIO (extendLinkEnv (zip names fhvals)))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (case names
                [name] (| ((== (occNameString (nameOccName name)) "it")
                           (return (Right ret))))
                _ (return
                    (Right (names-and-types dflags names ids))))))
        (= exception serialized
          (case serialized
            (EOtherException str) (return (Left str))
            (EExitCode ecode)     (liftIO (exitWith ecode))
            EUserInterrupt        (return (Left "Interrupt"))))
        (= incomplete
          (return (Left "update-hsc-env failed.")))
        (= eval-hvals-io
          (evalStmt hsc-env False (EvalThis hvals-io)))
        (= eval-for-prompt
          (do (<- stat (liftIO eval-hvals-io))
              (return (, stat ""))))
        (= eval-for-connection
          (liftIO (with-io-redirect tmpfile eval-hvals-io))))
    (do (<- (, status ret)
          ;; Switching behaviour between prompt and network
          ;; connection. Getting printed result as `String' for
          ;; connection by wrapping the execution of compiled result,
          ;; which is a value of `IO [HValue]' type.
          (case itype
            Prompt eval-for-prompt
            Connection eval-for-connection))
        (case status
          (EvalComplete _ (EvalSuccess hvs)) (success hvs ret)
          (EvalComplete _ (EvalException e)) (exception e)
          _                                  incomplete))))


;;; Auxiliary

(defn (var-name-and-type (-> DynFlags Name Var String))
  (dflags name var)
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (intercalate "\n"
                     (map (++ "; ")
                          (lines (++ nstr (++ " :: " typ))))))))

(defn (names-and-types (-> DynFlags [Name] [Var] String))
  (dflags names vars)
  (where (| ((all null tvs) "")
            (otherwise (intercalate "\n" tvs)))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))

(defn (eq-ii (-> InteractiveImport InteractiveImport Bool))
  (a b)
  (case (, a b)
    (, (IIModule x) (IIModule y)) (== x y)
    (, (IIDecl x) (IIDecl y))     (== (unLoc (ideclName x))
                                      (unLoc (ideclName y)))
    _                             False))
