;;;; Fundamental macros and functions.

(module SK.Macro)

(require Language.SK.GHC)
(require Language.SK.Macro)
(require Language.SK.Make)

(import Language.SK)
(import Language.SK.GHC)
(import Language.SK.Macro)
(import Language.SK.Make)

(require System.Directory)
(import System.Directory)

(require Data.List)
(import Data.List)

(require System.FilePath)
(import System.FilePath)


;;; Macro to specify the phase of body contents evaluation.
(define-macro eval-when form
  (let ((= compile? (elem 'compile))
        (= load? (elem 'load)))
    (case (unLocLForm form)
      (List (: _ (: (LForm (L _ (List phases))) body)))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@body)
               ,@body)))
         ((compile? phases)
          (return `(eval-when-compile ,@body)))
         ((load? phases)
          (return `(begin ,@body)))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

;;; Functions used for defining macros in this file.
(eval-when (compile load)
  (:: car (-> Code Code))
  (= car (LForm (L l code))
    (case code
      (List (: x _xs)) x
      _                (LForm (L l (List [])))))

  (:: cdr (-> Code Code))
  (= cdr (LForm (L l code))
    (case code
      (List (: x xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                        (case xs
                          []      (LForm (L l' (List [])))
                          (: y _) (LForm (L l' (List xs)))))
      _               (LForm (L l (List [])))))

  (:: cons (=> (Codish a) (-> a Code Code)))
  (= cons x (LForm (L l0 xs))
    (let ((= x' (toCode x))
          (= l1 (getLoc (unLForm x'))))
      (LForm (case xs
               (List xs') (L l1 (List (: x' xs')))
               _          (L l1 (List [x'])))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((= codes (map (\ arg (cons 'toCode (cons arg '()))))))
    (case (unLocLForm form)
      (List (: _ args)) (return `(foldr cons '() [,@(codes args)]))
      _                 (skSrcError form "list: invalid args"))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (let ((= make-body name arg body
          (case (unLForm arg)
            (L l1 (List arg')) (list-arg l1 name arg' body)
            (L l1 (Atom arg')) (atom-arg name arg body)
            _                  (merr "defmacro*: invalid args")))
        (= atom-arg name arg body
          (let ((= arg'
                  (| ((== arg '()) '_unused)
                     (otherwise    arg))))
            (return
              `(define-macro ,name *form*
                 ,(if (== arg '())
                      body
                      `(case *form*
                         (LForm (L _ (List (: _ ,arg)))) ,body))))))
        (= list-arg l1 name arg body
          (let ((= hlist xs
                  (LForm (L l1 (HsList xs))))
                (= err
                  `(skSrcError *form*
                               (concat
                                [(show ',name) [\lf]
                                 "invalid args: `"
                                 (show *form*) "'"])))
                (= abind
                  (list 'LForm
                        (list 'L '_loc
                              (list 'List (hlist (: '_ arg))))))
                (= body2
                  (list 'define-macro name '*form*
                        (list 'case '*form*
                              abind body
                              '_ err))))
            (return body2)))
        (= merr label
          (skSrcError form label)))
    (case (unLocLForm form)
      (List [_ name arg body]) (make-body name arg body)
      _                        (merr "defmacro*: invalid form"))))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return (list 'defmacro* name args
                (list 'return body0))))

;;; Macro for defining simple function, or, an alias of `='. This macro
;;; preserves the location of function name, arguments, and body.
(define-macro defn form
  (case (unLocLForm form)
    (List [_ name args body]) (return `(= ,name ,@args ,body))
    _                         (skSrcError form
                                          (++ "`defn': invalid form:\n"
                                              (show form)))))

;;; Macro for defining function and type signature in single form.
(defmacro defn: (name tsig args body)
  `(begin
     (:: ,name ,tsig)
     (= ,name ,@args
       ,body)))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand x))
                         (return `',expanded))))
    _            (skSrcError form (++ "macroexpand: invalid form\n"
                                      (show form)))))

;;; Show names of macro as list of strings.
(defmacro* macro-names ()
  (do (<- mes getEnvMacros)
      (return `(list ,@(macroNames mes)))))

;;; The `cond' macro, found in many Lisp languages.  The behaviour is
;;; same as wrapping the body with `case' expression with dummy unit, or
;;; `if' with `MultiWayIf' GHC language extension.
(defmacro cond body
  `(case ()
     _ (| ,@body)))


;;; Repl macros

(eval-when (compile load)
  (:: %compile-obj (-> String (Skc Code)))
  (= %compile-obj str
    (gbracket (do (liftIO initStaticOpts)
                  getSessionDynFlags)
              setSessionDynFlags
              (\ dflags
                (do (setSessionDynFlags (dflags {hscTarget HscAsm}))
                    (make [(, str Nothing)] False Nothing)
                    (return `(begin))))))

  (:: %link-module (-> FastString (Skc Code)))
  (= %link-module name
    (do (<- hsc-env getSession)
        (let ((= name' (unpackFS name))
              (= mname (mkModuleNameFS name))))
        (liftIO (do (unload hsc-env [])
                    (linkModule hsc-env (Module mainUnitId mname))))
        (return '(begin))))

  (:: %compile-and-import (-> FilePath (Skc Code)))
  (= %compile-and-import path
    (do (let ((= mname (asModuleName path))))
        (%compile-obj path)
        (%link-module (fsLit mname))
        (return `(import ,(aSymbol mname))))))

;;; Compile source code file to object code.
(defmacro* compile-obj (form)
  (maybe (skSrcError form (++ "compile-obj: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-obj: " file)))
               (%compile-obj file)))
         (fromCode form)))

;;; Link the object code of given module.
(defmacro* link-module (form)
  (let ((= go name
          (do (liftIO (putStrLn (++ "; link-module: " (unpackFS name))))
              (%link-module name)))
        (= err
          (skSrcError form (++ "link-module: not a symbol: "
                               (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (go sym)
      _                    err)))

;;; Compile module source code file to object code, then link it, and
;;; then import the compiled module.
(defmacro* compile-file (form)
  (maybe (skSrcError form (++ "compile-file: not a FilePath: "
                              (show form)))
         (\ file
           (do (liftIO (putStrLn (++ "; compile-file: " file)))
               (%compile-and-import file)))
         (fromCode form)))

;;; Load a module source code file. Handles both absolute paths and
;;; relative paths from import directories.
(defmacro* load-file (form)
  (let ((= find-file idirs path0
          (if (isAbsolute path0)
              (find-absolute idirs path0)
              (%compile-and-import path0)))
        (= find-absolute dirs path
          (case dirs
            (: dir dirs') (find-absolute' dir dirs' path)
            []            (cant-find-err path)))
        (= find-absolute' dir dirs path
          (do (<- dir' (if (== dir ".")
                           (liftIO getCurrentDirectory)
                           (return dir)))
              (find-file dirs (makeRelative dir' path))))
        (= cant-find-err file
          (skSrcError form (++ "load-file: cannot find: " file))))
    (maybe (skSrcError form (++ "load-file: not a FilePath: "
                                (show form)))
           (\ path
             (do (liftIO (putStrLn (++ "; load-file: " path)))
                 (<- dflags getSessionDynFlags)
                 (find-file (importPaths dflags) path)))
           (fromCode form))))

(defmacro* set-verbosity (form)
  (let ((= go n
          (do (<- dflags getSessionDynFlags)
              (setSessionDynFlags (dflags {verbosity n}))
              (return `(begin))))
        (= err
          (skSrcError form "set-verbosity: expecting int.")))
    (case (unLocLForm form)
      (Atom (AInteger n)) (go (fromInteger n))
      _                   err)))

(eval-when (compile load)
  (:: show-context (Skc ()))
  (= show-context
    (where (do (<- context getContext)
               (<- dflags getSessionDynFlags)
               (liftIO (putStrLn "\n; context:"))
               (liftIO (mapM_ (printContext dflags)
                              context)))
      (= printContext dflags ctx
        (case ctx
          (IIDecl decl)    (putStrLn (++ ";  IIDecl: "
                                         (showSDoc dflags (ppr decl))))
          (IIModule mname) (putStrLn (++ ";  IIModule: "
                                         (moduleNameString mname)))))))
  (:: show-paths (Skc ()))
  (= show-paths
    (do (<- dflags getDynFlags)
        (liftIO
         (do (<- cwd getCurrentDirectory)
             (putStrLn "\n; current working directory: ")
             (putStrLn (++ ";   " cwd))
             (let ((= ipaths (importPaths dflags))))
             (putStrLn "; module import search paths: ")
             (if (null ipaths)
                 (putStrLn ";   none")
                 (mapM_ (\ ipath
                          (putStrLn (++ ";   " ipath)))
                        ipaths)))))))

(defmacro* info (form)
  (let ((= go sym
          (case (unpackFS sym)
            "context" show-context
            "paths"   show-paths
            _         err))

        (= err
          (skSrcError form (++ "info: invalid form: " (show form)))))
    (case (unLocLForm form)
      (Atom (ASymbol sym)) (do (liftIO initStaticOpts)
                               (go sym)
                               (return '(begin)))
      _                    err)))
