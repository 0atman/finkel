;;;; Fundamental macros and functions.

(module SK.Macro)

(require Language.SK.Macro)
(require Language.SK.Run)

(require Control.Monad.IO.Class)
(require GhcMake)
(require StaticFlags)
(require Language.SK.GHC)
(require Language.SK.Make)

(import Language.SK)
(import Language.SK.Macro)
(import Language.SK.Run)

(import Control.Monad.IO.Class)
(import GhcMake)
(import StaticFlags)
(import Language.SK.GHC)
(import Language.SK.Make)


;;; Macro to specify the phase of body contents evaluation.
(define-macro eval-when form
  (let ((= compile? (elem 'compile))
        (= load? (elem 'load)))
    (case (unLForm form)
      (L _ (List (: _ (: (LForm (L _ (List phases))) body))))
      (| ((&& (compile? phases) (load? phases))
          (return
            `(begin
               (eval-when-compile
                ,@body)
               ,@body)))
         ((compile? phases)
          (return `(eval-when-compile ,@body)))
         ((load? phases)
          (return `(begin ,@body)))
         (otherwise
          (skSrcError form (++ "eval-when: invalid phase: "
                               (show phases)))))
      _ (skSrcError form (++ "eval-when: invalid form: "
                             (show form))))))

;;; Functions used for defining macros in this file.
(eval-when (compile load)
  (:: car (-> Code Code))
  (= car (LForm (L l code))
    (case code
      (List (: x _xs)) x
      _                (LForm (L l (List [])))))

  (:: cdr (-> Code Code))
  (= cdr (LForm (L l code))
    (case code
      (List (: x xs)) (let ((= l' (getLoc (mkLocatedForm xs))))
                        (case xs
                          []      (LForm (L l' (List [])))
                          (: y _) (LForm (L l' (List xs)))))
      _               (LForm (L l (List [])))))

  (:: cons (=> (Codish a) (-> a Code Code)))
  (= cons x (LForm (L l0 xs))
    (let ((= x' (toCode x))
          (= l1 (getLoc (unLForm x'))))
      (LForm (case xs
               (List xs') (L l1 (List (: x' xs')))
               _          (L l1 (List [x'])))))))

;;; Below `list' is defined as macro, since Haskell does not support
;;; vararg function (actually, vararg is doable in GHC, but requires
;;; some language extensions).
(define-macro list form
  (let ((= codes (map (\ arg (cons 'toCode (cons arg '()))))))
    (case (unLocLForm form)
      (List (: _ args)) (return `(foldr cons '() [,@(codes args)]))
      _                 (skSrcError form "list: invalid args"))))

;;; The `defmacro*' macro, a macro to define macro in `Skc' monad. The
;;; body expression should be a value of type `Skc a'.
(define-macro defmacro* form
  (let ((= make-body name arg body
          (case (unLForm arg)
            (L l1 (List arg')) (list-arg l1 name arg' body)
            (L l1 (Atom arg')) (atom-arg name arg body)
            _                  (merr "defmacro*: invalid args")))
        (= atom-arg name arg body
          (let ((= arg'
                  (| ((== arg '()) '_unused)
                     (otherwise    arg))))
            (return
              `(define-macro ,name ,arg'
                 ,body))))
        (= list-arg l1 name arg body
          (let ((= hlist xs
                  (LForm (L l1 (HsList xs))))
                (= err
                  `(skSrcError *form*
                               (concat
                                [(show ',name) [\lf]
                                 "invalid args: `"
                                 (show *form*) "'"])))
                (= abind
                  (list 'LForm
                        (list 'L '_loc
                              (list 'List (hlist (: '_ arg))))))
                (= body2
                  (list 'define-macro name '*form*
                        (list 'case '*form*
                              abind body
                              '_ err))))
            (return body2)))
        (= merr label
          (skSrcError form label)))
    (case (unLocLForm form)
      (List [_ name arg body]) (make-body name arg body)
      _                        (merr "defmacro*: invalid form"))))

;;; The `defmacro' macro, similar to the macro with same name found in
;;; other Lisps, such as Commmon Lisp, Clojure, LFE, Hy
;;; ... etc. Currently does not suuport lambda-list like pattern match
;;; in macro argument.
(defmacro* defmacro (name args body0)
  (return (list 'defmacro* name args
                (list 'return body0))))

;;; Macro for defining simple function, or, an alias of `='. This macro
;;; preserves the location of function name, arguments, and body.
(define-macro defn (LForm (L l form'))
  (case form'
    (List [_ name args body]) (return `(= ,name ,@args ,body))
    _ (skSrcError (LForm (L l form'))
       (++ "`defn': invalid form:\n" (show (LForm (L l form')))))))

;;; Macro for defining function and type signature in single form.
(defmacro defn: (name tsig args body)
  `(begin
     (:: ,name ,tsig)
     (= ,name ,@args
       ,body)))

;;; Macro for expanding macro. This version of `macroexpand' recursively
;;; expands all sub forms.
(defmacro* macroexpand (form)
  (case (unLocLForm form)
    (List [q x]) (| ((|| (== q 'quote) (== q 'quasiquote))
                     (do (<- expanded (expand x))
                         (return `',expanded))))
    _            (skSrcError form (++ "macroexpand: invalid form\n"
                                      (show form)))))

;;; Show names of macro as list of strings.
(defmacro* macro-names ()
  (do (<- mes getEnvMacros)
      (return `(list ,@(macroNames mes)))))

;;; Compile file, and then import the compiled result.
(defmacro* compile-file (form)
  ;; XXX: Re-compiling same file in single REPL session not working yet.
  (let ((= compile-and-load file
          (do (liftIO (do initStaticOpts
                          (putStrLn (++ "; compile-file: " file))))
              (<- dflags getSessionDynFlags)
              (setSessionDynFlags (dflags {hscTarget HscAsm
                                           ghcLink LinkBinary}))
              (make [(, file Nothing)] True Nothing)
              (setSessionDynFlags dflags)
              (return `(import ,(aSymbol (asModuleName file))))))
        (= err
          (skSrcError form (++ "compile-file: got " (show form)))))
    (case (fromCode form)
      (Just file) (compile-and-load file)
      Nothing     err)))
