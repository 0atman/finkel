;;;; | Main module for SK read-eval-print-loop.
;;;;
;;;; This module contains `replMain', the main entry point for SK REPL.
;;;; Most of the functionality of SK REPL is borrowed from modules from
;;;; GHC, and a few form GHCi.
;;;;
;;;; Since ghc 8.0.1, implementation of GHCi has changed to RemoteGHCi,
;;;; described in detail below:
;;;;
;;;;   https://ghc.haskell.org/trac/ghc/wiki/RemoteGHCi
;;;;
;;;; It might worth understanding the detail of the implementation to
;;;; support implementing some unusual functionalities such as `apply',
;;;; `compile-file', `load', `apropos', ... etc.

(require SK.Macro)
(require SK.Repl.Macro)

(module SK.Repl)

(import Control.Concurrent)     ; base
(import Control.Exception)
(import Control.Monad)
(import Control.Monad.IO.Class)
(import Data.List)
(import Data.IORef)
(import Data.Version)
(import System.Exit)
(import System.IO)
(import Unsafe.Coerce)

(import GhcMonad)               ; ghc
(import HscMain)
(import HscTypes)
(import Id)
(import InteractiveEval)
(import Linker)
(import Name)
(import Outputable)
(import TcRnDriver)
(import Var)

(import GHCi)                   ; ghci
(import GHCi.Message)
(import GHCi.RemoteTypes)

(import System.Console.Haskeline) ; haskeline

(import SK.Core)                ; sk-core
(import SK.Core.Builder)
(import SK.Core.GHC)
(import SK.Core.Run)
(import SK.Core.Lexer)
(import SK.Core.Macro)
(import SK.Core.Reader)
(import SK.Core.Syntax)

(import Control.Monad.Trans.Class) ; transformers
(import Control.Monad.Trans.State.Strict)

(import Paths_sk_repl)          ; internal
(import SK.Repl.Orphan)
(import SK.Repl.Apply)


;;;; Types

;;; At the moment, there is no support for GeneralizedNewtypeDeriving.
;;; Adding support for generalized newtype deriving means adding support
;;; for pragmas, and inspecting the pragmas from SK module source code
;;; during compilation.

;;; State for repl.
(data ReplState
  (ReplState {pendingInput String
              inputCount Int})
  (deriving (Eq Show)))

(defn: initialReplState () (ReplState)
  (ReplState {pendingInput ""
              inputCount 0}))

;; Newtype wrapper to hold repl state.
(newtype (Repl a)
  (Repl {unRepl (StateT ReplState Skc a)}))

(instance (Functor Repl)
  (= (fmap f (Repl a)) (Repl (fmap f a))))

(instance (Applicative Repl)
  (= (pure a) (Repl (pure a)))
  (= (<*> (Repl f) (Repl a)) (Repl (<*> f a))))

(instance (Monad Repl)
  (= return pure)
  (= (>>= a k) (Repl (>>= (unRepl a) (. unRepl k)))))

(instance (MonadIO Repl)
  (= (liftIO io) (Repl (liftIO io))))

(derive-monad-exception () Repl Repl unRepl)

(defn: runRepl (repl st) (-> (Repl a) ReplState (Skc a))
  (evalStateT (unRepl repl) st))

(defn: putReplState (st) (-> ReplState (Repl ()))
  (Repl (put st)))

(defn: getReplState () (Repl ReplState)
  (Repl get))

(defn: liftRepl (m) (-> (Skc a) (Repl a))
  (Repl (lift m)))

;;; Synonym for result value used in Repl.
(type (Result a) (Either String a))


;;;; Auxiliary

(defn: bodyp ((L _ stmt)) (-> HStmt Bool)
  (case stmt
    ((BodyStmt _ _ _ _) True)
    (_ False)))

(:: print-names-and-types (-> DynFlags [Name] [Var] (IO ())))
(= (print-names-and-types dflags names vars)
  (mapM_ (\ ((, name var))
           (let ((= nstr (occNameString (nameOccName name)))
                 (= typ (showPpr dflags (varType var))))
             (unless (== nstr "it")
               (putStrLn (concat [";;; " nstr " :: " typ])))))
         (zip names vars)))



;;;; Read

;;; | Read a form. Keeps its previous input string, repeatedly consumes
;;; inputs until concatenated inputs is a valid S-expression.
(:: readForm (-> String (Repl (Maybe LCode))))
(= (readForm input0)
  (do (<- st getReplState)
      (let ((= input1 (++ (pendingInput st) (: \lf input0)))
            (= count (succ (inputCount st)))
            (= (putAndReturn pending ret)
              (do (putReplState (st {inputCount (succ (inputCount st))
                                     pendingInput pending}))
                  (return ret)))))
      (case (evalSP sexpr (Just "<<repl>>") input1)
        ((Right forms) (putAndReturn "" (Just forms)))
        ((Left err) (putAndReturn input1 Nothing)))))


;;;; Eval

;; See `runStmt' in "ghc/GHCi/UI.hs". It handles statement, import
;; declaration, and other declarations by testing whether parser
;; succeeded or not.
(:: evalForms (-> [LTForm Atom] (Repl ())))
(= (evalForms forms0)
  (let ((= work
          (do (<- forms1 (macroexpands forms0))
              (<- ret (withHandler (evalStatement forms1)))
              (case ret
                ((Right _) (return ()))
                ((Left err) (liftIO (putStrLn err))))))
        (= (withHandler m)
          (withSourceErrorHandling m)))
    (liftRepl work)))

(:: evalStatement (-> [LTForm Atom] (Skc (Result ()))))
(= (evalStatement forms)
  (case (evalBuilder parseStmt forms)
    ((Right stmt0)
     (do (<- hscenv getSession)
         (<- stmt1 (liftIO (hscParsedStmt hscenv stmt0)))
         (case stmt1
           ((Just (, ids fhv fixity))
            (update-hsc-env hscenv (bodyp stmt0) ids fhv fixity))
           (Nothing
            (return (Left "evalStatement: no ret"))))))
    ((Left _) (evalImport forms))))

(:: update-hsc-env (-> HscEnv Bool [Id] ForeignHValue FixityEnv
                       (Skc (Result ()))))
(= (update-hsc-env hsc-env is-body ids hvals-io fixity-env)
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its body.
  (do (<- status (liftIO (evalStmt hsc-env False (EvalThis hvals-io))))
      (<- dflags getSessionDynFlags)
      (case status
        ((EvalComplete _ (EvalSuccess fhvals))
         (do (let ((= ic (hsc_IC hsc-env))
                   (= bindings (, (ic_tythings ic) (ic_rn_gbl_env ic)))
                   (= size 10)
                   (= ic2 (extendInteractiveContextWithIds ic ids))
                   (= ic3 (ic2 {ic_fix_env fixity-env}))
                   (= final-names (map getName ids))
                   (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
             (liftIO
              (do (let ((= name-alist (zip final-names fhvals))))
                  (extendLinkEnv name-alist)
                  (print-names-and-types dflags final-names ids)))
             (when is-body
               (case ids
                 ([] (return ()))
                 ((: var _)
                  (do (let ((= tystr (showPpr dflags (varType var)))))
                      (when (isPrefixOf "ReplIO" tystr)
                        (evalApply hsc-env-2 fhvals))))))

             ;; InteractiveEval does not export rttiEnvironment ...
             ;;
             ;; (<- hsc-env-3
             ;;     (liftIO
             ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

             (setSession hsc-env-2)
             (return (Right ()))))
        ((EvalComplete _ (EvalException serialized))
         (case serialized
           ((EOtherException str) (return (Left str)))
           ((EExitCode ecode) (liftIO (exitWith ecode)))
           (EUserInterrupt (return (Right ())))))
        (_
         (return (Left "update-hsc-env failed."))))))

(:: evalApply (-> HscEnv [ForeignHValue] (Skc ())))
(= (evalApply hsc-env replio-frefs)
  (do (<- session (fromGhc (Ghc return)))
      (case replio-frefs
        ([replio-fref]
         (do (<- hval (liftIO (withForeignRef replio-fref localRef)))
             (let ((= replio (unsafeCoerce hval))))
             (liftIO (void (forkIO (runReplIO session replio))))))
        (_
         (liftIO (putStrLn "evalApply: ambiguous ForeignHValue."))))))

(:: runReplIO (-> Session (ReplIO a) (IO ())))
(= (runReplIO (Session session) replio)
  (do (<- hsc-env (readIORef session))
      (let ((= lrdr-name (noLoc (mkRdrName (replIoName replio))))))
      (<- (: name _) (hscTcRnLookupRdrName hsc-env lrdr-name))
      (<- f-fref (getHValue hsc-env name))
      (<- f-hv (withForeignRef f-fref localRef))
      ;; Signature of `tcRnExpr' changed since ghc-8.0.2 release.
      (<- (, msg f-ty) (tcRnExpr hsc-env (noLoc (HsVar lrdr-name))))
      (case f-ty
        ((Just ty)
         (do (let ((= tystr (showPpr (hsc_dflags hsc-env) ty))))
             ;; XXX: Adhoc detection of ReplIO type, supports (ReplIO
             ;; Int) only. Want to generalize the detection of the
             ;; result type with ReplIO constructor.
             (if (isSuffixOf "(ReplIO Int)" tystr)
                 ;; Run the body of `f', then recursively call
                 ;; `runReplIO' with the returned value of `f'.
                 (do (let ((= f (unsafeCoerce f-hv))))
                     (<- replio' (f (replIoArgs replio)))
                     (runReplIO (Session session) replio'))
                 ;; Not a ReplIO, run once and done.
                 ((unsafeCoerce f-hv) (replIoArgs replio)))))
        (Nothing
         (putStrLn "runReplIO: no type info.")))))

(:: evalImport (-> [LTForm Atom] (Skc (Result ()))))
(= (evalImport forms)
  (case (evalBuilder parseImports forms)
    ((Right imports)
     (do (<- context getContext)
         (liftIO (mapM_ (. putStrLn (. (++ ";;; ") (. show unLocForm)))
                        forms))
         (let ((= (mkIIdecl (L _ idecl)) (IIDecl idecl))))
         (setContext (++ (map mkIIdecl imports) context))
         (return (Right ()))))
    ((Left err) (evalDecls forms))))

;;; Evaluate declarations. Can handle multiple declarations wrapped as
;;; `begin' form.
;;;
;;; Some relevant codes:
;;;
;;;  * ghc/GHCi/UI/Monad.hs: runDecls
;;;
;;;  * compiler/main/InteractiveEval.hs: runDeclsWithLocaton,
;;;    rttinvironment, handleRunstatus
;;;
;;;  * compiler/main/HscMain.hs: hscDeclsWithLocation
;;;
;;;  * compiler/main/HscTypes.hs: extendInteractiveContextWithIds
;;;
;;;  * libraries/ghci/GHCi/Run.hs: various command responding to
;;;    messages, extensively using RemoteRef.
;;;
(:: evalDecls (-> [LTForm Atom] (Skc (Result ()))))
(= (evalDecls forms)
  (case (evalBuilder parseDecls forms)
    ((Right decls)
     ;; Currently decls are converted as `let' statement and passed to
     ;; `hscParsedStmt'. Support for `data', `newtype', `class' .. etc
     ;; are not yet implemented.
     (do (let ((= l (mkLocatedList decls))
               (= stmt (b_letS l decls))))
         (<- hsc-env getSession)
         (<- ret (liftIO (hscParsedStmt hsc-env stmt)))
         (case ret
           ((Just (, ids hvals fixity))
            (update-hsc-env hsc-env False ids hvals fixity))
           (Nothing
            (return (Left (++ "evalDecls: "
                              (show (map unLocForm forms)))))))))
    ((Left err) (return (Left err)))))



;;;; Loop

;;; See `HscTypes.runInteractiveHsc'.
(:: initRepl (Repl ()))
(= initRepl
  (liftRepl
   (do (<- hsc_env getSession)
       (void (setSessionDynFlags (ic_dflags (hsc_IC hsc_env))))
       (let ((= decl (. IIDecl (. simpleImportDecl mkModuleName)))))
       (setContext [(decl "Prelude")
                    (decl "SK.Core")
                    (decl "SK.Repl.Apply")]))))

(:: loop (InputT Repl ()))
(= loop
  (do (<- st (lift getReplState))
      (let ((= prompt (| ((null (pendingInput st)) "> ")
                         (otherwise "")))))
      (<- mb-input (getInputLine prompt))
      (case mb-input
        (Nothing (return ()))
        ((Just str)
         (| ((== str "(quit)") (return ()))
            ((null str) loop)
            (otherwise
             (do (<- mb-form (lift (readForm str)))
                 (case mb-form
                   (Nothing (return ()))
                   ((Just form) (lift (evalForms [form]))))
                 loop)))))))

(:: skRepl (InputT Repl ()))
(= skRepl
  (let ((= lp
          (handleInterrupt (>> (outputStrLn "Cancelled.") lp)
                           loop)))
    (do (lift initRepl)
        (withInterrupt lp))))


;;;; Main

(:: replMain (IO ()))
(= replMain
  (let ((= go
          (do (let ((= repl (runInputT defaultSettings skRepl))
                    (= skc (runRepl repl initialReplState))))
              (<- ret (runSkc skc initialSkEnv))
              (case ret
                ((Right a) (return ()))
                ((Left err)
                 (>> (putStrLn (++ "replMain: error:" err)) go))))))
    (do (putStrLn
         (concat ["SK repl version " (showVersion version) ", "
                  "hit `Ctrl-d' to exit."]))
        go)))
