;;;; -*- mode: sk -*-
##(LANGUAGE GeneralizedNewtypeDeriving)

;;;; | Simple SK REPL.

;;; This implementation uses two threads: one for reading and printing,
;;; and another for evaluating and modifying the SkEnv. Using `MVar'
;;; containing `Code' to communicate between the threads. This design
;;; shall be easier to support reading forms from other sources than
;;; line oriented user input, e.g. network sockets.

(module SK.Repl)

(require SK.Core)

;; base
(import Control.Concurrent
        ((MVar) (ThreadId) forkIO killThread newEmptyMVar
                putMVar takeMVar))
(import Control.Monad (void))
(import Control.Monad.IO.Class ((MonadIO ..)))
(import Data.List (intercalate intersperse nubBy))
(import Data.Version (showVersion))
(import System.Exit (exitWith))
(import System.IO (hFlush stdout))

;; bytestring
(import Data.ByteString.Builder (stringUtf8 toLazyByteString))
(import (qualified Data.ByteString.Lazy.Char8 as BS))

;; haskeline
(import System.Console.Haskeline)

;; transformers
(import Control.Monad.Trans.Class)
(import Control.Monad.Trans.State.Strict)

;; sk-kernel
(import Language.SK)
(import Language.SK.Builder)
(import Language.SK.Eval)
(import Language.SK.GHC)
(import Language.SK.Lexer)
(import Language.SK.Reader)
(import Language.SK.Run)
(import Language.SK.Syntax)

;; internal
(import Paths_sk_repl)
(import SK.Repl.Env)
(import SK.Repl.GHC)


;;; Repl, state, and result types

(data ReplState
  (ReplState {pending-input [BS.ByteString]
              input-count Int})
  (deriving (Eq Show)))

(:: initial-repl-state (ReplState))
(= initial-repl-state
  (ReplState {pending-input [] input-count 0}))

(newtype (Repl a)
  (Repl {unRepl (StateT ReplState IO a)})
  (deriving (Functor Applicative Monad MonadIO MonadException)))

(:: run-repl (-> (Repl a) ReplState (IO a)))
(= run-repl repl st (evalStateT (unRepl repl) st))

(:: put-repl-state (-> ReplState (Repl ())))
(= put-repl-state st (Repl (put st)))

(:: get-repl-state (Repl ReplState))
(= get-repl-state (Repl get))

(:: lift-repl (-> (IO a) (Repl a)))
(= lift-repl m (Repl (lift m)))

(type Result (Either String String))


;;; Main

(defn (replMain (IO ()))
  ()
  (do (<- in-mv newEmptyMVar)
      (<- out-mv newEmptyMVar)
      (let ((= skc (runSkc (eval-loop in-mv out-mv) repl-env))))
      (<- eval-tid (forkIO (void skc)))
      (let ((= reader (read-print-loop in-mv out-mv eval-tid))
            (= reader' (runInputT defaultSettings reader))
            (= init-form
              '(begin
                (require SK.Prelude)
                (putStrLn "REPL ready, hit `Ctrl-d' to exit.")))))
      (putStrLn (++ "SK REPL " (showVersion version)))
      (putMVar in-mv init-form)
      (run-repl reader' initial-repl-state)))

(:: repl-env SkEnv)
(= repl-env (initialSkEnv {envContextModules ["SK.Prelude"]}))


;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(:: read-print-loop
  (-> (MVar Code) (MVar String) ThreadId (InputT Repl ())))
(= read-print-loop to-mvar from-mvar eval-tid
  (let ((= print-io
          (do (<- str (takeMVar from-mvar))
              (putStr str)
              (hFlush stdout)))
        (= go
          (do (<- st (lift get-repl-state))
              (let ((= prompt
                      (if (null (pending-input st))
                          "> "
                          ""))))
              (<- mb-input (getInputLine prompt))
              (case mb-input
                Nothing     quit
                (Just line) (| ((== line "(quit)") quit)
                               ((null line) go)
                               (otherwise (go' line))))))
        (= go' line
          (do (<- mb-form (lift (read-form line)))
              (case mb-form
                Nothing     go
                (Just form) (do (liftIO (do (putMVar to-mvar form)
                                            print-io))
                                go))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop
          (handleInterrupt
           (do (outputStrLn "Interrupd")
               loop)
           go)))
    ;; Print the result from boot expression, then start the loop.
    (do (liftIO print-io)
        (withInterrupt loop))))

;;; Read single S-expression form.
(:: read-form (-> String (Repl (Maybe Code))))
(= read-form input0
  (do (<- st get-repl-state)
      (let ((= input1
              (++ (pending-input st)
                  [(toLazyByteString (stringUtf8 (: \\n input0)))]))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret))))
        (case (evalSP sexpr (Just "<repl>") (BS.concat input1))
          (Right forms) (put-and-return [] (Just forms))
          (Left _err)   (put-and-return input1 Nothing)))))


;;; Eval

(:: eval-loop (-> (MVar Code) (MVar String) (Skc ())))
(= eval-loop in-mvar out-mvar
  (let ((= initialize
          ;; Default target in interactive context is `HscAsm',
          ;; updating to `HscInterpreted'.  Also, `dynamic' option is
          ;; enabled in REPL.
          (do (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))
                    (= dflags2 (addWay' WayDyn dflags1))))
              (void (setSessionDynFlags dflags2))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (putTheHscEnv session))))
        (= with-handler m
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))
        (= go (do (<- form (liftIO (takeMVar in-mvar)))
                  (<- ret (with-handler
                           (do (<- expanded (expands [form]))
                               (eval-form expanded))))
                  (let ((= str (case ret
                                 (Right r) r
                                 (Left err) err))))
                  (<- (Session session) (fromGhc (Ghc return)))
                  (liftIO (putTheHscEnv session))
                  (liftIO (putMVar out-mvar str))
                  go)))
    (>> initialize go)))

(:: eval-form (-> [Code] (Skc Result)))
(= eval-form forms
  (| ((null forms)
      (return (Right "")))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement stmt))
     ((<- (Right idecl) (evalBuilder parseImports forms))
      (eval-imports idecl))
     (otherwise
      (case (evalBuilder parseTopDecls forms)
        (Right decs) (eval-decls decs)
        (Left err)   (return (Left (concat [err "\n"])))))))

(:: eval-statement (-> HStmt (Skc Result)))
(= eval-statement stmt0
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, is h f)) (update-hsc-env hsc-env is h f)
        Nothing           (return (Left "eval-statement: no result")))))

(:: eval-imports (-> [HImportDecl] (Skc Result)))
(= eval-imports imports
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= mdls
              (concat ["; "
                       (intercalate ", " (map (. (showSDoc dflags) ppr)
                                              imports))
                       "\n"]))))
      (setContext (nubBy eq-ii (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(:: eval-decls (-> [HDecl] (Skc Result)))
(= eval-decls decls
  (do (<- (, tythings _ic) (evalDecls decls))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr
                      (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystrs (foldr show-tything [] tythings))
            (= tystr (unlines tystrs))))
      (return (Right tystr))))

(:: update-hsc-env
  (-> HscEnv [Id] ForeignHValue FixityEnv (Skc Result)))
(= update-hsc-env hsc-env ids hvals-io fixity-env
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its body.
  (let ((= success fhvals
          (do (let ((= ic (hsc_IC hsc-env))
                    (= ic2
                      (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic_fix_env fixity-env}))
                    (= final-names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
              (<- dflags getSessionDynFlags)
              (liftIO (extendLinkEnv (zip final-names fhvals)))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (return
                (Right
                 (show-names-and-types dflags final-names ids)))))
        (= exception serialized
          (case serialized
            (EOtherException str) (return (Left str))
            (EExitCode ecode)     (liftIO (exitWith ecode))
            EUserInterrupt        (return (Right "Interrupt"))))
        (= incomplete
          (return (Left "update-hsc-env failed."))))
    (do (<- status (liftIO
                    (evalStmt hsc-env False (EvalThis hvals-io))))
        (case status
          (EvalComplete _ (EvalSuccess hvs)) (success hvs)
          (EvalComplete _ (EvalException e)) (exception e)
          _                                  incomplete))))


;;; Auxiliary

(:: var-name-and-type (-> DynFlags Name Var String))
(= var-name-and-type dflags name var
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (concat
         (intersperse "\n"
                      (map (++ "; ")
                           (lines (++ nstr (++ " :: " typ)))))))))

(:: show-names-and-types (-> DynFlags [Name] [Var] String))
(= show-names-and-types dflags names vars
  (where (| ((all null tvs) "")
            (otherwise      (++ (concat (intersperse "\n" tvs)) "\n")))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))

(:: showContext (-> InteractiveImport String))
(= showContext ii
  (case ii
    (IIDecl idecl) (moduleNameString (unLoc (ideclName idecl)))
    (IIModule mdl) (moduleNameString mdl)))

(:: eq-ii (-> InteractiveImport InteractiveImport Bool))
(= eq-ii a b
  (case (, a b)
    (, (IIModule x) (IIModule y)) (== x y)
    (, (IIDecl x) (IIDecl y))     (== (unLoc (ideclName x))
                                      (unLoc (ideclName y)))
    _                             False))
