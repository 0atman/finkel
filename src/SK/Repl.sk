;;;; -*- mode: sk -*-
##(LANGUAGE GeneralizedNewtypeDeriving)

;;;; | Simple SK REPL.

;;; This implementation uses two threads: one for reading and printing,
;;; and another for evaluating and modifying the SkEnv. Using `MVar'
;;; containing `Code' to communicate between the threads. This design
;;; shall be easier to support reading forms from other sources than
;;; line oriented user input, e.g. network sockets.

(module SK.Repl)

(require SK.Core)
(require SK.Repl.Macro)

;; base
(import Control.Concurrent ((MVar) (ThreadId) forkIO killThread
                            newEmptyMVar putMVar takeMVar))
(import Control.Exception ((AsyncException ..)))
(import Control.Monad (void))
(import Control.Monad.IO.Class ((MonadIO ..)))
(import Data.List (intercalate intersperse isSuffixOf nubBy))
(import Data.Version (showVersion))
(import System.Exit (exitWith))
(import System.IO (hFlush stdout))

;; bytestring
(import Data.ByteString.Builder (stringUtf8 toLazyByteString))
(import qualified Data.ByteString.Lazy.Char8 as BS)

;; haskeline
(import System.Console.Haskeline)

;; transformers
(import Control.Monad.Trans.Class)
(import Control.Monad.Trans.State.Strict)

;; sk-kernel
(import Language.SK)
(import Language.SK.Builder)
(import Language.SK.Eval)
(import Language.SK.GHC)
(import Language.SK.Lexer)
(import Language.SK.Reader)
(import Language.SK.Run)
(import Language.SK.Syntax)
(import qualified Paths_sk_kernel)

;; internal
(import SK.Core)
(import SK.Repl.Env)
(import SK.Repl.GHC hiding (isGoodSrcSpan load))
(import SK.Repl.Macro)
(import qualified Paths_sk_lang)


;;; Repl, state, and result types

(data ReplState
  (ReplState {pending-input [BS.ByteString]
              input-count Int})
  (deriving (Eq Show)))

(:: initial-repl-state (ReplState))
(= initial-repl-state
  (ReplState {pending-input [] input-count 0}))

(newtype (Repl a)
  (Repl {unRepl (StateT ReplState IO a)})
  (deriving (Functor Applicative Monad MonadIO MonadException)))

(:: run-repl (-> (Repl a) ReplState (IO a)))
(= run-repl repl st (evalStateT (unRepl repl) st))

(:: put-repl-state (-> ReplState (Repl ())))
(= put-repl-state st (Repl (put st)))

(:: get-repl-state (Repl ReplState))
(= get-repl-state (Repl get))

(:: lift-repl (-> (IO a) (Repl a)))
(= lift-repl m (Repl (lift m)))

(type Result (Either String String))


;;; Main

(defdo (replMain (IO ()))
  ()
  (<- in-mv newEmptyMVar)
  (<- out-mv newEmptyMVar)
  (<- eval-tid
    (forkIO (void (runSkc (eval-loop in-mv out-mv) repl-env))))
  (let ((= reader (read-print-loop in-mv out-mv eval-tid))
        (= reader' (runInputT defaultSettings reader))
        (= init-form
          '(begin
            (require Prelude)
            (require SK.Prelude)
            (require SK.Repl.Env)
            (require SK.Repl.Macro)
            (putStrLn
             "REPL ready, hit `Ctrl-d' or type `(quit)' to exit.")))))
  (putStrLn
   (concat ["SK REPL (sk-lang " (showVersion Paths_sk_lang.version)
            ", sk-kernel " (showVersion Paths_sk_kernel.version)
            ")"]))
  (putMVar in-mv init-form)
  (run-repl reader' initial-repl-state))

(:: repl-env SkEnv)
(= repl-env
  (let ((= modules
          ["Prelude" "SK.Prelude" "SK.Repl.Env" "SK.Repl.Macro"])
        (= defaultMacros
          (mergeMacros specialForms replMacros)))
    (initialSkEnv {envContextModules modules
                   envDefaultMacros defaultMacros
                   envAddInDefineMacro True})))

;;; Default macros imported in REPL. These macros always get imported
;;; after loading compiled modules.
(macrolet* ((the-macros ()
              (return
                `[,@(map (\ mac `(, ,mac ,(aSymbol mac)))
                         (++ (exported-macros SK.Core)
                             (exported-macros SK.Repl.Macro)))])))
  (:: replMacros EnvMacros)
  (= replMacros
    (makeEnvMacros (the-macros))))


;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(:: read-print-loop
  (-> (MVar Code) (MVar Result) ThreadId (InputT Repl ())))
(= read-print-loop to-mvar from-mvar eval-tid
  (let ((= print-io
          (do (<- result (liftIO (takeMVar from-mvar)))
              (case result
                (Right str) (outputStr str)
                (Left str)  ((if (isSuffixOf "\n" str)
                                 outputStr
                                 outputStrLn)
                             str))
              (liftIO (hFlush stdout))))
        (= go
          (do (<- st0 (lift get-repl-state))
              (let ((= prompt
                      (if (null (pending-input st0))
                          "> "
                          ""))))
              (<- mb-input
                ;; Handle interrupt signals thrown while waiting for
                ;; input, to handle `Ctrl-C' key presses without valid
                ;; evaluation form, and refresh intermediate user inputs
                ;; in Repl state.
                (handleInterrupt
                 (lift (do (<- st1 get-repl-state)
                           (put-repl-state (st1 {pending-input []}))
                           (return (Just []))))
                 (getInputLine prompt)))
              (case mb-input
                Nothing     quit
                (Just line) (| ((== line "(quit)") quit)
                               ((null line) go)
                               (otherwise (go' line))))))
        (= go' line
          (do (<- mb-form (lift (read-form line)))
              (case mb-form
                Nothing     go
                (Just form) (do (liftIO (putMVar to-mvar form))
                                print-io
                                go))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop
          (handleInterrupt
           (do (throwTo eval-tid UserInterrupt)
               print-io
               loop)
           go)))
    ;; Print the result from boot expression, then start the loop.
    (withInterrupt (>> print-io loop))))

;;; Read single S-expression form.
(:: read-form (-> String (Repl (Maybe Code))))
(= read-form input0
  (do (<- st get-repl-state)
      (let ((= input1
              (++ (pending-input st)
                  [(toLazyByteString (stringUtf8 (: \\n input0)))]))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret))))
        (case (evalSP sexpr (Just "<repl>") (BS.concat input1))
          (Right forms) (put-and-return [] (Just forms))
          (Left _err)   (put-and-return input1 Nothing)))))


;;; Eval

(:: eval-loop (-> (MVar Code) (MVar Result) (Skc ())))
(= eval-loop in-mvar out-mvar
  (let ((= initialize
          ;; Default target in interactive context is `HscAsm',
          ;; updating to `HscInterpreted'.  Also, `dynamic' option is
          ;; enabled in REPL.
          (do (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))
                    (= dflags2 (addWay' WayDyn dflags1))))
              (void (setSessionDynFlags dflags2))
              (<- (Session session) (fromGhc (Ghc return)))
              (liftIO (putTheHscEnv session))))
        (= withAsyncHandler
          (ghandle
           (\ e
             (do (liftIO
                  (case e
                    UserInterrupt (return ())
                    ThreadKilled  (return ())
                    _             (putStrLn
                                   (++ "eval-loop: got " (show e)))))
                 go))))
        (= withSkHandler m
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))
        (= go
          (withAsyncHandler
           (do (<- form (liftIO (takeMVar in-mvar)))
               (<- ret (withSkHandler
                        (do (<- expanded (expands [form]))
                            (eval-form expanded))))
               (<- (Session session) (fromGhc (Ghc return)))
               (liftIO (do (putTheHscEnv session)
                           (putMVar out-mvar ret)))
               go))))
    (>> initialize go)))

(:: eval-form (-> [Code] (Skc Result)))
(= eval-form forms
  (| ((null forms)
      (return (Right "")))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement stmt))
     ((<- (Right idecl) (evalBuilder parseImports forms))
      (eval-imports idecl))
     (otherwise
      (case (evalBuilder parseTopDecls forms)
        (Right decs) (eval-decls decs)
        (Left err)   (return (Left (concat [err "\n"])))))))

(:: eval-statement (-> HStmt (Skc Result)))
(= eval-statement stmt0
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, is h f)) (update-hsc-env hsc-env is h f)
        Nothing           (return (Left
                                   "eval-statement: no result")))))

(:: eval-imports (-> [HImportDecl] (Skc Result)))
(= eval-imports imports
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= mdls
              (concat ["; "
                       (intercalate ", " (map (. (showSDoc dflags) ppr)
                                              imports))
                       "\n"]))))
      (setContext (nubBy eq-ii (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(:: eval-decls (-> [HDecl] (Skc Result)))
(= eval-decls decls
  (do (<- (, tythings _ic) (evalDecls decls))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr
                      (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystrs (foldr show-tything [] tythings))
            (= tystr (unlines tystrs))))
      (return (Right tystr))))

(:: update-hsc-env
  (-> HscEnv [Id] ForeignHValue FixityEnv (Skc Result)))
(= update-hsc-env hsc-env ids hvals-io fixity-env
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its body.
  (let ((= success fhvals
          (do (let ((= ic (hsc_IC hsc-env))
                    (= ic2
                      (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic_fix_env fixity-env}))
                    (= final-names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
              (<- dflags getSessionDynFlags)
              (liftIO (extendLinkEnv (zip final-names fhvals)))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (return
                (Right
                 (show-names-and-types dflags final-names ids)))))
        (= exception serialized
          (case serialized
            (EOtherException str) (return (Left str))
            (EExitCode ecode)     (liftIO (exitWith ecode))
            EUserInterrupt        (return (Left "Interrupt"))))
        (= incomplete
          (return (Left "update-hsc-env failed."))))
    (do (<- status (liftIO
                    (evalStmt hsc-env False (EvalThis hvals-io))))
        (case status
          (EvalComplete _ (EvalSuccess hvs)) (success hvs)
          (EvalComplete _ (EvalException e)) (exception e)
          _                                  incomplete))))


;;; Auxiliary

(:: var-name-and-type (-> DynFlags Name Var String))
(= var-name-and-type dflags name var
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (concat
         (intersperse "\n"
                      (map (++ "; ")
                           (lines (++ nstr (++ " :: " typ)))))))))

(:: show-names-and-types (-> DynFlags [Name] [Var] String))
(= show-names-and-types dflags names vars
  (where (| ((all null tvs) "")
            (otherwise      (++ (concat (intersperse "\n" tvs)) "\n")))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))

(:: showContext (-> InteractiveImport String))
(= showContext ii
  (case ii
    (IIDecl idecl) (moduleNameString (unLoc (ideclName idecl)))
    (IIModule mdl) (moduleNameString mdl)))

(:: eq-ii (-> InteractiveImport InteractiveImport Bool))
(= eq-ii a b
  (case (, a b)
    (, (IIModule x) (IIModule y)) (== x y)
    (, (IIDecl x) (IIDecl y))     (== (unLoc (ideclName x))
                                      (unLoc (ideclName y)))
    _                             False))
