;;;; | Main module for SK Read-Eval-Print-Loop.
;;;;
;;;; This module contains main function for SK REPL.

(module SK.Repl)

(import Control.Exception)      ; base
(import Control.Monad)
(import Control.Monad.IO.Class)
(import System.IO)

(import GhcMonad)               ; ghc
(import HscMain)
(import HscTypes)
(import Id)
(import InteractiveEval)
(import Linker)
(import Name)

(import GHCi)                   ; ghci
(import GHCi.RemoteTypes)

(import System.Console.Haskeline) ; haskeline

(import SK.Core)                ; sk-core
(import SK.Core.Builder)
(import SK.Core.GHC)
(import SK.Core.Run)
(import SK.Core.Lexer)
(import SK.Core.Macro)
(import SK.Core.Syntax)
(import SK.Core.TokenParser)

(import Control.Monad.Trans.Class) ; transformers
(import Control.Monad.Trans.State.Strict)

(import SK.Repl.Orphan)         ; Internal


;;; Types
;;; -----

;;; At the moment, there is no support for
;;; `GeneralizedNewtypeDeriving'. Adding support for generalized newtype
;;; deriving means adding support for pragmas, and inspecting the
;;; pragmas from SK module source code during compilation.

;;; State for repl.
(data ReplState
  (ReplState {pendingInput String
              inputCount Int})
  (deriving (Eq Show)))

(:: initialReplState ReplState)
(= initialReplState
  (ReplState {pendingInput ""
              inputCount 0}))

;; Newtype wrapper to hold repl state.
(newtype (Repl a) (Repl {unRepl (StateT ReplState Skc a)}))

(:: runRepl (-> (Repl a) ReplState (Skc a)))
(= (runRepl repl st) (evalStateT (unRepl repl) st))

(:: putReplState (-> ReplState (Repl ())))
(= (putReplState st) (Repl (put st)))

(:: getReplState (Repl ReplState))
(= getReplState (Repl get))

(:: liftRepl (-> (Skc a) (Repl a)))
(= (liftRepl m) (Repl (lift m)))

(instance (Functor Repl)
  (= (fmap f (Repl a)) (Repl (fmap f a))))

(instance (Applicative Repl)
  (= (pure a) (Repl (pure a)))
  (= (<*> (Repl f) (Repl a)) (Repl (<*> f a))))

(instance (Monad Repl)
  (= return pure)
  (= (>>= (Repl a) k) (Repl (>>= a (. unRepl k)))))

(instance (MonadIO Repl)
  (= (liftIO io) (Repl (liftIO io))))

(instance (MonadException Repl)
  (= (controlIO f)
    (Repl (controlIO
           (\ ((RunIO run0))
             (let ((= run1 (RunIO (. (fmap Repl) (. run0 unRepl)))))
               (fmap unRepl (f run1))))))))


;;; Read
;;; ----

(:: readForms (-> String (Repl (Maybe (LTForm Atom)))))
(= (readForms input0)
  (do (<- st getReplState)
      (let ((= input1 (++ (pendingInput st) (: \lf input0)))
            (= count (succ (inputCount st)))
            (= (putAndReturn pending ret)
              (do (putReplState (st {inputCount (succ (inputCount st))
                                     pendingInput pending}))
                  (return ret)))))
      (case (evalSP sexpr (Just "<<repl>>") input1)
        ((Right forms) (putAndReturn "" (Just forms)))
        ((Left err) (putAndReturn input1 Nothing)))))


;;; Eval
;;; ----

(:: evalForms (-> [LTForm Atom] (Repl ())))
(= (evalForms forms0)
  ;; See `runStmt' in "ghc/GHCi/UI.hs". It handles statement, import
  ;; declaration, and other declarations by testing whether parser
  ;; succeeded or not.
  (let ((= work
          (do (<- forms1 (macroexpands forms0))
              (<- ret (withHandler (evalStatement forms1)))
              (case ret
                ((Right _) (return ()))
                ((Left err) (liftIO (putStrLn err))))))
        (= (withHandler m)
          (withSourceErrorHandling m)))
    (liftRepl work)))

(:: evalStatement (-> [LTForm Atom] (Skc (Either String ()))))
(= (evalStatement forms)
  (case (evalBuilder parseStmt forms)
    ((Right stmt0)
     (do (<- hscenv getSession)
         (<- stmt1 (liftIO (hscParsedStmt hscenv stmt0)))
         (case stmt1
           (Nothing (liftIO (putStrLn "no ret")))
           ((Just (, ids fhv fixity))
            ;; (liftIO (evalIO hscenv fhv))
            (eval-stmt-inner hscenv ids fhv fixity)))
         (return (Right ()))))
    ((Left _) (evalImport forms))))

(:: eval-stmt-inner (-> HscEnv [Id] ForeignHValue FixityEnv (Skc ())))
(= (eval-stmt-inner hsc-env ids hvals-io fixity-env)
  (do (<- status (liftIO (evalStmt hsc-env False (EvalThis hvals-io))))
      ;; (updateFixityEnv fixity-env)
      (let ((= ic (hsc_IC hsc-env))
            (= bindings (, (ic_tythings ic) (ic_rn_gbl_env ic)))
            (= size 10)
            (= final-ic (extendInteractiveContextWithIds ic ids))
            (= final-names (map getName ids))
            (= hsc-env-2 (hsc-env {hsc_IC final-ic}))))
      (case status
        ((EvalComplete _ (EvalSuccess hvals))
         (liftIO
          (do (extendLinkEnv (zip final-names hvals))
              (mapM_ (. putStrLn
                        (. (++ ";;; ") nameStableString))
                     final-names))))
        (_ (return ())))

      ;; InteractiveEval does not export rttiEnvironment ...
      ;;
      ;; (<- hsc-env-3
      ;;     (liftIO
      ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

      (setSession hsc-env-2)))

(:: evalImport (-> [LTForm Atom] (Skc (Either String ()))))
(= (evalImport forms)
  (case (evalBuilder parseImports forms)
    ((Right imports)
     (do (<- context getContext)
         (liftIO (mapM_ (. putStrLn (. (++ ";;; ") (. show unLocForm)))
                        forms))
         (let ((= (ii (L _ idecl)) (IIDecl idecl))))
         (setContext (++ (map ii imports) context))
         (return (Right ()))))
    ((Left err) (evalDecls forms))))

(:: evalDecls (-> [LTForm Atom] (Skc (Either String ()))))
(= (evalDecls forms)
  ;; Some relevant codes:
  ;;
  ;;  * ghc/GHCi/UI/Monad.hs: runDecls
  ;;  * compiler/main/InteractiveEval.hs: runDeclsWithLocaton,
  ;;    rttinvironment, handleRunstatus
  ;;  * compiler/main/HscMain.hs: hscDeclsWithLocation
  ;;  * compiler/main/HscTypes.hs: extendInteractiveContextWithIds
  ;;
  (case (evalBuilder parseDecls forms)
    ((Right _)
     (do (liftIO (putStrLn
                  (++ ";;; decl " (show (map unLocForm forms)))))
         (return (Right ()))))
    ((Left err) (return (Left err)))))


;;; Loop
;;; ----

(:: initRepl (Repl ()))
(= initRepl
  ;; See `HscTypes.runInteractiveHsc'.
  (liftRepl
   (do (<- hsc_env getSession)
       (void (setSessionDynFlags (ic_dflags (hsc_IC hsc_env))))
       (let ((= decl (. IIDecl (. simpleImportDecl mkModuleName)))))
       (setContext [(decl "Prelude") (decl "SK.Core")]))))

;; (= initRepl
;;   (liftRepl setExpanderSettings))

(:: loop (InputT Repl ()))
(= loop
  (do (<- st (lift getReplState))
      (let ((= prompt (if (null (pendingInput st))
                          "sk> "
                          ""))))
      (<- minput (getInputLine prompt))
      (case minput
        (Nothing (return ()))
        ((Just str)
         (| ((== str "(quit)") (return ()))
            ((null str) loop)
            (otherwise
             (do (<- mbform (lift (readForms str)))
                 (case mbform
                   (Nothing (return ()))
                   ((Just form) (lift (evalForms [form]))))
                 loop)))))))

(:: skRepl (InputT Repl ()))
(= skRepl
  (let ((= lp
          (handleInterrupt
           (>> (outputStrLn "Cancelled.") lp)
           loop)))
    (>> (lift initRepl) (withInterrupt lp))))


;;; Main
;;; ----

(:: replMain (IO ()))
(= replMain
  (let ((= go
          (do (let ((= repl (runInputT defaultSettings skRepl))
                    (= skc (runRepl repl initialReplState))))
              (<- ret (runSkc skc initialSkEnv))
              (case ret
                ((Right a) (return ()))
                ((Left err) (>> (putStrLn (++ "ERR:" err)) go))))))
    (do (putStrLn "SK repl version 0.0.1, hit `Ctrl-d to exit.")
        go)))
