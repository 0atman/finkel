;;;; | Simple SK REPL.
;;;;
;;;; This implementation uses two threads: one for reading and printing,
;;;; and another for evaluating and modifying the SkEnv. Using `MVar'
;;;; containing `Code' to communicate between the threads. This design
;;;; shall be easier to support reading forms from other sources than
;;;; line oriented user input, e.g. network sockets.

(module SK.Repl replMain)

(require SK.Core)
(require SK.Repl.Macro)

;; base
(import Data.Version (showVersion))
(import System.Environment (getArgs))
(import System.Exit (exitFailure))
(import System.Console.GetOpt)

;; sk-kernel
(import Language.SK)
(import Language.SK.Run (initialSkEnv))
(import qualified Paths_sk_kernel)

;; internal
(import SK.Core)
(import SK.Repl.Macro)
(import SK.Repl.Loop)
(import qualified Paths_sk_lang)


;;; Main

(defdo (replMain (IO ()))
  ()
  (<- args getArgs)
  (case (getOpt Permute descrs args)
    (, o _ []) (act (foldl (flip id) initial-option o))
    (, _ _ es) (print-errors es)))


;;; Option types

(data ReplMode
  Help Version Run
  (deriving (Eq Show)))

(data ReplOption
  (ReplOption {repl-mode ReplMode}))

(defn (initial-option ReplOption)
  ()
  (ReplOption {repl-mode Run}))

(defn (descrs [OptDescr (-> ReplOption ReplOption)])
  ()
  [(Option [\h] ["help"]
           (NoArg (\ o (o {repl-mode Help})))
           "Show this help and exit.")
   (Option [\V] ["version"]
           (NoArg (\ o (o {repl-mode Version})))
           "Show version information and exit.")])

(defn (act (-> ReplOption (IO ())))
  (ro)
  (case (repl-mode ro)
    Help print-usage
    Version print-version
    Run run))


;;; Actions

(defdo (print-errors (-> [String] (IO ())))
  (errs)
  (mapM_ putStr errs)
  (putChar \\n)
  print-usage
  exitFailure)

(defn (print-usage (IO ()))
  ()
  (putStr
   (unlines
    ["USAGE: sk [OPTIONS]"
     ""
     "With no OPTIONS, start interactive REPL."
     ""
     (usageInfo "OPTIONS:" descrs)])))

(defn (print-version (IO ()))
  ()
  (putStrLn (++ "sk " sk-lang-version)))

(defdo (run (IO ()))
  ()
  (putStrLn (concat ["SK REPL (sk-lang " sk-lang-version
                     ", sk-kernel " sk-kernel-version ")"]))
  (start-repl repl-env))

(:: sk-lang-version String)
(= sk-lang-version (showVersion Paths_sk_lang.version))

(:: sk-kernel-version String)
(= sk-kernel-version (showVersion Paths_sk_kernel.version))

(:: repl-env SkEnv)
(= repl-env
  (let ((= modules
          ["Prelude" "SK.Prelude" "SK.Repl.Env" "SK.Repl.Macro"])
        (= defaultMacros
          (mergeMacros specialForms replMacros)))
    (initialSkEnv {envContextModules modules
                   envDefaultMacros defaultMacros
                   envAddInDefineMacro True})))

;;; Default macros imported in REPL. These macros always get imported
;;; after loading compiled modules.
(macrolet* ((the-macros ()
              (return
                `[,@(map (\ mac `(, ,mac ,(aSymbol mac)))
                         (++ (exported-macros SK.Core)
                             (exported-macros SK.Repl.Macro)))])))
  (:: replMacros EnvMacros)
  (= replMacros (makeEnvMacros (the-macros))))
