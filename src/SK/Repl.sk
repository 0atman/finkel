;;;; -*- mode: sk -*-
;;;; | Simple SK REPL.
;;;;
;;;; This implementation uses two threads: one for reading input and
;;;; another for evaluating and modifying the SkEnv. Using `MVar'
;;;; containing `LCode' to commnicate between the threads. This design
;;;; shall be easier to support reading forms from other sources than
;;;; line oriented user input, e.g. network sockets.

(require SK.Macro)
(require SK.Repl.Macro)

(module SK.Repl)

(import Control.Concurrent)     ; base
(import Control.Monad)
(import Control.Monad.IO.Class)
(import Control.Monad.Trans.Class)
(import Control.Monad.Trans.State.Strict)
(import Data.List)
(import Data.Version)
(import System.Exit)

(import GhcMonad)               ; ghc
(import HscMain)
(import HscTypes)
(import Id)
(import InteractiveEval)
(import Linker)
(import Name)
(import Outputable)
(import TcRnDriver)
(import Var)

(import GHCi)                   ; ghci
(import GHCi.Message)
(import GHCi.RemoteTypes)

(import System.Console.Haskeline) ; haskeline

(import SK.Core)                ; sk-core
(import SK.Core.Builder)
(import SK.Core.GHC)
(import SK.Core.Lexer)
(import SK.Core.Macro)
(import SK.Core.Reader)
(import SK.Core.Run)
(import SK.Core.Syntax)

(import Paths_sk_repl)          ; internal
(import SK.Repl.Apply)



;;;; Repl, state, and result types

(data ReplState
  (ReplState {pending-input String
              input-count Int})
  (deriving (Eq Show)))

(:: initial-repl-state (ReplState))
(= initial-repl-state
  (ReplState {pending-input "" input-count 0}))

(newtype (Repl a)
  (Repl {unRepl (StateT ReplState IO a)}))

(instance (Functor Repl)
  (= (fmap f (Repl a)) (Repl (fmap f a))))

(instance (Applicative Repl)
  (= (pure a) (Repl (pure a)))
  (= (<*> (Repl f) (Repl a)) (Repl (<*> f a))))

(instance (Monad Repl)
  (= return pure)
  (= (>>= a k) (Repl (>>= (unRepl a) (. unRepl k)))))

(instance (MonadIO Repl)
  (= (liftIO io) (Repl (liftIO io))))

(instance (MonadException Repl)
  (= (controlIO f)
    (Repl (controlIO
           (\ ((RunIO r0))
             (let ((= r1 (RunIO (. (fmap Repl) (. r0 unRepl)))))
               (fmap unRepl (f r1))))))))

(:: run-repl (-> (Repl a) ReplState (IO a)))
(= (run-repl repl st) (evalStateT (unRepl repl) st))

(:: put-repl-state (-> ReplState (Repl ())))
(= (put-repl-state st) (Repl (put st)))

(:: get-repl-state (Repl ReplState))
(= get-repl-state (Repl get))

(:: lift-repl (-> (IO a) (Repl a)))
(= (lift-repl m) (Repl (lift m)))

(type Result (Either String String))


;;;; Main

(:: replMain (IO ()))
(= replMain
  (do (<- in-mv newEmptyMVar)
      (<- out-mv newEmptyMVar)
      (let ((= skc (runSkc (eval-loop in-mv out-mv) initialSkEnv))))
      (<- eval-tid (forkIO (void skc)))
      (let ((= reader (read-print-loop in-mv out-mv eval-tid))
            (= reader' (runInputT defaultSettings reader))
            (= msg (unlines
                    [(++ "SK REPL, version " (showVersion version))
                     "hit `Ctrl-d' to exit."]))))
      (putStr msg)
      (run-repl reader' initial-repl-state)))


;;;; Read

;;; Read single S-expression form.
(defn: read-form (input0)
    (-> String (Repl (Maybe LCode)))
  (do (<- st get-repl-state)
      (let ((= input1 (++ (pending-input st) (: \lf input0)))
            (= count (succ (input-count st)))
            (= (put-and-return pending ret)
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret))))
        (case (evalSP sexpr (Just "<<repl>>") input1)
          ((Right forms) (put-and-return "" (Just forms)))
          ((Left err) (put-and-return input1 Nothing))))))

;;; Loop for reading input.
;;;
;;; Tracks tate of intermediate S-expression, and continue reading the
;;; input until successful parse result.
;;;
(:: read-print-loop
  (-> (MVar LCode) (MVar String) ThreadId (InputT Repl ())))
(= (read-print-loop to-eval-mvar from-eval-mvar eval-tid)
  (let ((= quit
          (liftIO (killThread eval-tid)))
        (= go
          (do (<- st (lift get-repl-state))
              (let ((= prompt (| ((null (pending-input st)) "> ")
                                 (otherwise "")))))
              (<- mb-input (getInputLine prompt))
              (case mb-input
                (Nothing quit)
                ((Just line)
                 (| ((== line "(quit)") quit)
                    ((null line) go)
                    (otherwise
                     (do (<- mb-form (lift (read-form line)))
                         (case mb-form
                           (Nothing go)
                           ((Just form)
                            (do (liftIO
                                 (do (putMVar to-eval-mvar form)
                                     (<- ret (takeMVar from-eval-mvar))
                                     (putStr ret)))
                                go))))))))))
        (= loop
          (handleInterrupt (>> (outputStrLn "Interrupd") loop)
                           go)))
    (withInterrupt loop)))


;;;; Eval

(:: eval-loop (-> (MVar LCode) (MVar String) (Skc ())))
(= (eval-loop in-mvar out-mvar)
  (let ((= init
          (do (<- hsc-env getSession)
              (<- _ (setSessionDynFlags (ic_dflags (hsc_IC hsc-env))))
              (let ((= decl
                      (. IIDecl (. simpleImportDecl mkModuleName)))))
              (setContext [(decl "Prelude")
                           (decl "SK.Core")
                           (decl "SK.Repl.Apply")])))
        (= (withHandler m)
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))
        (= go (do (<- form (liftIO (takeMVar in-mvar)))
                  (<- ret (withHandler
                           (do (<- expanded (macroexpands [form]))
                               (eval-statement expanded))))
                  (let ((= str (case ret
                                 ((Right r) r)
                                 ((Left err) err)))))
                  (liftIO (putMVar out-mvar str))
                  go)))
    (>> init go)))

(:: eval-statement (-> [LCode] (Skc Result)))
(= (eval-statement forms)
  (case (evalBuilder parseStmt forms)
    ((Right stmt0)
     (do (<- hsc-env getSession)
         (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
         (case stmt1
           ((Just (, ids hvals-io fixity-env))
            (update-hsc-env hsc-env True ids hvals-io fixity-env))
           (Nothing
            (return (Left "eval-statement: no result"))))))
    ((Left err) (eval-import forms))))

(:: eval-import (-> [LTForm Atom] (Skc Result)))
(= (eval-import forms)
  (case (evalBuilder parseImports forms)
    ((Right imports)
     (do (<- context getContext)
         (let ((= (mkIIdecl (L _ idecl)) (IIDecl idecl))
               (= ret (map (. (++ ";;; ") (. show unLocForm)) forms))))
         (setContext (++ (map mkIIdecl imports) context))
         (return (Right (unlines ret)))))
    ((Left err) (eval-decls forms))))

(:: eval-decls (-> [LTForm Atom] (Skc Result)))
(= (eval-decls forms)
  (case (evalBuilder parseDecls forms)
    ((Right decls)
     ;; Currently decls are converted as `let' statement and passed to
     ;; `hscParsedStmt'. Support for `data', `newtype', `class' .. etc
     ;; are not yet implemented.
     (do (let ((= l (mkLocatedList decls))
               (= stmt (b_letS l decls))))
         (<- hsc-env getSession)
         (<- ret (liftIO (hscParsedStmt hsc-env stmt)))
         (case ret
           ((Just (, ids hvals fixity))
            (update-hsc-env hsc-env False ids hvals fixity))
           (Nothing
            (return (Left (++ "evalDecls: "
                              (show (map unLocForm forms)))))))))
    ((Left err) (return (Left err)))))

(:: update-hsc-env
  (-> HscEnv Bool [Id] ForeignHValue FixityEnv (Skc Result)))
(= (update-hsc-env hsc-env is-body ids hvals-io fixity-env)
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its body.
  (do (<- status (liftIO (evalStmt hsc-env False (EvalThis hvals-io))))
      (<- dflags getSessionDynFlags)
      (case status
        ((EvalComplete _ (EvalSuccess fhvals))
         (do (let ((= ic (hsc_IC hsc-env))
                   (= bindings (, (ic_tythings ic) (ic_rn_gbl_env ic)))
                   (= size 10)
                   (= ic2 (extendInteractiveContextWithIds ic ids))
                   (= ic3 (ic2 {ic_fix_env fixity-env}))
                   (= final-names (map getName ids))
                   (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
             (liftIO (extendLinkEnv (zip final-names fhvals)))
             (when is-body
               (return ())
               ;; (case ids
               ;;   ([] (return ()))
               ;;   ((: var _)
               ;;    (do (let ((= tystr (showPpr dflags (varType var)))))
               ;;        (when (isPrefixOf "ReplIO" tystr)
               ;;          (evalApply hsc-env-2 fhvals)))))
               )

             ;; InteractiveEval does not export rttiEnvironment ...
             ;;
             ;; (<- hsc-env-3
             ;;     (liftIO
             ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

             (setSession hsc-env-2)
             (return
               (Right (print-names-and-types dflags final-names ids)))))
        ((EvalComplete _ (EvalException serialized))
         (case serialized
           ((EOtherException str) (return (Left str)))
           ((EExitCode ecode) (liftIO (exitWith ecode)))
           (EUserInterrupt (return (Right "Interrupt")))))
        (_
         (return (Left "update-hsc-env failed."))))))


;;;; Auxiliary

(:: print-names-and-types (-> DynFlags [Name] [Var] String))
(= (print-names-and-types dflags names vars)
  (let ((= tvs
          (map (\ ((, name var))
                 (let ((= nstr (occNameString (nameOccName name)))
                       (= typ (showPpr dflags (varType var))))
                   (if (== nstr "it")
                       ""
                       (concat [";; " nstr " :: " typ]))))
               (zip names vars))))
    (if (all null tvs)
        ""
        (++ (concat (intersperse [\lf] tvs)) [\lf]))))
