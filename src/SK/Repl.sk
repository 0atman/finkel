;;;; -*- mode: sk -*-
;;;; | Simple SK REPL.

;;; This implementation uses two threads: one for read/print, and
;;; another for evaluating and modifying the SkEnv. Using `MVar'
;;; containing `Code' to communicate between the threads. This design
;;; shall be easier to support reading forms from other sources than
;;; line oriented user input, e.g. network sockets.

(module SK.Repl)

(require SK.Core)

(import Control.Concurrent      ; base
        ((MVar) (ThreadId) forkIO killThread newEmptyMVar
                putMVar takeMVar))
(import Control.Monad (void when))
(import Control.Monad.IO.Class ((MonadIO ..)))
(import Data.List (intercalate intersperse nubBy))
(import Data.String (fromString))
(import Data.Version (showVersion))
(import System.Exit (exitWith))
(import System.IO (hFlush stdout))

(import GhcMonad)               ; ghc
(import HscMain)
(import HscTypes)
(import Id)
(import InteractiveEval)
(import Linker)
(import Name)
(import Outputable)
(import TcRnDriver)
(import Var)

(import GHCi)                   ; ghci
(import GHCi.Message)
(import GHCi.RemoteTypes)

(import System.Console.Haskeline) ; haskeline

(import Control.Monad.Trans.Class) ; transformers
(import Control.Monad.Trans.State.Strict)

(import Language.SK)                ; sk-kernel
(import Language.SK.Builder)
(import Language.SK.Eval)
(import Language.SK.GHC)
(import Language.SK.Lexer)
(import Language.SK.Macro)
(import Language.SK.Reader)
(import Language.SK.Run)
(import Language.SK.Syntax)

(import Paths_sk_repl)          ; internal
(import SK.Repl.Apply)



;;;; Repl, state, and result types

(data ReplState
  (ReplState {pending-input String
              input-count Int})
  (deriving (Eq Show)))

(:: initial-repl-state (ReplState))
(= initial-repl-state
  (ReplState {pending-input "" input-count 0}))

(newtype (Repl a)
  (Repl {unRepl (StateT ReplState IO a)}))

(instance (Functor Repl)
  (= fmap f (Repl a) (Repl (fmap f a))))

(instance (Applicative Repl)
  (= pure a (Repl (pure a)))
  (= <*> (Repl f) (Repl a) (Repl (<*> f a))))

(instance (Monad Repl)
  (= return pure)
  (= >>= a k (Repl (>>= (unRepl a) (. unRepl k)))))

(instance (MonadIO Repl)
  (= liftIO io (Repl (liftIO io))))

(instance (MonadException Repl)
  (= controlIO f
    (Repl (controlIO
           (\ (RunIO r0)
             (let ((= r1 (RunIO (. (fmap Repl) (. r0 unRepl)))))
               (fmap unRepl (f r1))))))))

(:: run-repl (-> (Repl a) ReplState (IO a)))
(= run-repl repl st (evalStateT (unRepl repl) st))

(:: put-repl-state (-> ReplState (Repl ())))
(= put-repl-state st (Repl (put st)))

(:: get-repl-state (Repl ReplState))
(= get-repl-state (Repl get))

(:: lift-repl (-> (IO a) (Repl a)))
(= lift-repl m (Repl (lift m)))

(type Result (Either String String))


;;;; Main

(defn: replMain (IO ()) ()
  (do (<- in-mv newEmptyMVar)
      (<- out-mv newEmptyMVar)
      (let ((= skc (runSkc (eval-loop in-mv out-mv) repl-env))))
      (<- eval-tid (forkIO (void skc)))
      (let ((= reader (read-print-loop in-mv out-mv eval-tid))
            (= reader' (runInputT defaultSettings reader))
            (= init-form
              '(begin
                (require SK.User)
                (putStrLn "REPL ready, hit `Ctrl-d' to exit.")))))
      (putStrLn (++ "SK REPL " (showVersion version)))
      (putMVar in-mv init-form)
      (run-repl reader' initial-repl-state)))

(:: repl-env SkEnv)
(= repl-env (initialSkEnv {envContextModules ["SK.User"]}))


;;;; Read and print

;;; Loop for reading input and printing the output.
;;;
;;; Tracks the state of intermediate S-expression from input, and
;;; continue reading the input until successful parse result.
(:: read-print-loop
  (-> (MVar Code) (MVar String) ThreadId (InputT Repl ())))
(= read-print-loop to-mvar from-mvar eval-tid
  (let ((= print-io
          (do (<- str (takeMVar from-mvar))
              (putStr str)
              (hFlush stdout)))
        (= go
          (do (<- st (lift get-repl-state))
              (let ((= prompt (| ((null (pending-input st)) "> ")
                                 (otherwise "")))))
              (<- mb-input (getInputLine prompt))
              (case mb-input
                Nothing     quit
                (Just line) (| ((== line "(quit)") quit)
                               ((null line) go)
                               (otherwise (go' line))))))
        (= go' line
          (do (<- mb-form (lift (read-form line)))
              (case mb-form
                Nothing     go
                (Just form) (do (liftIO (do (putMVar to-mvar form)
                                            print-io))
                                go))))
        (= quit
          (liftIO (killThread eval-tid)))
        (= loop
          (handleInterrupt (>> (outputStrLn "Interrupd") loop)
                           go)))
    ;; Print the result from boot expression, then start the loop.
    (do (liftIO print-io)
        (withInterrupt loop))))

;;; Read single S-expression form.
(:: read-form (-> String (Repl (Maybe Code))))
(= read-form input0
  (do (<- st get-repl-state)
      (let ((= input1 (++ (pending-input st) (: \lf input0)))
            (= count (succ (input-count st)))
            (= put-and-return pending ret
              (do (put-repl-state (st {input-count count
                                       pending-input pending}))
                  (return ret))))
        (case (evalSP sexpr (Just "<repl>") (fromString input1))
          (Right forms) (put-and-return "" (Just forms))
          (Left err)    (put-and-return input1 Nothing)))))


;;;; Eval

(:: eval-loop (-> (MVar Code) (MVar String) (Skc ())))
(= eval-loop in-mvar out-mvar
  (let ((= init
          (do (<- hsc-env getSession)
              (let ((= dflags0 (ic_dflags (hsc_IC hsc-env)))
                    ;; Default target in interactive context is
                    ;; ``HscAsm', updating to `HscInterpreted'.
                    (= dflags1 (dflags0 {hscTarget HscInterpreted
                                         ghcLink LinkInMemory}))
                    (= decl
                      (. IIDecl (. simpleImportDecl mkModuleName)))))
              (<- _ (setSessionDynFlags dflags1))
              (return ())))
        (= withHandler m
          (skErrorHandler defaultFatalMessager
                          defaultFlushOut
                          (withSourceErrorHandling m)))
        (= go (do (<- form (liftIO (takeMVar in-mvar)))
                  (<- ret (withHandler
                           (do (<- expanded (expands [form]))
                               (eval-form expanded))))
                  (let ((= str (case ret
                                 (Right r) r
                                 (Left err) err))))
                  (liftIO (putMVar out-mvar str))
                  go)))
    (>> init go)))

(:: eval-form (-> [Code] (Skc Result)))
(= eval-form forms
  (| ((null forms)
      (return (Right "")))
     ((<- (Right stmt) (evalBuilder parseStmt forms))
      (eval-statement stmt))
     ((<- (Right idecl) (evalBuilder parseImports forms))
      (eval-imports idecl))
     (otherwise
      (case (evalBuilder parseTopDecls forms)
        (Right decs) (eval-decls decs)
        (Left err)   (return (Left (concat [err [\lf]])))))))

(:: eval-statement (-> HStmt (Skc Result)))
(= eval-statement stmt0
  (do (<- hsc-env getSession)
      (<- stmt1 (liftIO (hscParsedStmt hsc-env stmt0)))
      (case stmt1
        (Just (, ids hvals-io fixity-env))
        (update-hsc-env hsc-env True ids hvals-io fixity-env)
        Nothing
        (return (Left "eval-statement: no result")))))

(:: eval-imports (-> [HImportDecl] (Skc Result)))
(= eval-imports imports
  (do (<- context getContext)
      (<- dflags getSessionDynFlags)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= eqII a b
              (case (, a b)
                (, (IIModule x) (IIModule y)) (== x y)
                (, (IIDecl x) (IIDecl y))     (== (unLoc (ideclName x))
                                                  (unLoc (ideclName y)))
                _                               False))
            (= mdls
              (concat ["; "
                       (intercalate ", " (map (. (showSDoc dflags) ppr)
                                              imports))
                       "\n"]))))
      (setContext (nubBy eqII (++ (map mkIIDecl imports) context)))
      (return (Right mdls))))

(:: eval-decls (-> [HDecl] (Skc Result)))
(= eval-decls decls
  (do (<- (, tythings ic) (evalDecls decls))
      (<- hsc-env getSession)
      (let ((= dflags (hsc_dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _          (++ "; " (showSDoc dflags (ppr tt)))))
            (= tystrs (foldr
                       (\ tt acc
                         (let ((= nstr
                                 (showSDoc dflags (ppr (getName tt)))))
                           (if (== "$trModule" nstr)
                               acc
                               (: (pr tt) acc))))
                       []
                       tythings))
            (= tystr (unlines tystrs))))
      (return (Right tystr))))

(:: update-hsc-env
  (-> HscEnv Bool [Id] ForeignHValue FixityEnv (Skc Result)))
(= update-hsc-env hsc-env is-body ids hvals-io fixity-env
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its body.
  (do (<- status (liftIO (evalStmt hsc-env False (EvalThis hvals-io))))
      (<- dflags getSessionDynFlags)
      (case status
        (EvalComplete _ (EvalSuccess fhvals))
        (do (let ((= ic (hsc_IC hsc-env))
                  (= bindings (, (ic_tythings ic) (ic_rn_gbl_env ic)))
                  (= size 10)
                  (= ic2 (extendInteractiveContextWithIds ic ids))
                  (= ic3 (ic2 {ic_fix_env fixity-env}))
                  (= final-names (map getName ids))
                  (= hsc-env-2 (hsc-env {hsc_IC ic3}))))
            (liftIO (extendLinkEnv (zip final-names fhvals)))
            (when is-body
              (return ())
              ;; (case ids
              ;;   ([] (return ()))
              ;;   ((: var _)
              ;;    (do (let ((= tystr (showPpr dflags (varType var)))))
              ;;        (when (isPrefixOf "ReplIO" tystr)
              ;;          (evalApply hsc-env-2 fhvals)))))
              )

            ;; InteractiveEval does not export `rttiEnvironment' ...
            ;;
            ;; (<- hsc-env-3
            ;;     (liftIO
            ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

            (setSession hsc-env-2)
            (return
              (Right (show-names-and-types dflags final-names ids))))
        (EvalComplete _ (EvalException serialized))
        (case serialized
          (EOtherException str) (return (Left str))
          (EExitCode ecode)     (liftIO (exitWith ecode))
          EUserInterrupt        (return (Right "Interrupt")))
        _ (return (Left "update-hsc-env failed.")))))


;;;; Auxiliary

(:: var-name-and-type (-> DynFlags Name Var String))
(= var-name-and-type dflags name var
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (concat
         (intersperse "\n"
                      (map (++ "; ")
                           (lines (++ nstr (++ " :: " typ)))))))))

(:: show-names-and-types (-> DynFlags [Name] [Var] String))
(= show-names-and-types dflags names vars
  (where (| ((all null tvs) "")
            (otherwise      (++ (concat (intersperse "\n" tvs)) "\n")))
    (= tvs (zipWith (var-name-and-type dflags) names vars))))
