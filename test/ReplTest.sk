;;; Tests for REPL.

(require SK.Core)

(defmodule ReplTest
  (use
   ;; base
   (Control.Concurrent)
   (Control.Monad (void))

   ;; directory
   (System.Directory (getCurrentDirectory))

   ;; hspec
   (Test.Hspec)

   ;; sk-kernel
   (Language.SK)
   (Language.SK.Run)

   ;; sk-lang
   (SK.Repl (repl-env))
   (SK.Repl.Loop)
   (SK.Repl.Types))

  (export replTests))

(defdo (replTests Spec)
  ()
  (describe "Read" readTests)
  (describe "Eval" evalTests))

(defdo (readTests Spec)
  ()
  (let ((= d describe)))
  (d "reading single line form"
     (it "returns '(foo bar buzz)"
         (do (<- form (run-repl (read-form "(foo bar buzz)")
                                initial-repl-state))
             (shouldBe (Just '(foo bar buzz)) form))))
  (d "reading multi line form"
     (it "returns '(a b c)"
         (do (<- form (run-repl (do (read-form "(a ")
                                    (read-form "b ")
                                    (read-form "c)"))
                                initial-repl-state))
             (shouldBe (Just '(a b c)) form)))))

(defdo (evalTests Spec)
  ()
  (let ((= d describe)))
  (<- in-mv (runIO newEmptyMVar))
  (<- out-mv (runIO newEmptyMVar))
  (<- tmpfile (runIO make-tmpfile))
  (<- current-dir (runIO getCurrentDirectory))
  (<- etid
    (runIO
     (forkIO (void (runSkc (eval-loop tmpfile in-mv) repl-env)))))
  (let ((= eval-form ok-or-ng form expect
          (d (concat ["evaluate " (show form)])
             (it (concat ["evaluates to " (show expect)])
                 (do (putMVar in-mv (Input Connection form out-mv))
                     (<- ret (takeMVar out-mv))
                     (shouldBe ret (ok-or-ng expect))))))
        (= eok (eval-form Right))
        (= eng (eval-form Left))))
  (beforeAll_
   (do (putMVar in-mv (Input Connection init-form out-mv))
       (void (takeMVar out-mv)))
   (afterAll_
    (do (killThread etid)
        (cleanup-tmpfile tmpfile))
    (do
      ;; Statements and declarations
      (eok '(+ 10 32) "42")
      (eok '(funcall1 'putStr "foo") "foo")
      (eok '(defn (foo (-> Int Int))
             (n)
             (+ n 1))
           "; foo :: Int -> Int")
      (eok '(begin
             (:: (x y) Int)
             (= x 1)
             (= y 2))
           "; x :: Int\n; y :: Int")
      (eok '(<- bar (return True))
           "; bar :: Bool")
      (eok '(data Foo (Foo Int))
           (concat ["; $tcFoo :: TyCon\n"
                    "; $tc'Foo :: TyCon\n"
                    "; Type constructor ‘Foo’"]))
      (eok '(import Control.Monad)
           "; import Control.Monad")

      ;; REPL macros
      (eok '(exported-macros Prelude) "[]")
      (eok '(info 'putStr)
           "putStr :: String -> IO () \t-- Defined in ‘System.IO’\n")
      (eok '(pwd) (show current-dir))

      ;; Errors
      (eng 'buzz
           (concat ["<interactive>:1:1: error: "
                    "Variable not in scope: buzz\n"]))
      (eng '(= f a (+ a 1) (+ a 2))
           (concat ["<quoted code>: syntax error on input "
                    "`(= f a (+ a 1) (+ a 2))'\n"]))
      (eng '(head []) "Prelude.head: empty list")))))
