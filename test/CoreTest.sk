;;;; Module to test macros.

(require SK.Core)

(module CoreTest coreTests)

(import Language.SK.Run)
(import Test.Hspec)
(import Test.QuickCheck)
(import SK.User)

(defmacro m1 (x)
  `(++ "m1 " ,x))

(defn (coreTests Spec) ()
  (do (describe "List" listTests)
      (describe "Macro" macroTests)))

(defn (listTests Spec) ()
  (do (let ((= d describe)))
      (d "car of (cons x xs)"
         (it "should be x"
             (let ((:: f (-> Code Code Property))
                   (= f x xs
                     (==> (list? xs) (== x (car (cons x xs))))))
               (property f))))
      (d "cdr of (cons x xs)"
         (it "should be xs"
             (let ((:: f (-> Code Code Property))
                   (= f x xs
                     (==> (list? xs) (== xs (cdr (cons x xs))))))
               (property f))))
      (d "list of x, y, and z"
         (it "should be a list"
             (let ((:: f (-> Int Char String Bool))
                   (= f x y z
                     (list? (list x y z))))
               (property f))))
      (d "length of atom"
         (it "should be 1"
             (let ((:: f (-> Code Property))
                   (= f x
                     (==> (atom? x) (== 1 (length x)))))
               (property f))))
      (d "mapcar"
         (it "should replace non-symbols"
             (shouldBe '(foo bar _ buzz _ _)
                       (mapcar (\ x (if (symbol? x) x '_))
                               '(foo bar (a b c) buzz 3 "string")))))))

(defmacro expandTo (in out)
  (let ((= macro (car in)))
    `(do (let ((= f (macroFunction ,macro))))
         (<- e (f ',in))
         (shouldBe e (Right ',out)))))

(defn (macroTests Spec) ()
  (do (let ((= d describe)))

      (d "(m1 \"foo\")"
         (it "should be \"m1 foo\""
             (shouldBe (m1 "foo") "m1 foo")))

      (d "expanding eval-when"
         (it "should expand to (begin (eval-when-compile ...) ....)"
             (expandTo
              (eval-when (compile load)
                (:: foo (-> Int Int))
                (= foo a (+ a 1)))
              (begin
                (eval-when-compile
                 (:: foo (-> Int Int))
                 (= foo a (+ a 1)))
                (:: foo (-> Int Int))
                (= foo a (+ a 1))))))

      (d "expanding defmacro*"
         (it "should expand to define-macro"
             (expandTo
              (defmacro* m1 (a)
                (return `(putStrLn (++ "hello, " ,a))))
              (define-macro m1 *form*
                (case *form*
                  (LForm (L _loc (List [_ a])))
                  (return
                    (quasiquote
                     (putStrLn (++ "hello, " (unquote a)))))
                  _ (skSrcError
                     *form*
                     (concat [(show (quote m1))
                              "\ninvalid args: `"
                              (show *form*) "'"])))))))

      (d "expanding defmacro"
         (it "should expand to defmacro*"
             (expandTo
              (defmacro m1 (a)
                `(putStrLn (++ "hello, " ,a)))
              (defmacro* m1 (a)
                (return
                  (quasiquote
                   (putStrLn (++ "hello, " (unquote a)))))))))

      (d "expanding macrolet*"
         (it "should expand to let-macro"
             (expandTo
              (macrolet* ((m (a b)
                            (return `(+ ,a ,b))))
                (m 20 22))
              (let-macro ((m *form*
                            (case *form*
                              (LForm (L _loc (List [_ a b])))
                              (return (quasiquote
                                       (+ (unquote a) (unquote b))))
                              _
                              (skSrcError
                               *form*
                               (concat [(show (quote m))
                                        "\ninvalid args: `"
                                        (show *form*)
                                        "'"])))))
                (m 20 22)))))

      (d "expanding macrolet"
         (it "should expand to let-macro with `return'"
             (expandTo
              (macrolet ((m (a b)
                           `(+ ,a ,b)))
                (m 20 22))
              (let-macro ((m *form*
                            (case *form*
                              (LForm (L _loc (List [_ a b])))
                              (return (quasiquote (+ (unquote a)
                                                     (unquote b))))
                              _
                              (skSrcError
                               *form*
                               (concat [(show (quote m))
                                        "\ninvalid args: `"
                                        (show *form*) "'"])))))
                (m 20 22)))))

      (d "expanding defn"
         (do (it "should expand to function declaration"
                 (expandTo
                  (defn foo (a b) (+ a b))
                  (= foo a b (+ a b))))
             (it "should expand to function with type signature"
                 (expandTo
                  (defn (foo (-> Int Int Int)) (a b)
                    (+ a b))
                  (begin
                    (:: foo (-> Int Int Int))
                    (= foo a b (+ a b)))))))

      (d "expanding defn+"
         (it "should expand to (eval-when (..) (defn ...))"
             (expandTo
              (defn+ foo (a b)
                (+ a b))
              (eval-when (compile load)
                (defn foo (a b)
                  (+ a b))))))

      (d "expanding list"
         (it "should expand to foldr"
             (expandTo
              (list \x \y \z)
              (foldr cons (quote ()) [(toCode \x)
                                      (toCode \y)
                                      (toCode \z)]))))))
