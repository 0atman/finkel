;;;; Module to test macros.

(require SK.Core)

(module CoreTest
  coreTests
  macroTests
  listTests)

(import Language.SK.Run)
(import Test.Hspec)
(import Test.QuickCheck)
(import SK.User)

(defmacro m1 (x)
  `(++ "m1 " ,x))

(defn (coreTests Spec) ()
  (do (describe "Macro" macroTests)
      (describe "List" listTests)))

(defmacro expandTo (in out)
  `(do (let ((= f (macroFunction ,(car in)))))
       (<- e (f ',in))
       (shouldBe e (Right ',out))))

(defn (macroTests Spec) ()
  (do (let ((= d describe)))

      (d "m1"
         (it "should be \"m1 foo\""
             (shouldBe (m1 "foo") "m1 foo")))

      (d "eval-when"
         (it "should expand to (begin (eval-when-compile ...) ....)"
             (expandTo
              (eval-when (compile load)
                (:: foo (-> Int Int))
                (= foo a (+ a 1)))
              (begin
                (eval-when-compile
                 (:: foo (-> Int Int))
                 (= foo a (+ a 1)))
                (:: foo (-> Int Int))
                (= foo a (+ a 1))))))

      (d "defmacro*"
         (it "should expand to define-macro"
             (expandTo
              (defmacro* m1 (a)
                (return `(putStrLn (++ "hello, " ,a))))
              (define-macro m1 *form*
                (case *form*
                  (LForm (L _loc (List [_ a])))
                  (return
                    (quasiquote
                     (putStrLn (++ "hello, " (unquote a)))))
                  _ (skSrcError
                     *form*
                     (concat [(show (quote m1))
                              "\ninvalid args: `"
                              (show *form*) "'"])))))))

      (d "defmacro"
         (it "should expand to defmacro*"
             (expandTo
              (defmacro m1 (a)
                `(putStrLn (++ "hello, " ,a)))
              (defmacro* m1 (a)
                (return
                  (quasiquote
                   (putStrLn (++ "hello, " (unquote a)))))))))

      (d "macro containing `$foo'"
         (it "should replace `$foo' with gensym"
             (do (let ((= f (macroFunction defmacro*))))
                 (<- (Right e) (f '(defmacro* m1 (a b)
                                    (let ((= $foo (+ ,a ,b)))
                                      (return $foo)))))
                 (shouldNotBe (elem (aSymbol "$foo") e) True))))

      (d "macrolet*"
         (it "should expand to let-macro"
             (expandTo
              (macrolet* ((m (a b)
                            (return `(+ ,a ,b))))
                (m 20 22))
              (let-macro ((m *form*
                            (case *form*
                              (LForm (L _loc (List [_ a b])))
                              (return (quasiquote
                                       (+ (unquote a) (unquote b))))
                              _
                              (skSrcError
                               *form*
                               (concat [(show (quote m))
                                        "\ninvalid args: `"
                                        (show *form*)
                                        "'"])))))
                (m 20 22)))))

      (d "macrolet"
         (it "should expand to let-macro with `return'"
             (expandTo
              (macrolet ((m (a b)
                           `(+ ,a ,b)))
                (m 20 22))
              (let-macro ((m *form*
                            (case *form*
                              (LForm (L _loc (List [_ a b])))
                              (return (quasiquote (+ (unquote a)
                                                     (unquote b))))
                              _
                              (skSrcError
                               *form*
                               (concat [(show (quote m))
                                        "\ninvalid args: `"
                                        (show *form*) "'"])))))
                (m 20 22)))))

      (d "defn"
         (do (it "should expand to function declaration"
                 (expandTo
                  (defn foo (a b) (+ a b))
                  (= foo a b (+ a b))))
             (it "should expand to function with type signature"
                 (expandTo
                  (defn (foo (-> Int Int Int)) (a b)
                    (+ a b))
                  (begin
                    (:: foo (-> Int Int Int))
                    (= foo a b (+ a b)))))))

      (d "defn+"
         (it "should expand to (eval-when (..) (defn ...))"
             (expandTo
              (defn+ foo (a b)
                (+ a b))
              (eval-when (compile load)
                (defn foo (a b)
                  (+ a b))))))

      (d "list"
         (it "should expand to foldr"
             (expandTo
              (list \x \y \z)
              (foldr cons (quote ()) [(toCode \x)
                                      (toCode \y)
                                      (toCode \z)]))))

      (d "macroexpand-1"
         (it "should expand to '(toCode 3)"
             (expandTo
              (macroexpand-1 '(quasiquote (unquote 3)))
              '(toCode 3))))

      (d "macroexpand"
         (it "should expand to '(toCode 3)"
             (expandTo
              (macroexpand '(quasiquote (unquote 3)))
              '(toCode 3))))

      (d "cond"
         (it "should expand to case"
             (expandTo
              (cond ((even x) 0) (otherwise 1))
              (case () _ (| ((even x) 0) (otherwise 1))))))))

(defn (listTests Spec) ()
  (do (let ((= d describe)))
      (d "car of (cons x xs)"
         (it "should be x"
             (let ((:: f (-> Code Code Property))
                   (= f x xs
                     (==> (list? xs) (== x (car (cons x xs))))))
               (property f))))
      (d "cdr of (cons x xs)"
         (it "should be xs"
             (let ((:: f (-> Code Code Property))
                   (= f x xs
                     (==> (list? xs) (== xs (cdr (cons x xs))))))
               (property f))))
      (d "list of x, y, and z"
         (it "should be a list"
             (let ((:: f (-> Int Char String Bool))
                   (= f x y z
                     (list? (list x y z))))
               (property f))))
      (d "length of atom"
         (it "should be 1"
             (let ((:: f (-> Code Property))
                   (= f x
                     (==> (atom? x) (== 1 (length x)))))
               (property f))))
      (d "mapcar"
         (it "should replace non-symbols"
             (shouldBe '(foo bar _ buzz _ _)
                       (mapcar (\ x (if (symbol? x) x '_))
                               '(foo bar (a b c) buzz 3 "string")))))
      (d "append"
         (it "should show sum of the length"
             (let ((:: f (-> Code Code Property))
                   (= f x y
                     (==> (&& (list? x) (list? y))
                          (== (length (append x y))
                              (+ (length x) (length y))))))
               (property f))))))
