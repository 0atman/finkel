;;;; Forms containing type declarations.

(module Main)

;;; 4.2 User-Defined Datatypes

;;; 4.2.1 Algebraic Datatype Declarations

(data MyData1
  (MyD1Con1 Int Bool ())
  (MyD1Con2 [(, Int Int)] Double Char)
  (deriving (Eq Show)))

(data (MyData2 a b)
  (MyD2Con1 a b)
  (MyD2Con2 a a Bool)
  (deriving (Eq Show)))

(data (MyData3 a)
  (MyD3Con1 {d3f1 a
             d3f2 (Maybe FilePath)})
  (MyD3Con2 Int Int Int)
  (MyD3Con3 {(d3f1 d3f1b d3f1c) a
             d3f4 (Either Bool Char)})
  (deriving (Eq Show)))

(data MyData4
  M4A M4B M4C M4D
  (deriving (Eq Show)))

(:: s4_2_1 (IO ()))
(= s4_2_1
  (do (print (MyD1Con1 123 True ()))
      (print (MyD1Con2 [(, 1 2) (, 3 4)] 1.23 \z))
      (print [(MyD2Con1 (:: 123 Int) \z)
              (MyD2Con2 (:: 789 Int) 0 False)])
      (print (MyD3Con1 \x (Just "/foo/bar")))
      (print (:: (MyD3Con2 1 2 3) (MyData3 Double)))
      (print (MyD3Con3 \a \b \c (Right \z)))
      (print [M4A M4B M4C])))

;;; 4.2.3 Datatype Renamings

(newtype (N1 a) (N1 a))

(instance (=> (Show a) (Show (N1 a)))
  (= (show (N1 a))
    (++ "N1 " (show a))))

(newtype (N2 a) (N2 a)
  (deriving (Eq Show)))

(newtype (N3 a) (N3 {unN3 a}))

(instance (=> (Show a) (Show (N3 a)))
  (= (show (N3 a))
    (++ "N3 " (show a))))

(newtype (N4 a) (N4 {unN4 a})
  (deriving (Eq Show)))

(:: s4_2_3 (IO ()))
(= s4_2_3
  (do (print (N1 1))
      (print (N2 2))
      (print (N3 3))
      (print (N4 4))))

(:: s4_2 (IO ()))
(= s4_2
  (do s4_2_1
      s4_2_3))

;;; 4.3 Type Classes and Overloading

;;; 4.3.2 Instance Declarations

(data (MyFnct a)
  (MyFnct {unMyFnct a})
  (deriving (Eq Show)))

(instance (Functor MyFnct)
  (= (fmap f (MyFnct a)) (MyFnct (f a))))

(:: s4_3 (IO ()))
(= s4_3
  (do (print (fmap (* 2) (MyFnct 21)))))

;;; 4.4 Nested Declarations

;; Unit type.
(:: foo ())
(= foo
  ())

;;; Simple function type.
(:: bar (-> String (IO ())))
(= (bar str)
  (putStrLn (++ "From bar: " str)))

;;; Another function type, taking multiple arguments.
(:: buzz (-> Int (-> Bool (-> String (IO ())))))
(= (buzz i b s)
  (do (putStrLn (++ "Int: " (show i)))
      (putStrLn (++ "Bool: " (show b)))
      (putStrLn (++ "String: " (show s)))))

;;; Function type operator '->' takes variable arguments, explicit
;;; parentheses are optional.
(:: buzz2 (-> Int Bool String (IO ())))
(= (buzz2 i b s)
  (do (putStrLn (++ "Int: " (show i)))
      (putStrLn (++ "Bool: " (show b)))
      (putStrLn (++ "String: " (show s)))))

;;; Function taking higher order function.
(:: quux (-> (-> Int Int) Int))
(= (quux f)
  (f 6))

;;; Function taking list.
(:: listy (-> [Int] (IO ())))
(= (listy xs)
  (mapM_ print xs))

;;; Function with type variables.
(:: tv01 (-> a [b] Int))
(= (tv01 x ys)
  (length ys))

;;; Main.
(:: main (IO ()))
(= main
  (do s4_2
      s4_3
      (print foo)
      (bar "BAR")
      (buzz 1 True "buzz")
      (print (quux (\ (n) (* (+ n 1) n))))
      (listy [1 2 3])
      (print (tv01 True [1 2 3]))))
