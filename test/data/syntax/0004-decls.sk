;;;; Forms containing type declarations.

(module Main)

;;; 4.2 User-Defined Datatypes

;;; 4.2.1 Algebraic Datatype Declarations

(data MyData1
  (MyD1Con1 Int Bool ())
  (MyD1Con2 [(, Int Int)] Double Char)
  (deriving (Eq Show)))

(data (MyData2 a b)
  (MyD2Con1 a b)
  (MyD2Con2 a a Bool)
  (deriving (Eq Show)))

(data (MyData3 a)
  (MyD3Con1 {d3f1 a
             d3f2 (Maybe FilePath)})
  (MyD3Con2 Int Int Int)
  (MyD3Con3 {(d3f1 d3f1b d3f1c) a
             d3f4 (Either Bool Char)})
  (deriving (Eq Show)))

(data MyData4
  M4A M4B M4C M4D
  (deriving (Eq Show)))

(:: s4_2_1 (IO ()))
(= s4_2_1
  (do (print (MyD1Con1 123 True ()))
      (print (MyD1Con2 [(, 1 2) (, 3 4)] 1.23 \z))
      (print [(MyD2Con1 (:: 123 Int) \z)
              (MyD2Con2 (:: 789 Int) 0 False)])
      (print (MyD3Con1 \x (Just "/foo/bar")))
      (print (:: (MyD3Con2 1 2 3) (MyData3 Double)))
      (print (MyD3Con3 \a \b \c (Right \z)))
      (print [M4A M4B M4C])))

;;; 4.2.2 Type Synonym Declarations

(type (Synonym1 a) (Maybe (Either String a)))
(type Synonym2 (Synonym1 Int))

(:: syn1a (Synonym1 Bool))
(= syn1a (Just (Left "syn1a")))

(:: syn2a Synonym2)
(= syn2a Nothing)

(:: s4_2_2 (IO ()))
(= s4_2_2
  (do (print syn1a)
      (print syn2a)))

;;; 4.2.3 Datatype Renamings

(newtype (N1 a) (N1 a))

(instance (=> (Show a) (Show (N1 a)))
  (= (show (N1 a))
    (++ "N1 " (show a))))

(newtype (N2 a) (N2 a) (deriving (Eq Show)))

(newtype (N3 a) (N3 {unN3 a}))

(instance (=> (Show a) (Show (N3 a)))
  (= (show (N3 a))
    (++ "N3 " (show a))))

(newtype (N4 a) (N4 {unN4 a}) (deriving (Eq Show)))

(:: s4_2_3 (IO ()))
(= s4_2_3
  (do (print (N1 1))
      (print (N2 2))
      (print (N3 3))
      (print (N4 4))))

(:: s4_2 (IO ()))
(= s4_2
  (do s4_2_1
      s4_2_2
      s4_2_3))

;;; 4.3 Type Classes and Overloading

;;; 4.3.1 Class Declarations

;;; Not yet implemented.

;;; 4.3.2 Instance Declarations

(data (MyFnct a)
  (MyFnct {unMyFnct a})
  (deriving (Eq Show)))

(instance (Functor MyFnct)
  (= (fmap f (MyFnct a)) (MyFnct (f a))))

(data (EmptyContext a) (EmptyContext Int))

(instance (=> () (Show (EmptyContext a)))
  (= (show (EmptyContext n)) (++ "EmptyContext " (show n))))

(data (MCs a b) (MCs a b))

(instance (=> (Show a) (Show b) (Show (MCs a b)))
  (= (show (MCs a b)) (concat ["MCs " (show a) " " (show b)])))

(:: s4_3 (IO ()))
(= s4_3
  (do (print (fmap (* 2) (MyFnct 21)))
      (print (EmptyContext 42))
      (print (MCs True \a))))

;;; 4.4 Nested Declarations

;;; 4.4.1 Type signatures

;; Unit type.
(:: ts1 ())
(= ts1 ())

;;; Simple function type.
(:: ts2 (-> String (IO ())))
(= (ts2 str)
  (putStrLn (++ "From ts2: " str)))

;;; Another function type, taking multiple arguments.
(:: ts3 (-> Int (-> Bool (-> String (IO ())))))
(= (ts3 i b s)
  (do (putStrLn (++ "Int: " (show i)))
      (putStrLn (++ "Bool: " (show b)))
      (putStrLn (++ "String: " (show s)))))

;;; Function type operator '->' takes variable arguments, explicit
;;; parentheses are optional.
(:: ts3b (-> Int Bool String (IO ())))
(= (ts3b i b s)
  (do (putStrLn (++ "Int: " (show i)))
      (putStrLn (++ "Bool: " (show b)))
      (putStrLn (++ "String: " (show s)))))

;;; Function taking higher order function.
(:: ts4 (-> (-> Int Int) Int))
(= (ts4 f)
  (f 6))

;;; Function taking list.
(:: ts5 (-> [Int] (IO ())))
(= (ts5 xs)
  (mapM_ print xs))

;;; Function with type variables.
(:: ts6 (-> a [b] Int))
(= (ts6 x ys)
  (length ys))

(:: s4_4_1 (IO ()))
(= s4_4_1
  (do (print ts1)
      (ts2 "BAR")
      (ts3 1 True "buzz")
      (ts3b 2 False "buzzz")
      (print (ts4 (\ (n) (* (+ n 1) n))))
      (ts5 [1 2 3])
      (print (ts6 True [1 2 3]))))

;;; 4.4.3 Function and Pattern Bindinds

;;; 4.4.3.1 Function bindings

;;; Function without guards.
(:: fpb0 (-> Int String))
(= (fpb0 n)
  (++ "f0 got " (show n)))

;;; Function with guards.
(:: fpb1 (-> Int String))
(= (fpb1 n)
  (| ((even n) "even")
     (otherwise "odd")))

;;; Function with pattern guards.
(:: fpb2 (-> (Maybe Int) (Maybe Int) String))
(= (fpb2 a b)
  (| ((<- (Just n) a) (<- (Just m) b) (even n) (even m)
      "f2: got two even numbers.")
     ((<- (Just n) a) (<- (Just m) b)
      (++ "f2: got two numbers, sum = " (show (+ n m))))
     ((<- (Just n) a)
      "f2: b was nothing.")
     ((<- (Just n) b)
      "f2: a was nothing")
     (otherwise
      "f2: no numbers.")))

(:: fpb3 [String])
(= fpb3 ["string" "expression" "without" "guards"])

;;; 4.4.3.2 Pattern Bindings

(:: (xs ys) [Int])
(= (, xs ys)
  (break (> 5) (enumFromTo 1 10)))

(:: addJust (-> Int Int (Maybe Int)))
(= (addJust a b) (Just (+ a b)))

(:: tpb1 Int)
(= (Just tpb1) (addJust 16 27))

(:: tpb2 Int)
(= [_ _ tpb2 _]
  (enumFrom 40))

(:: tpb3 Int)
(= (: tpb3 _)
  (enumFrom 42))

(:: s4_4_3 (IO ()))
(= s4_4_3
  (do (putStrLn (fpb0 42))
      (putStrLn (fpb1 10))
      (putStrLn (fpb1 11))
      (putStrLn (fpb2 (Just 2) (Just 4)))
      (putStrLn (fpb2 (Just 2) (Just 5)))
      (putStrLn (fpb2 (Just 100) Nothing))
      (putStrLn (fpb2 (Nothing) (Just 8)))
      (putStrLn (fpb2 Nothing Nothing))
      (print fpb3)
      (putStrLn (++ "xs: " (show xs)))
      (putStrLn (++ "ys: " (show ys)))
      (putStrLn (++ "tpb1: " (show tpb1)))
      (putStrLn (++ "tpb2: " (show tpb2)))
      (putStrLn (++ "tpb3: " (show tpb3)))))

(:: s4_4 (IO ()))
(= s4_4
  (do s4_4_1
      s4_4_3))

;;; Main.
(:: main (IO ()))
(= main
  (do s4_2
      s4_3
      s4_4))
