;;; -*- mode: sk -*-

(module Main)

;;; Simple expressions

(= simple1 a b
  (+ (* a (simple2 (+ a b) (+ a b) a))
     (* (simple2 (* b b) (* a a) (* a b)) b)))

(= simple2 x y z
  (* (+ x (* y z))
     (+ y (* x z))))

(= factorial n
   (if (== n 1)
       1
       (* n (factorial (- n 1)))))

(= simples
  (>> (print (simple1 3 4))
      (print (factorial 10))))

;;; 3.3 Curried Applications and Lambda Abstractions

;;; This function takes single argument which is a function, and applies
;;; 3 and 11 to it.
(= lam1 f
  (f 3 11))

;;; Calls `lam1' defined above.
(= lam2
  (print (lam1 (\ a b
                 (* a (+ a b))))))

(= lamexprs
  lam2)

;;; 3.8 Tuples

(:: tup1 (-> a (-> b (-> c (, a b c)))))
(= tup1 a b c
  (, a b c))

(= tupexprs
  (print (tup1 \x \y \z)))

;;; 3.12 Let Expressions

;;; Expression with empty 'let'.
(= let1 n
  (let ()
    (+ n 35)))

;;; Expression with 'let'. In bindings of `let', 'a' is a integer value
;;; 14, and `f' is a function taking two arguments.
(= let2 n
  (let ((:: a Int)
        (= a 14)
        (:: f (-> Int Int Int))
        (= f x y
          (+ x y))
        (:: g (-> Int Int))
        (= g (\ x (* x 2))))
    (g (f n a))))

(= letexprs
  (do (print (let1 7))
      (print (let2 7))))

;;; 3.13 Case Expressions

(= case1 x
  (case x
    ((Just n) (+ n 1))
    (_ 0)))

(= case2 x
  (case x
    ((Right (Just _)) 1)
    ((Right Nothing) 2)
    ((Left (Just _)) 3)
    ((Left Nothing) 4)))

(:: mbeven (-> Int (Maybe Int)))
(= mbeven n
  (if (even n)
      (Just n)
      Nothing))

(:: case3 (-> (Maybe Int) Int String))
(= case3 x y
  (case x
    ((Just n) (| ((odd n) (> n 100)
                  "small odd number")
                 ((odd n)
                  "big odd number")
                 ((<- (Just m) (mbeven n))
                  (let ((:: k Int)
                        (= k (+ m 1))))
                  (< k 101)
                  "small even number")
                 (otherwise
                  "big even number")))
    (Nothing (| ((even y) "y is even")
                (otherwise "y is odd")))))

(= caseexprs
  (do (print (case1 (Just 41)))
      (print (case1 Nothing))
      (print (case2 (Right (Just ()))))
      (print (case3 (Just 42) 12))))

;;; 3.14 Do Expressions

(= showBar x
  (do (putStrLn "String `bar' from showBar.")
      (return x)))

(= listdo
  (do (<- x [1 2 3])
      (<- y [4 5 6])
      [x y]))

(= doexpres
  (do (putStrLn "foo")
      (<- buzz (showBar "buzz"))
      (let ((:: (buzz3 buzz4) String)
            (= buzz3 (concat [buzz buzz buzz]))
            (= buzz4 "buzz4")))
      (putStrLn buzz3)
      (putStrLn buzz4)
      (print listdo)))

;;; 3.15 Datatypes with Field Labels

(data R1
  (Con1 {field1 Int
         field2 Bool})
  (deriving (Eq Show)))

(:: mkR1 (-> Int (-> Bool R1)))
(= mkR1 a b
  (Con1 {field1 a field2 b}))

(= fieldexprs
  (do (let ((:: (r1 r2) R1)
            (= r1 (Con1 {field2 False
                         field1 42}))
            (= r2 (r1 {field1 (* (field1 r1) 2)}))
            (= r3 ((mkR1 21 True) {field1 12}))))
      (print r1)
      (print r2)
      (print r3)))

;;; 3.16 Expression Type-Signatures

(= f2 n
  (if (< n (:: 2 Int))
      n
      (+ (f2 (- n 1))
         (f2 (- n 2)))))

(= tsigexprs
  (print (f2 10)))

;;; 3.17 Pattern Matching

;;; Top level functions with pattern matches.

(= fib 0 0)
(= fib 1 1)
(= fib n (+ (fib (- n 1))
            (fib (- n 2))))

(= bar Nothing "bar got nothing")
(= bar _ "bar got something")

(= buzz (Just n)
  (putStrLn (++ "buzz: " (show n))))
(= buzz _
  (putStrLn "buzz got nothing"))

(= addMaybes Nothing Nothing 0)
(= addMaybes (Just a) Nothing a)
(= addMaybes Nothing (Just b) b)
(= addMaybes (Just a) (Just b) (+ a b))

(= nest1 Nothing 0)
(= nest1 (Just (Right n)) n)
(= nest1 (Just (Left True)) 9999)
(= nest1 (Just (Left False)) 42)

(= lp1 [] 0)
(= lp1 [a] 1)
(= lp1 [(Just x) (Just y)] (+ x y))
(= lp1 [a b] 2)
(= lp1 _ 999)

(= patexprs1
  (do (print (fib 10))
      (putStrLn (bar Nothing))
      (putStrLn (bar (Just undefined)))
      (buzz (Just 3))
      (print (addMaybes Nothing Nothing))
      (print (addMaybes (Just 2) Nothing))
      (print (addMaybes Nothing (Just 3)))
      (print (addMaybes (Just 2) (Just 3)))
      (print (nest1 Nothing))
      (print (nest1 (Just (Right 3))))
      (print (nest1 (Just (Left True))))
      (print (lp1 []))
      (print (lp1 [Nothing]))
      (print (lp1 [Nothing Nothing]))
      (print (lp1 [(Just 28) (Just 14)]))
      (print (lp1 [Nothing (Just 1) Nothing]))))

(:: tupp1 (-> (, a b) a))
(= tupp1 (, a _) a)

(:: tupp2 (-> (, Char Char Char) Char))
(= tupp2 x
  (case x
    ((, _ _ c) c)))

(:: intpat (-> Int String))
(= intpat x
  (case x
    (1 "one")
    (2 "two")
    (_ "unknown")))

(:: strpat (-> String String))
(= strpat x
  (case x
    ("foo" "GOT FOO")
    ("bar" "GOT BAR")
    (_ "UNKNOWN")))

(:: charpat (-> Char String))
(= charpat x
  (case x
    (\a "GOT A")
    (\b "GOT B")
    (_ "UNKNOWN")))

(= patexprs2
  (do (print (tupp1 (, True False)))
      (print (tupp2 (, \a \b \c)))
      (print (intpat 1))
      (print (intpat 2))
      (print (intpat 3))
      (print (strpat "foo"))
      (print (strpat "bar"))
      (print (strpat "buzz"))
      (print (charpat \a))
      (print (charpat \X))))

(= patexprs
  (do patexprs1
      patexprs2))

;;; Main

(= main
  (do simples
      lamexprs
      tupexprs
      letexprs
      caseexprs
      doexpres
      fieldexprs
      tsigexprs
      patexprs))
