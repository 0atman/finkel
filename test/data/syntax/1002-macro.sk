;;; Tests for macros.

(module Main)

(import Language.SK)

;; Simple version of `defmacro' defined with `define-macro'
(define-macro defmacro form
  (case form
    (LForm (L _ (List [_self name args body])))
    (case args
      (LForm (L _ (List _)))
      (return
        `(define-macro ,name form
           (case form
             (LForm (L l1 (List [_ ,@args]))) (return ,body)
             _ (failS (++ (show ',name) ": error")))))
      _ (return `(define-macro ,name ,args
                   (return ,body))))
    _ (failS "defmac: error")))

;;; Using `defmacro' defined above.
(defmacro m1 (x y)
  `(putStrLn (concat [,x ", " ,y])))

(define-macro m2 form
  (where (case form
           (LForm (L _ (List [_self arg1 arg2])))
           (return (mkbody arg1 arg2)))
    (= mkbody x y
      `(print (+ (:: ,x Int) (:: ,y Int))))))

;; Simple `let-macro'.
(let-macro ((m2a form
              (case form
                (LForm (L _ (List [_ a b c]))) (return `(,a (+ ,b ,c)))
                _ (failS "m2a: error")))
            (m2b form
              (case form
                (LForm (L _ (List [_ x y]))) (return `(+ ,x ,y))
                _ (failS "m2b: error"))))
  (:: f1 (-> Int Int (IO ())))
  (= f1 x y
    (m2a print x (m2b x y))))

;;; Macro taking fractional value as argument.
(let-macro ((m1 form
              (case form
                (LForm (L l (List [_ x])))
                (case (fromCode x)
                  (Just d) (if (<= 1.0 (:: d Double))
                               (return '"more or eq to one")
                               (return '"less than one"))
                  Nothing (return '"not a double"))
                _ (failS "m1: invalid args"))))
  (:: fracmac (IO ()))
  (= fracmac
    (do (putStrLn (m1 1.1))
        (putStrLn (m1 0.9))
        (putStrLn (m1 \x)))))

;;; Macro returning haskell list.
(let-macro ((m2 form
              (case form
                (LForm (L l (List [_ a b c])))
                (let ((:: mbints (Maybe (, Int Int Int)))
                      (= mbints
                        (do (<- x (fromCode a))
                            (<- y (fromCode b))
                            (<- z (fromCode c))
                            (return (, x y z)))))
                  (case mbints
                    (Just (, x y z))
                    (return `[,(* x 100) ,(* y 100) ,(* z 100)])
                    _ (failS "m2: invalid args")))
                _ (failS "m2: invalid form"))))
  (:: hslistmac (IO ()))
  (= hslistmac
    (print (m2 1 2 3))))

(:: main (IO ()))
(= main
  (do (m1 "Hello" "macro")
      (m2 11 31)
      (f1 11 20)
      fracmac
      hslistmac))
