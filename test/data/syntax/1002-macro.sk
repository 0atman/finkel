;;; Tests for macros.

(module Main)

(import SK.Core)

;; Simple `defmacro' definition by `define-macro'
(define-macro defmacro (form)
  (case form
    ((List [name arg body])
     (case arg
       ((List list-args)
        (return `(define-macro ,name (form)
                   (case form
                     ((List ,list-args) (return ,body))
                     (_ (failS (++ (show ',name) ": error")))))))
       ((Atom (ASymbol _))
        (return `(define-macro ,name (,arg)
                   (return ,body))))))
    (_ (failS "defmac: error"))))

;;; Using `defmacro' defined above.
(defmacro m1 (x y)
  `(putStrLn (concat [,x ", " ,y])))

;; Simple `macrolet'.
(macrolet ((m2a (a b c)
             (return `(,a (+ ,b ,c))))
           (m2b (x y)
             (return `(+ ,x ,y))))
  (:: f1 (-> Int Int (IO ())))
  (= (f1 x y)
    (m2a print x (m2b x y))))

;;; Macro taking fractional value as argument.
(macrolet ((m1 (n)
             (case (fromCode n)
               ((Just d) (if (<= 1.0 (:: d Double))
                             (return '"more or eq")
                             (return '"less")))
               (Nothing (failS "m1: error")))))
  (:: fracmac (IO ()))
  (= fracmac
    (do (putStrLn (m1 1.1))
        (putStrLn (m1 0.9)))))

;;; Macro returning haskell list.
(macrolet ((m2 (a b c)
             (let ((:: mbints (Maybe (, Int Int Int)))
                   (= mbints
                     (do (<- x (fromCode a))
                         (<- y (fromCode b))
                         (<- z (fromCode c))
                         (return (, x y z)))))
               (case mbints
                 ((Just (, x y z))
                  (return `[,(* x 100) ,(* y 100) ,(* z 100)]))
                 (_ (failS "error: m2"))))))
  (:: hslistmac (IO ()))
  (= hslistmac
    (print (m2 1 2 3))))

(:: main (IO ()))
(= main
  (do (m1 "Hello" "macro")
      (f1 11 20)
      fracmac
      hslistmac))
