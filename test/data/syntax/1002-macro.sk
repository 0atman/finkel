;;; Tests for macros.

(module Main)

(import SK.Core)

;; Simplified version of `defmacro' defined with `define-macro'
(define-macro defmacro (form)
  (case form
    ((L l0 (TList [_self name args body]))
     (let ((= loc (locateForm l0)))
       (case args
         ((L _ (TList _))
          (return
            (loc `(define-macro ,name (form)
                    (case form
                      ((L l1 (TList [_ ,@args]))
                       (return (locateForm l1 ,body)))
                      (_ (failS (++ (show ',name) ": error"))))))))
         (_
          (return (loc `(define-macro ,name (,args)
                          (return ,body))))))))
    (_ (failS "defmac: error"))))

;;; Using `defmacro' defined above.
(defmacro m1 (x y)
  `(putStrLn (concat [,x ", " ,y])))

;; Simple `let-macro'.
(let-macro ((m2a (form)
              (case form
                ((L l (TList [_ a b c]))
                 (return (locateForm l `(,a (+ ,b ,c)))))
                (_ (failS "m2a: error"))))
            (m2b (form)
              (case form
                ((L l (TList [_ x y]))
                 (return (locateForm l `(+ ,x ,y))))
                (_ (failS "m2b: error")))))
  (:: f1 (-> Int Int (IO ())))
  (= (f1 x y)
    (m2a print x (m2b x y))))

;;; Macro taking fractional value as argument.
(let-macro ((m1 (form)
             (case form
               ((L l (TList [_ x]))
                (case (fromCode (unLocForm x))
                  ((Just d)
                   (if (<= 1.0 (:: d Double))
                       (return (locateForm l '"more or eq to one"))
                       (return (locateForm l '"less than one"))))
                  (Nothing
                   (return (locateForm l '"not a double")))))
               (_
                (failS "m1: invalid args")))))
  (:: fracmac (IO ()))
  (= fracmac
    (do (putStrLn (m1 1.1))
        (putStrLn (m1 0.9))
        (putStrLn (m1 \x)))))

;;; Macro returning haskell list.
(let-macro ((m2 (form)
              (case form
                ((L l (TList [_ a b c]))
                 (let ((:: mbints (Maybe (, Int Int Int)))
                       (= mbints
                         (do (<- x (fromCode (unLocForm a)))
                             (<- y (fromCode (unLocForm b)))
                             (<- z (fromCode (unLocForm c)))
                             (return (, x y z)))))
                   (case mbints
                     ((Just (, x y z))
                      (return
                        (locateForm l `[,(* x 100)
                                        ,(* y 100)
                                        ,(* z 100)])))
                     (_ (failS "m2: invalid args")))))
                (_ (failS "m2: invalid form")))))
  (:: hslistmac (IO ()))
  (= hslistmac
    (print (m2 1 2 3))))

(:: main (IO ()))
(= main
  (do (m1 "Hello" "macro")
      (f1 11 20)
      fracmac
      hslistmac))
