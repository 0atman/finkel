;;; -*- mode: sk -*-

(module Main)

;;; Simple expressions

(= (simple1 a b)
   (+ (* a (simple2 (+ a b) (+ a b) a))
      (* (simple2 (* b b) (* a a) (* a b)) b)))

(= (simple2 x y z)
   (* (+ x (* y z))
      (+ y (* x z))))

(= (factorial n)
   (if (== n 1)
       1
       (* n (factorial (- n 1)))))

(= simples
  (>> (print (simple1 3 4))
      (print (factorial 10))))

;;; 3.3 Curried Applications and Lambda Abstractions

;;; This function takes single argument which is a function, and applies
;;; 3 and 11 to it.
(= (lam1 f)
  (f 3 11))

;;; Calls `lam1' defined above.
(= lam2
  (print (lam1 (\ (a b)
                  (* a (+ a b))))))

(= lamexprs
  lam2)

;;; 3.8 Tuples

(:: tup1 (-> a (-> b (-> c (, a b c)))))
(= (tup1 a b c)
  (, a b c))

(= tupexprs
  (print (tup1 \x \y \z)))

;;; 3.12 Let Expressions

;;; Expression with empty 'let'.
(= (let1 n)
  (let ()
    (+ n 35)))

;;; Expression with 'let'. In bindings of `let', 'a' is a integer value
;;; 14, and `f' is a function taking two arguments.
(= (let2 n)
  (let ((:: a Int)
        (= a 14)
        (:: f (-> Int (-> Int Int)))
        (= (f x y)
          (+ x y))
        (:: g (-> Int Int))
        (= g (\ (x) (* x 2))))
    (g (f n a))))

(= letexprs
  (do (print (let1 7))
      (print (let2 7))))


;;; 3.14 Do Expressions

(= (showBar x)
  (do (putStrLn "String `bar' from showBar.")
      (return x)))

(= doexpres
  (do (putStrLn "foo")
      (<- buzz (showBar "buzz"))
      (putStrLn buzz)))

;;; 3.16 Expression Type-Signatures

;; Expression with explicit type signature
(= (f2 n)
  (if (< n (:: 2 Int))
      n
      (+ (f2 (- n 1))
         (f2 (- n 2)))))

(= tsigexprs
  (print (f2 10)))

;;; 3.17 Pattern Matching

;;; Top level functions with pattern matches.

(= (fib 0) 0)
(= (fib 1) 1)
(= (fib n) (+ (fib (- n 1))
              (fib (- n 2))))

(= (bar Nothing) "bar got nothing")
(= (bar _) "bar got something")

(= (buzz (Just n))
  (putStrLn (++ "buzz: " (show n))))
(= (buzz _)
  (putStrLn "buzz got nothing"))

(= (addMaybes Nothing Nothing) 0)
(= (addMaybes (Just a) Nothing) a)
(= (addMaybes Nothing (Just b)) b)
(= (addMaybes (Just a) (Just b)) (+ a b))

(= (nest1 Nothing) 0)
(= (nest1 (Just (Right n))) n)
(= (nest1 (Just (Left True))) 9999)
(= (nest1 (Just (Left False))) 42)

(= (lp1 []) 0)
(= (lp1 [a]) 1)
(= (lp1 [a b]) 2)
(= (lp1 [(Just x) (Just y)]) (+ x y))
(= (lp1 _) 999)

(= patexprs1
  (do (print (fib 10))
      (putStrLn (bar Nothing))
      (putStrLn (bar (Just undefined)))
      (buzz (Just 3))
      (print (addMaybes Nothing Nothing))
      (print (addMaybes (Just 2) Nothing))
      (print (addMaybes Nothing (Just 3)))
      (print (addMaybes (Just 2) (Just 3)))
      (print (nest1 Nothing))
      (print (nest1 (Just (Right 3))))
      (print (nest1 (Just (Left True))))
      (print (lp1 []))
      (print (lp1 [Nothing]))
      (print (lp1 [Nothing Nothing]))
      (print (lp1 [(Just 28) (Just 14)]))
      (print (lp1 [Nothing (Just 1) Nothing]))))

(:: tupp1 (-> (, a b) a))
(= (tupp1 (, a _)) a)

(:: tupp2 (-> (, Char Char Char) Char))
(= (tupp2 x)
  (case x
    (, _ _ c) c))

(= patexprs2
  (do (print (tupp1 (, True False)))
      (print (tupp2 (, \a \b \c)))))

(= patexprs
  (do patexprs1
      patexprs2))

;;; Main

(= main
  (do simples
      lamexprs
      tupexprs
      letexprs
      doexpres
      tsigexprs
      patexprs))
